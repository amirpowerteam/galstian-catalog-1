<!DOCTYPE html>
<html lang="en" dir="ltr" class="dark">

<head>
    <meta charset="UTF-8" />
    <title>GALSTIAN Catalog</title>
    <script>
        // Fallback handler: if an <img> or <video> fails to load and its src references
        // /uploaded_media or /deploy, try loading the file from raw.githubusercontent.com once.
        (function(){
            try {
                const USER = 'amirpowerteam';
                const REPO = 'galstian-catalog-1';
                // Track URLs we've already tried (to avoid noisy repeated retries)
                const FAILED_MEDIA = new Set();
                const tryRawFallback = (el) => {
                    try {
                        if (!el) return;
                        const src = el.currentSrc || el.src || el.getAttribute && el.getAttribute('src');
                        if (!src || typeof src !== 'string') return;
                        // Avoid retrying same URL repeatedly
                        if (FAILED_MEDIA.has(src)) { console.warn('Already tried fallback for', src); return; }
                        const m = src.match(/(?:\/([^\/]+)\/)?(uploaded_media\/.*)$/);
                        if (!m) return;
                        const path = m[1] ? (m[1] + '/' + m[2]) : m[2];
                        const rawUrl = `https://raw.githubusercontent.com/${USER}/${REPO}/main/${path.replace(/^\//, '')}`;
                        el.dataset.triedRawFallback = '1';
                        FAILED_MEDIA.add(src);
                        // For <video>, try setting src and load; for <img>, set src
                        if (el.tagName === 'VIDEO' || el.tagName === 'AUDIO' || el.tagName === 'SOURCE') {
                            el.src = rawUrl;
                            try { el.load && el.load(); } catch(e){}
                        } else if (el.tagName === 'IMG') {
                            el.src = rawUrl;
                        } else {
                            // generic setAttribute fallback
                            try { el.setAttribute('src', rawUrl); } catch(e){}
                        }
                        console.info('Tried raw.githubusercontent fallback for media:', rawUrl, 'original:', src);
                    } catch(e){}
                };

                window.addEventListener('error', function(ev){
                    try {
                        const target = ev.target || ev.srcElement;
                        if (!target) return;
                        const tag = (target.tagName || '').toUpperCase();
                        if (tag === 'IMG' || tag === 'VIDEO' || tag === 'AUDIO' || tag === 'SOURCE') {
                            tryRawFallback(target);
                        }
                    } catch(e){}
                }, true);
            } catch(e) { console.warn('raw fallback init failed', e); }
        })();
        // Safety guards: ignore accidental assignments or fetch calls with null/"null".
        (function(){
            try {
                const origFetch = window.fetch && window.fetch.bind(window);
                if (origFetch) {
                    window.fetch = function(input, init) {
                        if (input == null) return Promise.reject(new TypeError('fetch called with null or undefined'));
                        if (typeof input === 'string' && input.trim().toLowerCase() === 'null') return Promise.reject(new TypeError('fetch called with string "null"'));
                        return origFetch(input, init);
                    };
                }
            } catch (e) { console.warn('Failed to patch fetch guard', e); }

            // Prevent setting element.src to null which triggers requests to /null
            try {
                const patchSetter = (proto) => {
                    const desc = Object.getOwnPropertyDescriptor(proto, 'src');
                    if (!desc || typeof desc.set !== 'function') return;
                    const origSet = desc.set;
                    Object.defineProperty(proto, 'src', {
                        configurable: true,
                        enumerable: desc.enumerable,
                        get: desc.get,
                        set: function(v) {
                            try {
                                if (v == null) return; // ignore null/undefined
                                if (typeof v === 'string') {
                                    const s = v.trim();
                                    if (!s) return;
                                    const low = s.toLowerCase();
                                    if (low === 'null') return; // ignore literal 'null'
                                    if (s.indexOf('<<REDACTED') !== -1) return; // ignore scrubbed placeholders
                                    if (s[0] === '<') return; // ignore accidental angle-bracket placeholders
                                }
                            } catch (e) { /* ignore guard errors */ }
                            // Normalize absolute repo-root paths for GitHub Pages
                            try {
                                if (typeof v === 'string') {
                                    const repoParts = (location.pathname || '').split('/').filter(Boolean);
                                    const repoBase = repoParts.length ? repoParts[0] : null;
                                    // If value is like '/uploaded_media/...' or '/deploy/...' and not already prefixed with repoBase,
                                    // rewrite to include the repo base so it resolves under /<repo>/uploaded_media/... on GitHub Pages.
                                    if (repoBase && v.startsWith('/') && !v.startsWith('/' + repoBase) && (/^\/(uploaded_media|deploy|assets)\//.test(v))) {
                                        const newV = '/' + repoBase + (v.startsWith('/') ? v : ('/' + v));
                                        try { return origSet.call(this, newV); } catch(e) { /* fallback */ }
                                    }
                                }
                            } catch(e) {}
                            return origSet.call(this, v);
                        }
                    });
                };
                if (window.HTMLImageElement) patchSetter(HTMLImageElement.prototype);
                if (window.HTMLMediaElement) patchSetter(HTMLMediaElement.prototype);
            } catch (e) { console.warn('Failed to patch src setters', e); }
            // Also guard setAttribute for src/href and specific element href/src setters (script, link)
            try {
                const origSetAttribute = Element.prototype.setAttribute;
                Element.prototype.setAttribute = function(name, value) {
                    try {
                        const n = (name || '').toString().toLowerCase();
                        if ((n === 'src' || n === 'href') && typeof value === 'string') {
                            const sv = value.trim();
                            if (!sv) return;
                            if (sv.toLowerCase() === 'null') return;
                            if (sv.indexOf('<<REDACTED') !== -1) return;
                            if (sv[0] === '<') return;
                            try {
                                const repoParts = (location.pathname || '').split('/').filter(Boolean);
                                const repoBase = repoParts.length ? repoParts[0] : null;
                                if (repoBase && sv.startsWith('/') && !sv.startsWith('/' + repoBase) && (/^\/(uploaded_media|deploy|assets)\//.test(sv))) {
                                    value = '/' + repoBase + (sv.startsWith('/') ? sv : ('/' + sv));
                                }
                            } catch(e) {}
                        }
                    } catch (e) { /* ignore */ }
                    return origSetAttribute.call(this, name, value);
                };

                const patchProp = (proto, prop) => {
                    try {
                        const desc = Object.getOwnPropertyDescriptor(proto, prop);
                        if (!desc || typeof desc.set !== 'function') return;
                        const orig = desc.set;
                        Object.defineProperty(proto, prop, {
                            configurable: true,
                            enumerable: desc.enumerable,
                            get: desc.get,
                            set: function(v) {
                                try {
                                    if (v == null) return;
                                    if (typeof v === 'string') {
                                        const s = v.trim();
                                        if (!s) return;
                                        if (s.toLowerCase() === 'null') return;
                                        if (s.indexOf('<<REDACTED') !== -1) return;
                                        if (s[0] === '<') return;
                                    }
                                } catch (e) { /* ignore */ }
                                return orig.call(this, v);
                            }
                        });
                    } catch (e) {}
                };

                if (window.HTMLScriptElement) patchProp(HTMLScriptElement.prototype, 'src');
                if (window.HTMLLinkElement) patchProp(HTMLLinkElement.prototype, 'href');
                if (window.HTMLAnchorElement) patchProp(HTMLAnchorElement.prototype, 'href');
            } catch (e) { console.warn('Failed to patch setAttribute/src/href guards', e); }
        })();
    </script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <script>
        // Detect when the page is opened via file:// so we can avoid fetch/XHR that
        // browsers commonly block under the file origin (origin === 'null').
        window.IS_FILE_PROTOCOL = (location.protocol === 'file:' || (typeof location.origin === 'string' && location.origin === 'null'));
    </script>
    <script>
        // --- Runtime helpers: console capture and detailed report API ---
        (function(){
            if (!window.__capturedConsole) {
                window.__capturedConsole = [];
                const maxLogs = 2000;
                const wrap = (name) => {
                    const orig = console[name];
                    console[name] = function(...args) {
                        try {
                            window.__capturedConsole.push({ level: name, time: new Date().toISOString(), args: args.map(a => { try { return typeof a === 'string' ? a : JSON.stringify(a); } catch (e) { return String(a); } }) });
                            if (window.__capturedConsole.length > maxLogs) window.__capturedConsole.shift();
                        } catch (e) {}
                        try { orig.apply(console, args); } catch (e) {}
                    };
                };
                ['log','info','warn','error','debug'].forEach(wrap);
                window.addEventListener('error', (ev) => { try { window.__capturedConsole.push({ level: 'error', time: new Date().toISOString(), args: [ev.message, ev.filename + ':' + ev.lineno + ':' + ev.colno] }); if (window.__capturedConsole.length>2000) window.__capturedConsole.shift(); } catch(e){} });
                window.addEventListener('unhandledrejection', (ev) => { try { window.__capturedConsole.push({ level: 'unhandledrejection', time: new Date().toISOString(), args: [String(ev.reason)] }); if (window.__capturedConsole.length>2000) window.__capturedConsole.shift(); } catch(e){} });
            }

            // configurable body limit (bytes) and include bodies default
            if (typeof window.__REPORT_BODY_SIZE_LIMIT === 'undefined') window.__REPORT_BODY_SIZE_LIMIT = 2 * 1024 * 1024; // 2MB default
            // Default to excluding response bodies to keep reports small; include via options.includeBodies=true
            if (typeof window.__REPORT_INCLUDE_BODIES === 'undefined') window.__REPORT_INCLUDE_BODIES = false;

            // Expose a global async generator that returns the detailed report object.
            window.__generateDetailedReport = async function(options){
                options = options || {};
                const includeBodies = (typeof options.includeBodies !== 'undefined') ? options.includeBodies : window.__REPORT_INCLUDE_BODIES || false;
                const bodyLimit = (typeof options.bodyLimit === 'number') ? options.bodyLimit : window.__REPORT_BODY_SIZE_LIMIT;
                const report = { env: {}, time: new Date().toISOString(), files: {}, serviceWorkers: [], caches: {}, indexedDB: {}, storage: {}, console: {}, notes: [] };
                try {
                    report.env.url = location.href;
                    report.env.userAgent = navigator.userAgent;
                    report.env.platform = navigator.platform;
                    report.env.cookieEnabled = navigator.cookieEnabled;
                    report.env.online = navigator.onLine;
                    report.env.language = navigator.language;
                } catch (e) { report.envError = String(e); }

                const fetchText = async (p) => { try { const r = await fetch(p); if (!r.ok) return { status: r.status }; const t = await r.text(); return { status: r.status, text: t }; } catch (e) { return { error: String(e) }; } };
                try {
                    const idx = await fetchText('/index.html');
                    const swf = await fetchText('/sw.js');
                    report.files['/index.html'] = { status: idx.status || null, length: idx.text ? idx.text.length : 0, text: idx.text || null };
                    report.files['/sw.js'] = { status: swf.status || null, length: swf.text ? swf.text.length : 0, text: swf.text || null };
                    try { if (swf.text) { const m = swf.text.match(/const\s+CACHE_VERSION\s*=\s*['\"]([^'\"]+)['\"]/); if (m) report.env.swCacheVersion = m[1]; } } catch(e){}
                } catch (e) { report.filesError = String(e); }

                try {
                    if ('serviceWorker' in navigator) {
                        const regs = await navigator.serviceWorker.getRegistrations();
                        report.serviceWorkers = regs.map(r => ({ scope: r.scope, active: r.active && r.active.state, waiting: r.waiting && r.waiting.state, installing: r.installing && r.installing.state }));
                    }
                } catch (e) { report.swRegsError = String(e); }

                try {
                    const keys = await caches.keys(); report.caches.keys = keys; 
                    for (const k of keys) {
                        try {
                            const c = await caches.open(k);
                            const reqs = await c.keys();
                            report.caches[k] = { count: reqs.length, entries: [] };
                            for (const r of reqs.slice(0, 1000)) {
                                const entry = { url: r.url };
                                try {
                                    const resp = await c.match(r);
                                    if (resp) {
                                        entry.status = resp.status; entry.type = resp.type; entry.headers = {};
                                        try { resp.headers.forEach((v,n)=> entry.headers[n]=v); } catch(e){}
                                        try {
                                            const clone = resp.clone();
                                            const blob = await clone.blob(); entry.bodySize = blob.size;
                                            if (includeBodies) {
                                                // If body is small enough, inline as base64. Otherwise store the body in IndexedDB
                                                if (blob.size <= bodyLimit) {
                                                    const arr = await blob.arrayBuffer();
                                                    let binary = '';
                                                    const bytes = new Uint8Array(arr);
                                                    const chunk = 0x8000;
                                                    for (let i=0;i<bytes.length;i+=chunk) binary += String.fromCharCode.apply(null, bytes.subarray(i, i+chunk));
                                                    entry.bodyBase64 = btoa(binary);
                                                } else {
                                                    // store large bodies in an IndexedDB database to avoid huge IPC serialization
                                                    try {
                                                        const storeDB = await new Promise((res, rej) => {
                                                            const rq = indexedDB.open('detailed_report_bodies_v1', 1);
                                                            rq.onupgradeneeded = (ev) => {
                                                                const db = ev.target.result;
                                                                if (!db.objectStoreNames.contains('bodies')) db.createObjectStore('bodies', { keyPath: 'key' });
                                                            };
                                                            rq.onsuccess = () => res(rq.result);
                                                            rq.onerror = () => rej(rq.error);
                                                        });
                                                        const key = (crypto && crypto.randomUUID) ? crypto.randomUUID() : ('body-' + Date.now() + '-' + Math.random().toString(36).slice(2));
                                                        const tx = storeDB.transaction('bodies', 'readwrite');
                                                        const store = tx.objectStore('bodies');
                                                        await new Promise((res, rej) => {
                                                            const putReq = store.put({ key, blob });
                                                            putReq.onsuccess = () => res(true);
                                                            putReq.onerror = () => rej(putReq.error);
                                                        });
                                                        try { tx.commit && tx.commit(); } catch(e){}
                                                        try { storeDB.close(); } catch(e){}
                                                        entry.bodyStored = true; entry.bodyKey = key; entry.note = 'body stored in IndexedDB: detailed_report_bodies_v1/bodies';
                                                    } catch(e){ entry.bodyError = 'failed to store body in IndexedDB: ' + String(e); }
                                                }
                                            } else {
                                                entry.note = 'body omitted (includeBodies=false)';
                                            }
                                        } catch(e){ entry.bodyError = String(e); }
                                    }
                                } catch(e){ entry.error = String(e); }
                                report.caches[k].entries.push(entry);
                            }
                        } catch(e){ report.caches[k] = { error: String(e) }; }
                    }
                } catch(e){ report.cachesError = String(e); }

                    try {
                    if (typeof dbGetAll === 'function' && typeof STORES !== 'undefined') {
                        const storeNames = Object.keys(STORES || {});
                        for (const s of storeNames) {
                            try {
                                const arr = await dbGetAll(STORES[s]);
                                report.indexedDB[s] = { count: arr.length, sample: arr.slice(0,200) };
                                const approxSize = JSON.stringify(arr).length;
                                if (approxSize <= 500*1024) report.indexedDB[s].full = arr;
                            } catch(e){ report.indexedDB[s] = { error: String(e) }; }
                        }
                    } else {
                        // Fallback: attempt to open known DB names and enumerate their object stores.
                        try {
                            const candidateDBs = [];
                            if (typeof DB_NAME === 'string') candidateDBs.push(DB_NAME);
                            if (typeof LEGACY_DB_NAME === 'string') candidateDBs.push(LEGACY_DB_NAME);
                            // also check for PortableCatalogDB_Lazy_* variants
                            candidateDBs.push('PortableCatalogDB_Lazy_V1');
                            for (const dbName of Array.from(new Set(candidateDBs))) {
                                if (!dbName) continue;
                                try {
                                    const req = indexedDB.open(dbName);
                                    const dbObj = await new Promise((res, rej) => {
                                        req.onsuccess = () => res(req.result);
                                        req.onerror = () => rej(req.error);
                                        req.onupgradeneeded = () => { req.transaction && req.transaction.abort(); res(req.result); };
                                    });
                                    const stores = Array.from(dbObj.objectStoreNames || []);
                                    report.indexedDB[dbName] = { stores: {} };
                                    for (const s of stores) {
                                        try {
                                            const tx = dbObj.transaction(s, 'readonly');
                                            const store = tx.objectStore(s);
                                            let items = [];
                                            if ('getAll' in store) {
                                                items = await new Promise((res, rej) => { const r = store.getAll(); r.onsuccess = () => res(r.result); r.onerror = () => rej(r.error); });
                                            } else {
                                                // iterate with cursor
                                                items = await new Promise((res, rej) => {
                                                    const out = [];
                                                    const cursorReq = store.openCursor();
                                                    cursorReq.onsuccess = (ev) => {
                                                        const c = ev.target.result;
                                                        if (!c) return res(out);
                                                        out.push(c.value);
                                                        if (out.length >= 200) return res(out);
                                                        c.continue();
                                                    };
                                                    cursorReq.onerror = () => rej(cursorReq.error);
                                                });
                                            }
                                            report.indexedDB[dbName].stores[s] = { count: items.length, sample: items.slice(0,200) };
                                        } catch (e) {
                                            report.indexedDB[dbName].stores[s] = { error: String(e) };
                                        }
                                    }
                                    try { dbObj.close(); } catch(e){}
                                } catch(e) {
                                    report.indexedDB[dbName] = { error: String(e) };
                                }
                            }
                            if (!Object.keys(report.indexedDB).length) report.indexedDBNote = 'No readable IndexedDB databases found.';
                        } catch(e) {
                            report.indexedDBNote = 'IndexedDB fallback failed: ' + String(e);
                        }
                    }
                } catch(e){ report.indexedDBError = String(e); }

                try {
                    report.storage = { localStorage: {}, sessionStorage: {}, cookies: '' };
                    try {
                        // redact sensitive keys to avoid leaking API keys/secrets in reports
                        const SENSITIVE_RE = /api[_-]?key|token|secret|password|gemini|openai/i;
                        for (let i=0;i<localStorage.length;i++){
                            const k = localStorage.key(i);
                            try {
                                const val = localStorage.getItem(k);
                                if (k && SENSITIVE_RE.test(k)) {
                                    report.storage.localStorage[k] = '<<REDACTED>>';
                                } else {
                                    report.storage.localStorage[k] = val;
                                }
                            } catch(e) { report.storage.localStorage[k] = '<<error reading>>'; }
                        }
                    } catch(e){ report.storage.localStorageError=String(e); }
                    try { for (let i=0;i<sessionStorage.length;i++){ const k=sessionStorage.key(i); report.storage.sessionStorage[k]=sessionStorage.getItem(k); } } catch(e){ report.storage.sessionStorageError=String(e); }
                    try { report.storage.cookies = document.cookie; } catch(e){ report.storage.cookiesError=String(e); }
                } catch(e){ report.storageError = String(e); }

                try { report.console = { recent: window.__capturedConsole || [] }; } catch(e){ report.consoleError = String(e); }

                try { report.runtime = { controlled: !!(navigator.serviceWorker && navigator.serviceWorker.controller) }; } catch(e){}

                // Generate a human-readable diagnostic summary (compact)
                try {
                    const linesFor = (text, pat, context = 2) => {
                        if (!text) return null;
                        const idx = text.search(new RegExp(pat, 'm'));
                        if (idx === -1) return null;
                        const before = text.slice(0, idx);
                        const lineNum = before.split(/\r?\n/).length;
                        const allLines = text.split(/\r?\n/);
                        const start = Math.max(0, lineNum - 1 - context);
                        const end = Math.min(allLines.length, lineNum - 1 + context + 1);
                        return { line: lineNum, snippet: allLines.slice(start, end).join('\n') };
                    };

                    const summary = [];
                    summary.push(`Report time: ${report.time}`);
                    summary.push(`URL: ${report.env.url}`);
                    summary.push(`UserAgent: ${report.env.userAgent}`);
                    summary.push('');
                    // SW control
                    summary.push(`ServiceWorker controlling page: ${report.runtime && report.runtime.controlled ? 'YES' : 'NO'}`);
                    if (report.serviceWorkers && report.serviceWorkers.length) {
                        summary.push(`Registered SW count: ${report.serviceWorkers.length}`);
                        report.serviceWorkers.forEach((r, i) => summary.push(`  SW[${i}]: scope=${r.scope} active=${r.active} waiting=${r.waiting} installing=${r.installing}`));
                    }
                    summary.push('');
                    // Cache summary
                    if (report.caches && report.caches.keys) {
                        summary.push(`Caches: ${report.caches.keys.length}`);
                        for (const k of report.caches.keys) {
                            const info = report.caches[k];
                            if (!info) continue;
                            summary.push(`- ${k}: entries=${info.count}`);
                            // list up to 10 non-200 or top entries
                            const bad = (info.entries||[]).filter(e => e.status && (e.status < 200 || e.status >= 300));
                            if (bad.length) summary.push(`  Non-2xx entries: ${bad.length} (examples: ${bad.slice(0,5).map(b=>b.url).join(', ')})`);
                            const firstUrls = (info.entries||[]).slice(0,10).map(e=>e.url.split('?')[0]);
                            if (firstUrls.length) summary.push(`  Sample entries: ${firstUrls.join(', ')}`);
                        }
                    }
                    summary.push('');
                    // IndexedDB summary
                    if (report.indexedDB) {
                        const keys = Object.keys(report.indexedDB).filter(k => k !== 'Note' && k !== 'note');
                        summary.push(`IndexedDB stores: ${keys.length}`);
                        keys.forEach(k => {
                            const v = report.indexedDB[k];
                            if (v && v.count !== undefined) summary.push(`  ${k}: count=${v.count}`);
                            else summary.push(`  ${k}: ${JSON.stringify(v).slice(0,200)}`);
                        });
                    }
                    summary.push('');
                    // Files and version checks
                    try {
                        if (report.files && report.files['/sw.js'] && report.files['/sw.js'].text) {
                            const loc = linesFor(report.files['/sw.js'].text, 'const\\s+CACHE_VERSION');
                            if (loc) {
                                summary.push(`sw.js CACHE_VERSION at line ${loc.line}:`);
                                summary.push(loc.snippet);
                            }
                        }
                        if (report.files && report.files['/index.html'] && report.files['/index.html'].text) {
                            const loc2 = linesFor(report.files['/index.html'].text, 'navigator.serviceWorker.controller');
                            if (loc2) {
                                summary.push(`index.html navigator.serviceWorker.controller usage at line ${loc2.line}:`);
                                summary.push(loc2.snippet);
                            }
                        }
                    } catch(e){}

                    // Warnings
                    const warnings = [];
                    if (!(report.runtime && report.runtime.controlled)) warnings.push('Page is not controlled by ServiceWorker — some SW ops may fail or have no controller');
                    if (report.files && report.env && report.env.swCacheVersion && report.files['/index.html'] && report.files['/index.html'].text) {
                        // try to find a cache version variable in index.html (if present)
                        const idxMatch = (report.files['/index.html'].text || '').match(/CACHE_VERSION\s*=\s*['\"]([^'\"]+)['\"]/);
                        if (idxMatch && idxMatch[1] !== report.env.swCacheVersion) warnings.push(`CACHE_VERSION mismatch: index.html=${idxMatch[1]} vs sw.js=${report.env.swCacheVersion}`);
                    }
                    if (warnings.length) { summary.push('Warnings:'); warnings.forEach(w => summary.push(' - ' + w)); }

                    report.summary = summary.join('\n');
                } catch (e) { report.summaryError = String(e); }

                return report;
            };
        })();
    </script>
    <script>
        // If the page is opened via file://, show a clear banner with instructions
        (function fileProtocolBanner(){
            try {
                if (!window.IS_FILE_PROTOCOL) return;
                const banner = document.createElement('div');
                banner.id = 'file-protocol-banner';
                banner.style.cssText = 'position:fixed;left:12px;right:12px;top:12px;z-index:9999;padding:12px 16px;background:#fffbeb;border:1px solid #f59e0b;color:#92400e;border-radius:8px;font-family:Inter,Arial,sans-serif;box-shadow:0 6px 18px rgba(0,0,0,0.06)';
                banner.innerHTML = `
                    <div style="display:flex;gap:12px;align-items:center;">
                        <div style="flex:1">
                            <strong>توجه:</strong> این صفحه با پروتکل <code>file://</code> باز شده—قابلیت‌های Service Worker و کش ممکن است کار نکنند.
                            برای فعال‌سازی کامل، لطفاً پوشه پروژه را با یک سرور محلی سرو کنید.
                            <div style="margin-top:6px;font-size:13px;color:#475569">پیشنهاد: اجرا در پوشه پروژه با یکی از دستورات زیر:</div>
                            <pre style="background:#fff;border-radius:6px;padding:8px;margin:6px 0;font-size:13px;color:#0f172a">npx http-server -c-1 . -p 8080
python -m http.server 8080
.
برای ویندوز: اجرا کردن <em>start-server.bat</em> یا <em>start-server.ps1</em></pre>
                        </div>
                        <div style="display:flex;flex-direction:column;gap:8px">
                            <button id="copy-server-cmd" style="background:#0ea5e9;color:white;border:none;padding:8px 12px;border-radius:6px;cursor:pointer">کپی دستور</button>
                            <button id="dismiss-file-banner" style="background:transparent;border:1px solid #e2e8f0;padding:6px 10px;border-radius:6px;cursor:pointer">بستن</button>
                        </div>
                    </div>`;
                document.addEventListener('DOMContentLoaded', () => {
                    const container = document.getElementById('file-protocol-area');
                    if (container) {
                        container.appendChild(banner);
                    } else {
                        // Intentionally do not show any UI on the main page. Banner will appear only inside Settings when available.
                        console.log('Page opened under file:// — no `file-protocol-area` found; banner not shown on main page.');
                    }
                });
            } catch(e) { console.warn('fileProtocolBanner error', e); }
        })();
    </script>
    <script>
        // Service Worker registration (skip on file://)
        (function registerSW() {
            try {
                if (window.IS_FILE_PROTOCOL) {
                    console.log('Skipping Service Worker registration under file:// protocol');
                    return;
                }
                if ('serviceWorker' in navigator) {
                    navigator.serviceWorker.register('/sw.js').then((reg) => {
                        console.log('ServiceWorker registered:', reg);
                        if (reg.waiting) {
                            console.log('SW waiting — consider update flow');
                        }
                        reg.addEventListener('updatefound', () => {
                            const newSW = reg.installing;
                            console.log('SW update found:', newSW);
                            newSW.addEventListener('statechange', () => {
                                console.log('SW statechange:', newSW.state);
                                if (newSW.state === 'installed' && navigator.serviceWorker.controller) {
                                    // New update available
                                    console.log('New SW installed — page can prompt user to refresh');
                                }
                            });
                        });
                    }).catch((err) => console.error('SW registration failed', err));
                }
            } catch (e) {
                console.warn('SW registration skipped:', e);
            }
        })();
    </script>
    <!-- Libraries -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js" crossorigin></script>
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- SheetJS (XLSX) library: try local copy first, then CDN as fallback -->
    <script>
        (function () {
            const localPath = 'assets/xlsx.full.min.js';
            const cdnCandidates = [
                // Try jsDelivr without pinned version (redirects to latest when available)
                'https://cdn.jsdelivr.net/npm/xlsx/dist/xlsx.full.min.js',
                // Fallback to unpkg
                'https://unpkg.com/xlsx/dist/xlsx.full.min.js'
            ];
            function loadScript(src) {
                return new Promise((resolve, reject) => {
                    const s = document.createElement('script');
                    s.src = src;
                    s.async = true;
                    s.onload = () => resolve(src);
                    s.onerror = () => reject(src);
                    document.head.appendChild(s);
                });
            }

            // Caching strategy:
            // 1) If a cached script exists in localStorage, inject it first (works offline in the browser).
            // 2) Try the local file in `assets/`.
            // 3) If local file loads but doesn't expose `window.XLSX` (placeholder), try CDN candidates.
            // 4) After successfully loading from CDN, fetch the script text and cache it in localStorage for future offline use.
            const LOCAL_STORAGE_KEY = 'xlsx_local_text';

            async function tryInjectFromLocalStorage() {
                try {
                    const txt = localStorage.getItem(LOCAL_STORAGE_KEY);
                    if (!txt) return false;
                    const blob = new Blob([txt], { type: 'application/javascript' });
                    const url = URL.createObjectURL(blob);
                    await loadScript(url);
                    console.log('XLSX injected from localStorage cache');
                    return !!window.XLSX;
                } catch (e) {
                    console.warn('Failed to inject XLSX from localStorage cache', e);
                    return false;
                }
            }

            async function cacheScriptText(url) {
                try {
                    if (window.IS_FILE_PROTOCOL) {
                        // Skip caching attempts when opened via file:// — fetch/XHR may be blocked
                        console.log('Skipping cacheScriptText under file:// protocol');
                        return;
                    }
                    const resp = await fetch(url);
                    if (!resp.ok) return;
                    const txt = await resp.text();
                    try { localStorage.setItem(LOCAL_STORAGE_KEY, txt); console.log('Cached XLSX script in localStorage'); } catch (e) { console.warn('Could not cache XLSX script:', e); }
                } catch (e) {
                    // ignore
                }
            }

            (async function loadXlsxWithCache() {
                // 1) Try inject from localStorage cache
                const fromCache = await tryInjectFromLocalStorage();
                if (fromCache) return;

                // 2) Try local file in assets
                try {
                    await loadScript(localPath);
                    console.log('Local xlsx script loaded:', localPath);
                    if (window.XLSX) {
                        console.log('XLSX available on window after local load');
                        return;
                    }
                    console.warn('Local xlsx loaded but `window.XLSX` is not defined — trying CDN candidates...');
                } catch (e) {
                    console.warn('Local XLSX not found or failed to load, trying CDN candidates...');
                }

                // 3) Try CDN candidates in order
                for (const url of cdnCandidates) {
                    try {
                        await loadScript(url);
                        if (window.XLSX) {
                            console.log('XLSX loaded from CDN:', url);
                            // 4) Cache for offline use
                            cacheScriptText(url);
                            return;
                        } else {
                            console.warn('Loaded script from', url, 'but `window.XLSX` still not defined.');
                        }
                    } catch (e) {
                        console.warn('Failed to load XLSX from', url);
                    }
                }

                console.error('Failed to load XLSX from local and all CDN candidates. .xlsx export will fall back to CSV.');
            })();

            // Quick check on DOMContentLoaded to report status
            document.addEventListener('DOMContentLoaded', () => {
                if (!window.XLSX) {
                    console.warn('XLSX not available on window after attempts.');
                } else {
                    console.log('XLSX available on window');
                }
            });
        })();
    </script>

    <!-- Load AI Module -->
    <script type="module">
        try {
            // Correct, modern package name
            const module = await import("https://esm.sh/@google/genai");
            if (module && module.GoogleGenAI) {
                window.genai = {
                    GoogleGenAI: module.GoogleGenAI,
                    Type: module.Type,
                    Modality: module.Modality
                };
            } else {
                console.error("AI Module loaded but GoogleGenAI class is missing.");
                window.genai = { error: "AI Module loaded but GoogleGenAI class is missing." };
            }
        } catch (err) {
            console.error("Failed to load AI module:", err);
            window.genai = { error: err };
        }
    </script>

    <!-- Fonts & Styles -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700;900&family=Vazirmatn:wght@400;500;700;900&family=Playfair+Display:wght@700&display=swap"
        rel="stylesheet">
    <link rel="preload" href="assets/galstian-logo.png" as="image">
    <!-- Inline favicon to avoid automatic /favicon.ico 404 when serving locally -->
    <link rel="icon" href="data:image/svg+xml;utf8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3E%3Crect width='16' height='16' fill='%23f1f5f9'/%3E%3Ctext x='8' y='11' font-size='9' text-anchor='middle' fill='%233b82f6' font-family='Arial'%3EG%3C/text%3E%3C/svg%3E">

    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Arial', 'Inter', 'system-ui', 'sans-serif'],
                        vazir: ['Vazirmatn', 'system-ui', 'sans-serif'],
                        serif: ['Playfair Display', 'serif'],
                    },
                    animation: {
                        'fade-in': 'fadeIn 0.5s ease-out forwards',
                        'slide-up': 'slideUp 0.5s ease-out forwards',
                        'hero-fade-in': 'heroFadeIn 1.5s ease-out forwards',
                    },
                    keyframes: {
                        fadeIn: { '0%': { opacity: 0 }, '100%': { opacity: 1 } },
                        slideUp: { '0%': { opacity: 0, transform: 'translateY(20px)' }, '100%': { opacity: 1, transform: 'translateY(0)' } },
                        heroFadeIn: {
                            '0%': { opacity: 0 },
                            '100%': { opacity: 1 },
                        },
                    },
                    colors: {
                        'admin-bg': 'var(--admin-bg)',
                        'admin-sidebar': 'var(--admin-sidebar)',
                        'admin-text-primary': 'var(--admin-text-primary)',
                        'admin-text-secondary': 'var(--admin-text-secondary)',
                        'admin-accent': 'var(--admin-accent)',
                        'admin-border': 'var(--admin-border)',
                    }
                }
            }
        }
    </script>

    <style>
        :root,
        html.light {
            --admin-bg: rgba(241, 245, 249, 0.7);
            /* slate-100 with transparency */
            --admin-sidebar: rgba(255, 255, 255, 0.85);
            /* white with transparency */
            --admin-text-primary: #0f172a;
            /* slate-900 */
            --admin-text-secondary: #475569;
            /* slate-600 */
            --admin-accent: #3b82f6;
            /* blue-600 */
            --admin-border: #e2e8f0;
            /* slate-200 */
        }

        html.dark {
            --admin-bg: rgba(2, 6, 23, 0.7);
            /* slate-950 with transparency */
            --admin-sidebar: rgba(15, 23, 42, 0.85);
            /* slate-900 with transparency */
            --admin-text-primary: #f8fafc;
            /* slate-50 */
            --admin-text-secondary: #94a3b8;
            /* slate-400 */
            --admin-accent: #60a5fa;
            /* blue-400 */
            --admin-border: #1e293b;
            /* slate-800 */
        }

        html,
        body,
        #root {
            height: 100%;
            overflow-x: hidden;
            max-width: 100vw;
        }

        /* In management mode, contain scrolling within elements, not the body */
        html.management-mode-active,
        html.management-mode-active body,
        html.management-mode-active #root {
            overflow: hidden;
        }

        body {
            font-family: 'Arial', 'Inter', system-ui, 'sans-serif';
            transition: background-color 0.3s ease-in-out;
            overflow-x: hidden;
            background-color: #f1f5f9;
            /* slate-100 */
            margin: 0;
            padding: 0;
            /* Respect mobile safe area (iPhone notch, Android gesture nav) */
            padding-bottom: env(safe-area-inset-bottom, 16px);
            width: 100vw;
            max-width: 100%;
        }

        html.dark body {
            background-color: #020617;
            /* slate-950 */
        }

        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(30, 41, 59, 0.5);
        }

        ::-webkit-scrollbar-thumb {
            background: #475569;
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #64748b;
        }

        .horizontal-scrollbar::-webkit-scrollbar {
            height: 6px;
        }

        @keyframes rotateGlow {
            from {
                transform: rotate(0deg);
            }

            to {
                transform: rotate(360deg);
            }
        }

        .assistant-modal-glow {
            position: relative;
            padding: 2px;
            /* This creates the border thickness */
            border-radius: 0.5rem;
            /* Tailwind's rounded-lg */
            overflow: hidden;
            z-index: 1;
        }

        .assistant-modal-glow::before {
            content: '';
            position: absolute;
            z-index: -1;
            inset: -200%;
            /* Make gradient larger to avoid artifacts at corners */
            background: conic-gradient(from 180deg,
                    #4f46e5,
                    #3b82f6,
                    #60a5fa,
                    #a5b4fc,
                    #60a5fa,
                    #3b82f6,
                    #4f46e5);
            animation: rotateGlow 3s linear infinite;
        }

        /* New styles for header tabs */
        .header-tab-button,
        .header-tab-icon-button {
            position: relative;
            background-color: transparent;
            border-radius: 9999px;
            /* rounded-full */
            font-weight: 600;
            /* font-semibold */
            transition: color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
            cursor: pointer;
        }

        html.light .header-tab-button,
        html.light .header-tab-icon-button {
            color: #475569;
            /* slate-600 */
        }

        html.dark .header-tab-button,
        html.dark .header-tab-icon-button {
            color: #94a3b8;
            /* slate-400 */
        }

        html.light .header-tab-button:disabled,
        html.light .header-tab-icon-button:disabled {
            color: #cbd5e1;
            /* slate-300 */
        }

        html.dark .header-tab-button:disabled,
        html.dark .header-tab-icon-button:disabled {
            color: #475569;
            /* slate-600 */
        }

        html.light .header-tab-button:not(:disabled):hover,
        html.light .header-tab-icon-button:hover {
            color: #0f172a;
            /* slate-900 */
        }

        html.dark .header-tab-button:not(:disabled):hover,
        html.dark .header-tab-icon-button:hover {
            color: white;
        }

        .header-tab-button {
            padding: 0.5rem 1rem;
            font-size: 0.875rem;
            /* text-sm */
            line-height: 1.25rem;
        }

        .header-tab-icon-button {
            padding: 0.625rem;
            /* p-2.5 */
        }

        .header-tab-button:not(:disabled):hover,
        .header-tab-icon-button:hover {
            box-shadow: 0 0 12px 2px rgba(96, 165, 250, 0.5);
        }


        /* Hero Slideshow Styles */
        .hero-bg-slide {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-size: cover;
            background-position: center center;
            opacity: 0;
            transition: opacity 1.5s ease-in-out;
        }

        .hero-bg-slide.visible {
            opacity: 1;
        }

        .slideshow-image {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            opacity: 0;
            transition: opacity 0.8s ease-in-out;
        }

        .slideshow-image.visible {
            opacity: 1;
        }
    </style>
        <style>
        /* Inlined from index.css to improve file:// compatibility */
        /* Global safety: ensure no accidental transform/zoom rules affect layout */
        html, body {
            transform: none !important;
            zoom: 1 !important;
        }

        /* Ensure product detail image container can expand as needed */
        .product-main-image-container {
            min-height: 420px;
        }
        </style>
        <style>
            @media (max-width: 900px) {
                /* Ensure header/hero logo stays in its original place on mobile */
                #appLogo {
                    transform: translateY(0) !important;
                }
                /* Restore original logo container offset */
                #logoContainer {
                    transform: translateY(0) !important;
                    top: 64px !important;
                }
                /* Only move footer's main brand logo down on mobile */
                #footerLogo {
                    transform: translateY(26px) !important;
                    margin-top: 10px !important;
                    position: relative !important;
                }
                /* Nudge the smaller secondary logo 8mm further down so it doesn't overlap */
                #secondaryLogo {
                    transform: translateY(8mm) !important;
                    margin-top: 6px !important;
                }
            }
        </style>
</head>

<body>
    <div id="root">
        <div style="display:flex; align-items:center; justify-content:center; min-height:100dvh; min-height:-webkit-fill-available; padding-bottom:env(safe-area-inset-bottom,16px); box-sizing:border-box; color:black; font-family:sans-serif;"
            class="dark:text-white">
            <svg class="animate-spin -ml-1 mr-3 h-8 w-8" xmlns="http://www.w3.org/2000/svg" fill="none"
                viewBox="0 0 24 24">
                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                <path class="opacity-75" fill="currentColor"
                    d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z">
                </path>
            </svg>
            Loading Catalog...
        </div>
    </div>

    <script type="text/babel">
        /* PRELOADED_DATA_PLACEHOLDER */
        (function(){
            if (window.PRELOADED_DATA) return;
            window.PRELOADED_DATA_PROMISE = (async function loadPreloadedData(){
                const tryUrls = [
                    'https://raw.githubusercontent.com/amirpowerteam/galstian-catalog-1/main/metadata.json',
                    'https://raw.githubusercontent.com/amirpowerteam/galstian-catalog-1/main/metadata-1.json',
                    'https://raw.githubusercontent.com/amirpowerteam/galstian-catalog-1/main/metadata-1-1.json',
                    'https://raw.githubusercontent.com/amirpowerteam/galstian-catalog-1/main/metadata-1-1-1.json'
                ];

                async function fetchJson(url){
                    try{
                        const res = await fetch(url, { cache: 'no-store' });
                        if (!res.ok) throw new Error('status ' + res.status);
                        return await res.json();
                    }catch(e){ console.warn('fetchJson failed', url, e); return null; }
                }

                let dataObj = null;
                // Try common backup filenames first (catalog_backup.json at repo root or deploy folder)
                const backupCandidates = [
                    'catalog_backup.json',
                    'deploy/catalog_backup.json',
                    'deploy/catalog_backup_lazy_2026-01-01T18-42-54-296Z.json',
                    // Fallback to raw.githubusercontent URLs so GitHub Pages can load the packed backup
                    'https://raw.githubusercontent.com/amirpowerteam/galstian-catalog-1/main/catalog_backup.json',
                    'https://raw.githubusercontent.com/amirpowerteam/galstian-catalog-1/main/deploy/catalog_backup.json',
                    'https://raw.githubusercontent.com/amirpowerteam/galstian-catalog-1/main/deploy/catalog_backup_lazy_2026-01-01T18-42-54-296Z.json'
                ];
                for (const b of backupCandidates) {
                    try {
                        dataObj = await fetchJson(b);
                        if (dataObj) { console.info('Loaded metadata from backup', b); break; }
                    } catch(e) { /* ignore */ }
                }
                if (!window.IS_FILE_PROTOCOL) {
                    for (const u of tryUrls) {
                        dataObj = await fetchJson(u);
                        if (dataObj) { console.info('Loaded metadata from', u); break; }
                    }
                } else {
                    console.info('file:// protocol detected; skipping remote fetch');
                }

                if (!dataObj) {
                    const localCandidates = ['metadata.json','metadata-1.json','metadata-1-1.json','metadata-1-1-1.json'];
                    for (const u of localCandidates) {
                        dataObj = await fetchJson(u);
                        if (dataObj) { console.info('Loaded metadata from local', u); break; }
                    }
                }

                if (dataObj) {
                    // Normalize absolute repo-root media paths (e.g. '/uploaded_media/...')
                    // to relative paths so they resolve correctly under GitHub Pages
                    const normalizePaths = (obj) => {
                        if (!obj || typeof obj !== 'object') return;
                        const walk = (value) => {
                            if (Array.isArray(value)) {
                                for (let i = 0; i < value.length; i++) {
                                    if (typeof value[i] === 'string') {
                                        value[i] = normalizeString(value[i]);
                                    } else if (typeof value[i] === 'object' && value[i] !== null) {
                                        walk(value[i]);
                                    }
                                }
                                return;
                            }
                            if (typeof value === 'object') {
                                for (const k in value) {
                                    if (!Object.prototype.hasOwnProperty.call(value, k)) continue;
                                    const v = value[k];
                                    if (typeof v === 'string') {
                                        value[k] = normalizeString(v);
                                    } else if (typeof v === 'object' && v !== null) {
                                        walk(v);
                                    }
                                }
                            }
                        };

                        const normalizeString = (s) => {
                            if (!s || typeof s !== 'string') return s;
                            const trimmed = s.trim();
                            if (!trimmed) return s;
                            // don't touch obvious absolute URLs or data/blob
                            if (/^https?:\/\//i.test(trimmed) || trimmed.startsWith('data:') || trimmed.startsWith('blob:')) return trimmed;
                            // Only normalize known repo-local media paths to relative (remove leading slash)
                            if (/^\/(uploaded_media|deploy|assets)\//.test(trimmed)) {
                                return trimmed.replace(/^\//, '');
                            }
                            return trimmed;
                        };

                        walk(obj);
                    };

                    try { normalizePaths(dataObj); } catch(e) { console.warn('normalizePaths failed', e); }

                    const data = {
                        brands: dataObj.brands || [],
                        categories: dataObj.categories || [],
                        products: dataObj.products || []
                    };
                    const config = dataObj.config || {
                        app_title: dataObj.app_title || 'GALSTIAN',
                        welcome_images: dataObj.welcome_images || [],
                        welcome_video: dataObj.welcome_video || null,
                        welcome_background_type: dataObj.welcome_background_type || 'image',
                        welcome_background_video: dataObj.welcome_background_video || null
                    };
                    window.PRELOADED_DATA = { data, config };
                    try {
                        // If running on GitHub Pages, clear the 'catalog_preloaded_v1' flag
                        // to force a fresh import from the deployed backup (helpful after deploys).
                        const host = (location && location.hostname) ? location.hostname : '';
                        if (host.indexOf('github.io') !== -1 || host.indexOf('amirpowerteam.github.io') !== -1) {
                            try { localStorage.removeItem('catalog_preloaded_v1'); } catch(e){}
                            try { localStorage.removeItem('catalog_backup_etag'); } catch(e){}
                            try { localStorage.removeItem('catalog_backup_version'); } catch(e){}
                            console.info('Cleared preload flags on GitHub Pages to force catalog import.');
                        }
                    } catch(e) {}
                    return true;
                }
                console.warn('No preloaded metadata found on GitHub or local files.');
                return false;
            })();
        })();
        window.onload = () => {
            const { useState, useEffect, useCallback, useMemo, useRef } = React;

            // --- CONSTANTS ---
            // This placeholder is now only for the very first run or if DB fails.
            const INITIAL_BRANDS = [
                {
                    id: 'brand-1',
                    name: { en: '', fa: '' },
                    logo: null,
                },
            ];

            const INITIAL_CATEGORIES = [
                {
                    id: 'cat-1-1',
                    brandId: 'brand-1',
                    name: { en: '', fa: '' },
                },
            ];

            const INITIAL_PRODUCTS = [];

            const DEFAULT_WELCOME_IMAGES = [
                'https://images.pexels.com/photos/1571460/pexels-photo-1571460.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=2',
                'https://images.pexels.com/photos/276583/pexels-photo-276583.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=2',
                'https://images.pexels.com/photos/6585757/pexels-photo-6585757.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=2',
                'https://images.pexels.com/photos/1643383/pexels-photo-1643383.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=2',
            ];

            const TRANSLATIONS = {
                appName: 'GALSTIAN',
                editAppTitle: 'Edit Catalog Title',
                edit: 'Edit',
                delete: 'Delete',
                save: 'Save',
                cancel: 'Cancel',
                close: 'Close',
                confirmDelete: 'Are you sure you want to delete this item? This action cannot be undone.',
                confirmDeleteAction: 'Yes, Delete',
                searchPlaceholder: 'Search all products (EN or FA)...',
                search: 'Search',
                clear: 'Clear',
                searchResultsTitle: 'Search Results',
                noResultsFound: 'No products found matching your search.',
                untitled: '',
                loading: 'Loading Catalog...',
                migratingData: 'Optimizing data structure, please wait...',
                brands: 'Brands',
                addBrand: 'Add Brand',
                editBrand: 'Edit Brand',
                brandNameEn: 'Brand Name (English)',
                brandNameFa: 'Brand Name (Persian)',
                brandLogo: 'Brand Logo',
                uploadLogo: 'Upload Logo',
                categories: 'Categories',
                addCategory: 'Add Category',
                editCategory: 'Edit Category',
                categoryNameEn: 'Category Name (English)',
                categoryNameFa: 'Category Name (Persian)',
                products: 'Products',
                addProduct: 'Add Product',
                editProduct: 'Edit Product',
                productNameEn: 'Product Name (English)',
                productNameFa: 'Product Name (Persian)',
                descriptionEn: 'Creative Description (English)',
                descriptionFa: 'Creative Description (Persian)',
                remarks: 'Technical Specs / Dimensions',
                remarksFa: 'ملاحظات (Remarks)',
                price: 'Price',
                priceNote: 'Text Below Price',
                currency: 'Currency',
                inventory: 'Inventory',
                totalQuantity: 'Total Quantity',
                images: 'Images',
                uploadImages: 'Upload Images (up to 5)',
                selectImagesToShare: 'Select images to share',
                shareOnWhatsApp: 'Share on WhatsApp',
                shareFailedTextOnly: 'Could not share images. Sharing text only.',
                generateWithAI: '✨ Generate with AI',
                generateBothAI: '✨ Generate Descriptions (EN & FA)',
                generating: 'Generating...',
                aiGenerationError: 'Failed to generate description. Check your API Key and internet connection.',
                aiNeedsImages: 'Please upload at least one image to generate a description.',
                aiServiceLoadError: "AI services failed to load. Check your internet connection, or disable any ad blockers/firewalls and refresh.",
                aiProductDetectionError: "AI could not identify a product in the image. Please use a clear product photo.",
                apiKeyMissingMessage: 'To use AI features, please set your Google AI Studio API key.',
                import: 'Import',
                export: 'Export',
                importData: 'Import Data (Backup)',
                exportData: 'Export Data (Backup)',
                importConfirm: 'Are you sure? Importing will ERASE and REPLACE all current data with the backup.',
                importSuccess: 'Data imported successfully!',
                importError: 'Failed to import data. The file might be in an an unsupported format.',
                importingData: 'Importing data, please wait...',
                exportToExcel: 'Export to Excel',
                exporting: 'Exporting...',
                importFromExcel: 'Import from Excel',
                importExcelConfirm: 'This will merge data from the Excel file with your current catalog. Are you sure you want to continue?',
                importExcelAction: 'Yes, Import',
                importExcelSuccess: 'Successfully imported from Excel!',
                importExcelError: 'Failed to import from Excel. Please check the file format and column names.',
                exportForSharing: 'Create Sharable File',
                exportForSharingSuccess: 'A new file `catalog-for-upload.html` has been created. Upload this file to your hosting service.',
                exportForSharingError: 'Could not create shareable file. Make sure `build.js` is in the same folder and Node.js is installed.',
                searchWithImage: 'Search with Image',
                capture: 'Capture',
                aiSearching: 'AI is searching for similar products...',
                aiTextSearching: 'AI is searching the catalog...',
                aiSearchError: 'AI search failed. Please try again or check your connection.',
                cameraError: 'Could not access the camera. Please check permissions.',
                aiSearchNoResults: 'AI did not find any matching products.',
                aiSearchImageDescription: 'Image Search Results',
                setApiKey: 'Set API Key',
                apiKeyModalTitle: 'Set Google AI Studio API Key',
                apiKeyModalMessage: 'To enable AI features, please enter your API key below. You can get a key from Google AI Studio.',
                apiKeyModalPlaceholder: 'Enter your API key here',
                apiKeySaved: 'API Key saved successfully!',
                searchWithVoice: 'AI Assistant',
                listening: 'Listening...',
                aiNavigating: 'AI is understanding your request...',
                voiceSearchError: 'Voice search is not supported by your browser.',
                voicePermissionError: 'Microphone access was denied. Please enable it in your browser settings.',
                voiceSearchNoUnderstand: "Sorry, I couldn't understand that. Please try again.",
                assistantTitle: 'AI Assistant',
                assistantStatusConnecting: 'Connecting...',
                assistantStatusListening: 'Listening...',
                assistantStatusSpeaking: 'AI is speaking...',
                assistantStatusIdle: 'Tap the mic to start',
                assistantStatusError: 'Connection error. Please try again.',
                endConversation: 'End Conversation',
                welcomeSettings: 'Welcome Settings',
                welcomeSettingsTitle: 'Customize Welcome Screen',
                addWelcomeImages: 'Add Images',
                deleteImageConfirm: 'Are you sure you want to delete this photo?',
                exportReadyTitle: 'Export Ready',
                exportReadyMessage: 'Your backup file is ready to be shared or downloaded.',
                shareDownload: 'Share / Download',
                shareFailedFallbackToDownload: 'Share failed. Downloading the file instead...',
                theme: 'Theme',
                exitShowroomMode: 'Exit Showroom Mode',
                brandHistory: 'Brand History',
                editBrandHistory: 'Edit Brand History',
                brandHistoryTextEn: 'Brand History (English)',
                brandHistoryTextFa: 'Brand History (Persian)',
                brandHistoryLogo: 'History Section Logo',
                // New/Updated Welcome Settings translations
                welcomeBackground: 'Welcome Screen Background',
                // Footer
                footerSettings: 'Footer Settings',
                contactInfo: 'Contact Information',
                locationLink: 'View on Map',
                getInTouch: 'Get In Touch',
                backgroundType: 'Background Type',
                imageSlideshow: 'Image Slideshow',
                backgroundVideo: 'Background Video',
                uploadBackgroundVideo: 'Upload Background Video',
                backgroundVideoInfo: 'Upload a single video (MP4 recommended, max 50MB) to be used as a looping background on the welcome screen.',
                promotionalVideo: 'Promotional Video',
                promotionalVideoInfo: 'This video is displayed after the welcome screen, before the brand list.',
                replaceVideo: 'Replace Video',
                deleteVideo: 'Delete Video',
                // Control Panel Translations
                controlPanel: "Control Panel",
                dashboard: "Dashboard",
                overview: "Overview",
                totalBrands: "Total Brands",
                totalCategories: "Total Categories",
                totalProducts: "Total Products",
                quickActions: "Quick Actions",
                manageProducts: "Manage Products",
                manageBrands: "Manage Brands",
                manageCategories: "Manage Categories",
                appSettings: "Settings",
                backToShowroom: "Back to Showroom",
                dangerZone: "Danger Zone",
                wipeAllData: "Wipe All Data",
                wipeAllDataConfirm: "This is irreversible. All brands, categories, products, and settings will be permanently deleted and reset to the default state. Are you absolutely sure?",
                wipeAllDataAction: "Yes, Delete Everything",
                dataWiped: "All data has been wiped and reset.",
                dataWipeError: "Failed to wipe data.",
                productTableId: "ID",
                productTableName: "Product Name",
                productTableBrand: "Brand",
                productTableCategory: "Category",
                productTablePrice: "Price",
                productTableQuantity: "Qty",
                productTableActions: "Actions",
                searchProducts: "Search by name, brand, category...",
                noProductsFoundInPanel: "No products found. Start by adding one!",
                add: 'Add',
                // Footer Translations
                footerSettings: 'Footer Settings',
                brandLogo: 'Brand Logo',
                secondaryLogo: 'Secondary Logo',
                address: 'Address',
                locationLink: 'Location Link (Map)',
                phoneNumbers: 'Phone Numbers',
                contactInfo: 'Contact Information',
                getInTouch: 'Get in Touch',
            };

            // --- NEW DATABASE HELPERS (LAZY LOADING ARCHITECTURE) ---
            // CACHE BUSTER - Update this when data structure changes
            const CACHE_VERSION = '2025-12-26-1';
            
            // استعمال V1 اگر V2 خالی ہو - fallback to old database
            const DB_NAME = 'PortableCatalogDB_Lazy_V1';
            const DB_VERSION = 1;

            const STORES = {
                BRANDS: 'brands',
                CATEGORIES: 'categories',
                PRODUCTS: 'products',
                CONFIG: 'config',
            };

            // Legacy store from the previous non-lazy version
            const LEGACY_DB_NAME = 'FurnitureCatalogDB_Standalone_v3';
            const LEGACY_STORE_NAME = 'catalog_data';
            const LEGACY_DATA_KEY = 'main_data_key';

            let dbPromise = null;
            const openDB = () => {
                if (dbPromise) {
                    return dbPromise;
                }
                dbPromise = new Promise((resolve, reject) => {
                    const request = indexedDB.open(DB_NAME, DB_VERSION);
                    request.onerror = () => reject(request.error);
                    request.onsuccess = () => resolve(request.result);
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        if (!db.objectStoreNames.contains(STORES.BRANDS)) {
                            db.createObjectStore(STORES.BRANDS, { keyPath: 'id' });
                        }
                        if (!db.objectStoreNames.contains(STORES.CATEGORIES)) {
                            const categoryStore = db.createObjectStore(STORES.CATEGORIES, { keyPath: 'id' });
                            categoryStore.createIndex('by_brand', 'brandId', { unique: false });
                        }
                        if (!db.objectStoreNames.contains(STORES.PRODUCTS)) {
                            const productStore = db.createObjectStore(STORES.PRODUCTS, { keyPath: 'id' });
                            productStore.createIndex('by_category', 'categoryId', { unique: false });
                            productStore.createIndex('by_brand', 'brandId', { unique: false });
                        }
                        if (!db.objectStoreNames.contains(STORES.CONFIG)) {
                            db.createObjectStore(STORES.CONFIG, { keyPath: 'key' });
                        }
                    };
                });
                return dbPromise;
            };

            const dbAction = (storeName, mode, action) => new Promise(async (resolve, reject) => {
                const db = await openDB();
                const tx = db.transaction(storeName, mode);
                const store = tx.objectStore(storeName);
                action(store, resolve, reject);
                tx.oncomplete = () => resolve();
                tx.onerror = () => reject(tx.error);
            });

            const dbGetAll = (storeName) => dbAction(storeName, 'readonly', (store, resolve) => {
                const req = store.getAll();
                req.onsuccess = () => resolve(req.result);
            });

            const dbGetByIndex = (storeName, indexName, query) => dbAction(storeName, 'readonly', (store, resolve) => {
                const index = store.index(indexName);
                const req = index.getAll(query);
                req.onsuccess = () => resolve(req.result);
            });

            const dbGet = (storeName, key) => dbAction(storeName, 'readonly', (store, resolve) => {
                const req = store.get(key);
                req.onsuccess = () => resolve(req.result);
            });

            const dbPut = (storeName, item, key) => dbAction(storeName, 'readwrite', (store) => store.put(item, key));
            const dbDelete = (storeName, key) => dbAction(storeName, 'readwrite', (store) => store.delete(key));
            const dbClear = (storeName) => dbAction(storeName, 'readwrite', (store) => store.clear());

            // --- UTILITY HELPERS ---
            // Use a cryptographically-strong UUID when available to avoid collisions.
            const generateId = (() => {
                if (typeof crypto !== 'undefined' && crypto.randomUUID) {
                    return () => `id-${crypto.randomUUID()}`;
                }
                return () => {
                    try {
                        const arr = new Uint8Array(16);
                        if (typeof crypto !== 'undefined' && crypto.getRandomValues) crypto.getRandomValues(arr);
                        else for (let i = 0; i < arr.length; i++) arr[i] = Math.floor(Math.random() * 256);
                        const hex = Array.from(arr).map(b => b.toString(16).padStart(2, '0')).join('');
                        // Format similar to UUID for readability
                        return `id-${hex.slice(0,8)}-${hex.slice(8,12)}-${hex.slice(12,16)}-${hex.slice(16,20)}-${hex.slice(20,32)}`;
                    } catch (e) {
                        return `id-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
                    }
                };
            })();

            const fileToDataURL = (file) => new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.readAsDataURL(file);
                reader.onload = () => resolve(reader.result);
                reader.onerror = error => reject(error);
            });

            // --- Auto-fix duplicate product IDs on page load ---
            async function autoFixDuplicateProductIds() {
                try {
                    // gather products
                    const products = await dbGetAll(STORES.PRODUCTS);
                    const seen = new Map();
                    const duplicates = [];
                    for (const p of products) {
                        const id = String(p.id);
                        if (seen.has(id)) {
                            duplicates.push({ id, product: p });
                        } else {
                            seen.set(id, p);
                        }
                    }
                    if (duplicates.length === 0) {
                        console.log('autoFixDuplicateProductIds: no duplicates found');
                        return;
                    }

                    // create an export backup of key stores (non-destructive)
                    const backup = {
                        exportedAt: new Date().toISOString(),
                        brands: await dbGetAll(STORES.BRANDS),
                        categories: await dbGetAll(STORES.CATEGORIES),
                        products: products,
                        config: await dbGetAll(STORES.CONFIG)
                    };
                    const backupBlob = new Blob([JSON.stringify(backup, null, 2)], { type: 'application/json' });
                    const url = URL.createObjectURL(backupBlob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `indexeddb_backup_before_fix_${Date.now()}.json`;
                    document.body.appendChild(a);
                    a.click();
                    a.remove();
                    URL.revokeObjectURL(url);
                    console.log('autoFixDuplicateProductIds: backup exported');

                    // remap duplicates (keep first occurrence)
                    const idMap = {};
                    for (const dup of duplicates) {
                        const oldId = String(dup.id);
                        // generate unique id
                        let candidate; let tries = 0;
                        do { candidate = generateId(); tries++; } while (await dbGet(STORES.PRODUCTS, candidate) && tries < 50);
                        if (await dbGet(STORES.PRODUCTS, candidate)) {
                            console.error('autoFixDuplicateProductIds: failed to generate unique id for', oldId);
                            continue;
                        }
                        const prod = { ...dup.product, id: candidate };
                        await dbPut(STORES.PRODUCTS, prod);
                        idMap[oldId] = idMap[oldId] || [];
                        idMap[oldId].push(candidate);
                        console.log(`autoFixDuplicateProductIds: remapped ${oldId} -> ${candidate}`);
                    }

                    // offer mapping file for download
                    const mapBlob = new Blob([JSON.stringify({ mappedAt: new Date().toISOString(), map: idMap }, null, 2)], { type: 'application/json' });
                    const u2 = URL.createObjectURL(mapBlob);
                    const a2 = document.createElement('a');
                    a2.href = u2;
                    a2.download = `id_map_after_fix_${Date.now()}.json`;
                    document.body.appendChild(a2);
                    a2.click();
                    a2.remove();
                    URL.revokeObjectURL(u2);

                    console.log('autoFixDuplicateProductIds: completed. mapping downloaded.');
                } catch (e) {
                    console.error('autoFixDuplicateProductIds error:', e);
                }
            }

            // run automatically but defer to allow DB initialization
            window.addEventListener('load', () => {
                setTimeout(() => { autoFixDuplicateProductIds(); }, 1500);
            });

            const fileToBase64 = (file, maxWidth = 1920, maxHeight = 1920, quality = 0.8) => new Promise((resolve, reject) => {
                if (file.type.startsWith('video/')) {
                    // For videos, just return the data URL without processing
                    return fileToDataURL(file).then(resolve).catch(reject);
                }

                const reader = new FileReader();
                reader.readAsDataURL(file);
                reader.onload = event => {
                    const img = new Image();
                    img.src = event.target.result;
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        let { width, height } = img;

                        if (width > height) {
                            if (width > maxWidth) {
                                height = Math.round(height * (maxWidth / width));
                                width = maxWidth;
                            }
                        } else {
                            if (height > maxHeight) {
                                width = Math.round(width * (maxHeight / height));
                                height = maxHeight;
                            }
                        }

                        canvas.width = width;
                        canvas.height = height;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0, width, height);

                        const mimeType = file.type === 'image/png' ? 'image/png' : 'image/jpeg';
                        const dataUrl = canvas.toDataURL(mimeType, quality);

                        resolve(dataUrl);
                    };
                    img.onerror = error => reject(new Error("Image could not be loaded. It might be corrupted or in an an unsupported format."));
                };
                reader.onerror = error => reject(new Error("File could not be read."));
            });

            const convertDataURLToJpeg = (dataUrl) => new Promise((resolve, reject) => {
                const mimeType = dataUrl.match(/:(.*?);/)?.[1];
                if (mimeType !== 'image/svg+xml') {
                    resolve(dataUrl);
                    return;
                }

                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    const ctx = canvas.getContext('2d');
                    ctx.fillStyle = '#FFFFFF';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(img, 0, 0);
                    const jpegDataUrl = canvas.toDataURL('image/jpeg', 0.9);
                    resolve(jpegDataUrl);
                };
                img.onerror = (err) => {
                    console.error("SVG Conversion Error:", err);
                    reject(new Error('Failed to load SVG image for conversion.'));
                };
                img.src = dataUrl;
            });

            // Compress an image data URL by drawing to canvas and exporting as JPEG
            const compressImageDataUrl = (dataUrl, maxWidth = 1200, maxHeight = 1200, quality = 0.75) => new Promise((resolve) => {
                if (typeof dataUrl !== 'string' || !dataUrl.startsWith('data:image/')) return resolve(dataUrl);
                const img = new Image();
                img.onload = () => {
                    let { width, height } = img;
                    if (width > maxWidth) {
                        height = Math.round(height * (maxWidth / width));
                        width = maxWidth;
                    }
                    if (height > maxHeight) {
                        width = Math.round(width * (maxHeight / height));
                        height = maxHeight;
                    }
                    const canvas = document.createElement('canvas');
                    canvas.width = width;
                    canvas.height = height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0, width, height);
                    try {
                        const out = canvas.toDataURL('image/jpeg', quality);
                        resolve(out);
                    } catch (e) {
                        console.error('Image compression failed', e);
                        resolve(dataUrl);
                    }
                };
                img.onerror = () => resolve(dataUrl);
                img.src = dataUrl;
            });

            const getLocalizedText = (obj, field, lang, fallback = '') => {
                if (!obj || !obj[field]) return fallback;
                const value = (obj[field][lang] || obj[field][lang === 'en' ? 'fa' : 'en'] || '').toString().trim();
                return value || fallback;
            };

            // تابع تمیز کردن نام محصول - خیلی تهاجمی!
            const cleanProductName = (text) => {
                if (!text) return '';
                let cleaned = String(text).trim();
                // Treat obvious UI placeholders as empty
                try {
                    const placeholders = [TRANSLATIONS.productNameEn, TRANSLATIONS.productNameFa, TRANSLATIONS.descriptionEn, TRANSLATIONS.descriptionFa, TRANSLATIONS.untitled];
                    const normalize = (s) => (s || '').toString().trim();
                    const cleanedNormalized = cleaned;
                    for (const ph of placeholders) {
                        if (!ph) continue;
                        if (cleanedNormalized.toLowerCase() === normalize(ph).toLowerCase()) return '';
                    }
                } catch (e) {
                    // ignore if TRANSLATIONS not ready yet
                }

                // حذف کلمات ناخواسته با تمام احتمالات
                // CONFORT را با quote، space یا بدون
                cleaned = cleaned.replace(/\s*["']*(CONFORT|GLAMOUR|ARTE|COMFORT)["']*\s*/gi, ' ');
                
                // حذف کدهای محصول (حروف بزرگ + اعداد)
                cleaned = cleaned.replace(/\b[A-Z]{2,}\d+\b/g, '');
                cleaned = cleaned.replace(/\b[A-Z]{2}\d{2,}\b/g, '');
                
                // حذف کدهای محصول فقط اعداد یا فقط حروف بزرگ
                cleaned = cleaned.replace(/\b[A-Z]+\d+[A-Z]*\b/g, '');
                
                // حذف علامت‌های خاص
                cleaned = cleaned.replace(/['"]/g, '');
                cleaned = cleaned.replace(/[-_()]/g, ' ');
                
                // حذف اعداد تنها
                cleaned = cleaned.replace(/^\d+\s*/, '');
                cleaned = cleaned.replace(/\s*\d+$/, '');
                
                // حذف فاصله‌های اضافی
                cleaned = cleaned.replace(/\s+/g, ' ').trim();
                
                // اگر خالی شد مقدار خالی برگردان
                if (!cleaned || cleaned.length < 2) return '';
                return cleaned;
            };

            // Sanitize product data - clean all product names from CONFORT etc
            const sanitizeProduct = (product) => {
                if (!product) return product;
                const sanitized = { ...product };
                if (sanitized.name) {
                    // Do not aggressively clean English names here — only clean Persian.
                    if (sanitized.name.fa) sanitized.name.fa = cleanProductName(sanitized.name.fa);
                }
                return sanitized;
            };

            const getLocalizedTitle = (nameObj, lang, fallback = '') => {
                if (!nameObj) return fallback;
                let enText = nameObj.en?.toString().trim() || '';
                let faText = nameObj.fa?.toString().trim() || '';

                // Clean Persian name for display; keep English as-is (trimmed)
                if (faText) faText = cleanProductName(faText);
                return (lang === 'fa' ? (faText || enText) : (enText || faText)) || fallback;
            };

            const toLatinDigits = (str) => {
                if (str === undefined || str === null) return str;
                if (typeof str !== 'string') return str;
                const map = { '۰':'0','۱':'1','۲':'2','۳':'3','۴':'4','۵':'5','۶':'6','۷':'7','۸':'8','۹':'9', '٠':'0','١':'1','٢':'2','٣':'3','٤':'4','٥':'5','٦':'6','٧':'7','٨':'8','٩':'9' };
                return str.replace(/[۰-۹٠-٩]/g, c => map[c] || c);
            };

            const formatPrice = (value, currency = '', lang = 'en') => {
                if (value === undefined || value === null || value === '') return '';
                const n = Number(value);
                if (isNaN(n)) return String(value) + (currency ? (' ' + currency) : '');
                const locale = (lang === 'fa' || String(currency).includes('تومان') || String(currency).includes('ریال')) ? 'fa-IR' : 'en-US';
                const formatted = n.toLocaleString(locale) + (currency ? (' ' + currency) : '');
                // ensure digits are Latin (0-9) even when locale yields Persian digits
                return toLatinDigits(formatted);
            };

            const dataURLtoBlob = (dataurl) => {
                if (typeof dataurl !== 'string' || !dataurl.startsWith('data:')) {
                    throw new Error('Invalid input: not a data URL.');
                }
                const arr = dataurl.split(',');
                if (arr.length < 2) {
                    throw new Error('Invalid data URL: missing data part.');
                }
                const mimeMatch = arr[0].match(/:(.*?);/);
                if (!mimeMatch || mimeMatch.length < 2) {
                    console.error("Could not extract MIME type from data URL:", arr[0]);
                    throw new Error('Invalid data URL: MIME type could not be determined.');
                }
                const mime = mimeMatch[1];
                const bstr = atob(arr[1]);
                let n = bstr.length;
                const u8arr = new Uint8Array(n);
                for (let i = 0; i < n; i++) {
                    u8arr[i] = bstr.charCodeAt(i);
                }
                return new Blob([u8arr], { type: mime });
            };

            // --- NEW HOOK for scroll animations ---
            function useOnScreen(ref, options) {
                const [isIntersecting, setIntersecting] = useState(false);

                useEffect(() => {
                    const observer = new IntersectionObserver(
                        ([entry]) => {
                            setIntersecting(entry.isIntersecting);
                        },
                        options
                    );
                    const currentRef = ref.current;
                    if (currentRef) {
                        observer.observe(currentRef);
                    }
                    return () => {
                        if (currentRef) {
                            observer.unobserve(currentRef);
                        }
                    };
                }, [ref, options]);

                return isIntersecting;
            }


            // --- ICON COMPONENTS ---
            const PlusIcon = ({ className = "w-6 h-6" }) => (<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}><path strokeLinecap="round" strokeLinejoin="round" d="M12 4.5v15m7.5-7.5h-15" /></svg>);
            const PencilIcon = ({ className = "w-5 h-5" }) => (<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}><path strokeLinecap="round" strokeLinejoin="round" d="m16.862 4.487 1.687-1.688a1.875 1.875 0 1 1 2.652 2.652L10.582 16.07a4.5 4.5 0 0 1-1.897 1.13L6 18l.8-2.685a4.5 4.5 0 0 1 1.13-1.897l8.932-8.931Zm0 0L19.5 7.125M18 14v4.75A2.25 2.25 0 0 1 15.75 21H5.25A2.25 2.25 0 0 1 3 18.75V8.25A2.25 2.25 0 0 1 5.25 6H10" /></svg>);
            const TrashIcon = ({ className = "w-5 h-5" }) => (<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}><path strokeLinecap="round" strokeLinejoin="round" d="m14.74 9-.346 9m-4.788 0L9.26 9m9.968-3.21c.342.052.682.107 1.022.166m-1.022-.165L18.16 19.673a2.25 2.25 0 0 1-2.244 2.077H8.084a2.25 2.25 0 0 1-2.244-2.077L4.772 5.79m14.456 0a48.108 48.108 0 0 0-3.478-.397m-12 .562c.34-.059.68-.114 1.022-.165m0 0a48.11 48.11 0 0 1 3.478-.397m7.5 0v-.916c0-1.18-.91-2.134-2.036-2.134H8.036C6.91 2.75 6 3.664 6 4.834v.916m7.5 0a48.667 48.667 0 0 0-7.5 0" /></svg>);
            const ShareIcon = ({ className = "w-5 h-5" }) => (<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}><path strokeLinecap="round" strokeLinejoin="round" d="M7.217 10.907a2.25 2.25 0 1 0 0 2.186m0-2.186c.18.324.283.696.283 1.093s-.103.77-.283 1.093m0-2.186 9.566-5.314m-9.566 7.5 9.566 5.314m0 0a2.25 2.25 0 1 0 0-2.186m0 2.186c-.18.324-.283.696.283 1.093s.103.77.283 1.093m0-2.186-9.566-5.314" /></svg>);
            const XMarkIcon = ({ className = "w-6 h-6" }) => (<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}><path strokeLinecap="round" strokeLinejoin="round" d="M6 18 18 6M6 6l12 12" /></svg>);
            const CameraIcon = ({ className = "w-5 h-5" }) => (<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}><path strokeLinecap="round" strokeLinejoin="round" d="M6.827 6.175A2.31 2.31 0 0 1 5.186 7.23c-.38.054-.757.112-1.134.175C2.999 7.58 2.25 8.507 2.25 9.574V18a2.25 2.25 0 0 0 2.25 2.25h15A2.25 2.25 0 0 0 21.75 18V9.574c0-1.067-.75-1.994-1.802-2.169a47.865 47.865 0 0 0-1.134-.175 2.31 2.31 0 0 1-1.64-1.055l-.822-1.316a2.192 2.192 0 0 0-1.736-1.039 48.776 48.776 0 0 0-5.232 0 2.192 2.192 0 0 0-1.736 1.039l-.821 1.316Z" /><path strokeLinecap="round" strokeLinejoin="round" d="M16.5 12.75a4.5 4.5 0 1 1-9 0 4.5 4.5 0 0 1 9 0ZM18.75 10.5h.008v.008h-.008V10.5Z" /></svg>);
            const BuildingStorefrontIcon = ({ className = "w-8 h-8 text-slate-500 dark:text-slate-400" }) => (<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}><path strokeLinecap="round" strokeLinejoin="round" d="M13.5 21v-7.5A2.25 2.25 0 0 1 15.75 11.25h.5a2.25 2.25 0 0 1 2.25 2.25V21M3 16.06V4.75A2.25 2.25 0 0 1 5.25 2.5h13.5A2.25 2.25 0 0 1 21 4.75v11.31M3 16.06l1.622-1.622a1.5 1.5 0 0 1 2.12 0l1.622 1.622m0 0l2.12-2.12a1.5 1.5 0 0 1 2.12 0l2.12 2.12M3 16.06v4.69A2.25 2.25 0 0 0 5.25 23h13.5a2.25 2.25 0 0 0 2.25-2.25v-4.69" /></svg>);
            const Bars3Icon = ({ className = "w-6 h-6" }) => (<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}><path strokeLinecap="round" strokeLinejoin="round" d="M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25h16.5" /></svg>);
            const ChevronDownIcon = ({ className = "w-5 h-5" }) => (<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}><path strokeLinecap="round" strokeLinejoin="round" d="m19.5 8.25-7.5 7.5-7.5-7.5" /></svg>);
            const ChevronUpIcon = ({ className = "w-5 h-5" }) => (<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}><path strokeLinecap="round" strokeLinejoin="round" d="m4.5 15.75 7.5-7.5 7.5 7.5" /></svg>);
            const EllipsisVerticalIcon = ({ className = "w-6 h-6" }) => (<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}><path strokeLinecap="round" strokeLinejoin="round" d="M12 6.75a.75.75 0 1 1 0-1.5.75.75 0 0 1 0 1.5ZM12 12.75a.75.75 0 1 1 0-1.5.75.75 0 0 1 0 1.5ZM12 18.75a.75.75 0 1 1 0-1.5.75.75 0 0 1 0 1.5Z" /></svg>);
            const MicrophoneIcon = ({ className = "w-5 h-5", isListening }) => (
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
                    <path strokeLinecap="round" strokeLinejoin="round" d="M12 18.75a6 6 0 0 0 6-6v-1.5a6 6 0 0 0-12 0v1.5a6 6 0 0 0 6 6Z" />
                    <path strokeLinecap="round" strokeLinejoin="round" d="M19.5 12a7.5 7.5 0 1 1-15 0 7.5 7.5 0 0 1 15 0Z" />
                </svg>
            );
            const SunIcon = ({ className = "w-6 h-6" }) => (<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}><path strokeLinecap="round" strokeLinejoin="round" d="M12 3v2.25m6.364.386-1.591 1.591M21 12h-2.25m-.386 6.364-1.591-1.591M12 18.75V21m-4.773-4.227-1.591 1.591M5.25 12H3m4.227-4.773L5.636 5.636M15.75 12a3.75 3.75 0 1 1-7.5 0 3.75 3.75 0 0 1 7.5 0Z" /></svg>);
            const MoonIcon = ({ className = "w-6 h-6" }) => (<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}><path strokeLinecap="round" strokeLinejoin="round" d="M21.752 15.002A9.72 9.72 0 0 1 18 15.75c-5.385 0-9.75-4.365-9.75-9.75 0-1.33.266-2.597.748-3.752A9.753 9.753 0 0 0 3 11.25C3 16.635 7.365 21 12.75 21a9.753 9.753 0 0 0 9.002-5.998Z" /></svg>);
            const WhatsAppIcon = ({ className = "w-5 h-5" }) => (<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" fill="currentColor" className={className}><path d="M380.9 97.1C339 55.1 283.2 32 223.9 32c-122.4 0-222 99.6-222 222 0 39.1 10.2 77.3 29.6 111L0 480l117.7-30.9c32.4 17.7 68.9 27 106.1 27h.1c122.3 0 224.1-99.6 224.1-222 0-59.3-25.2-115-67.1-157zm-157 341.6c-33.8 0-67.3-8.8-97.2-25.4l-7-4.1-72.5 19 19.3-71.1-4.5-7.4c-18.5-30.3-28.2-65.7-28.2-101.7 0-101.7 82.8-184.5 184.6-184.5 49.3 0 95.6 19.2 130.4 54.1 34.8 34.9 56.2 81.2 56.1 130.5 0 101.8-84.9 184.6-186.6 184.6zm101.2-138.2c-5.5-2.8-32.8-16.2-37.9-18-5.1-1.9-8.8-2.8-12.5 2.8-3.7 5.6-14.3 18-17.6 21.8-3.2 3.7-6.5 4.2-12 1.4-32.6-16.3-54-29.1-75.5-66-5.7-9.8 5.7-9.1 16.3-30.3 1.8-3.7.9-6.9-.5-9.7-1.4-2.8-12.5-30.1-17.1-41.2-4.5-10.8-9.1-9.3-12.5-9.5-3.2-.2-6.9-.2-10.6-.2-3.7 0-9.7 1.4-14.8 6.9-5.1 5.6-19.4 19-19.4 46.3 0 27.3 19.9 53.7 22.6 57.4 2.8 3.7 39.1 59.7 94.8 83.8 35.2 15.2 49 16.5 66.6 13.9 10.7-1.6 32.8-13.4 37.4-26.4 4.6-13 4.6-24.1 3.2-26.4-1.3-2.5-5-3.9-10.5-6.6z" /></svg>);
            // Control Panel Icons
            const ChartPieIcon = ({ className = "w-6 h-6" }) => (<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}><path strokeLinecap="round" strokeLinejoin="round" d="M10.5 6a7.5 7.5 0 1 0 7.5 7.5h-7.5V6Z" /><path strokeLinecap="round" strokeLinejoin="round" d="M13.5 10.5H21A7.5 7.5 0 0 0 13.5 3v7.5Z" /></svg>);
            const Squares2X2Icon = ({ className = "w-6 h-6" }) => (<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}><path strokeLinecap="round" strokeLinejoin="round" d="M3.75 6A2.25 2.25 0 0 1 6 3.75h2.25A2.25 2.25 0 0 1 10.5 6v2.25a2.25 2.25 0 0 1-2.25 2.25H6a2.25 2.25 0 0 1-2.25-2.25V6ZM3.75 15.75A2.25 2.25 0 0 1 6 13.5h2.25a2.25 2.25 0 0 1 2.25 2.25V18a2.25 2.25 0 0 1-2.25 2.25H6a2.25 2.25 0 0 1-2.25-2.25v-2.25ZM13.5 6a2.25 2.25 0 0 1 2.25-2.25H18A2.25 2.25 0 0 1 20.25 6v2.25A2.25 2.25 0 0 1 18 10.5h-2.25a2.25 2.25 0 0 1-2.25-2.25V6ZM13.5 15.75a2.25 2.25 0 0 1 2.25-2.25H18a2.25 2.25 0 0 1 2.25 2.25V18A2.25 2.25 0 0 1 18 20.25h-2.25A2.25 2.25 0 0 1 13.5 18v-2.25Z" /></svg>);
            const TagIcon = ({ className = "w-6 h-6" }) => (<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}><path strokeLinecap="round" strokeLinejoin="round" d="M9.568 3H5.25A2.25 2.25 0 0 0 3 5.25v4.318c0 .597.237 1.17.659 1.591l9.581 9.581c.699.699 1.78.872 2.607.33a18.095 18.095 0 0 0 5.223-5.223c.542-.827.369-1.908-.33-2.607L11.16 3.66A2.25 2.25 0 0 0 9.568 3Z" /><path strokeLinecap="round" strokeLinejoin="round" d="M6 6h.008v.008H6V6Z" /></svg>);
            const CubeIcon = ({ className = "w-6 h-6" }) => (<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}><path strokeLinecap="round" strokeLinejoin="round" d="m21 7.5-9-5.25L3 7.5m18 0-9 5.25m9-5.25v9l-9 5.25M3 7.5l9 5.25M3 7.5v9l9 5.25m0-9v9" /></svg>);
            const Cog6ToothIcon = ({ className = "w-6 h-6" }) => (<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}><path strokeLinecap="round" strokeLinejoin="round" d="M9.594 3.94c.09-.542.56-.94 1.11-.94h2.593c.55 0 1.02.398 1.11.94l.213 1.281c.063.374.26.716.53 1.003l.867.867c.39.39.39 1.024 0 1.414l-.867.867c-.27.287-.467.629-.53 1.003l-.213 1.281c-.09.543-.56.94-1.11.94h-2.594c-.55 0-1.02-.398-1.11-.94l-.213-1.281c-.063-.374-.26-.716-.53-1.003l-.867-.867c-.39-.39-.39-1.024 0 1.414l.867.867c.27.287.467.629.53 1.003l.213-1.281Z" /><path strokeLinecap="round" strokeLinejoin="round" d="M15 12a3 3 0 1 1-6 0 3 3 0 0 1 6 0Z" /></svg>);
            const ArrowLeftOnRectangleIcon = ({ className = "w-6 h-6" }) => (<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}><path strokeLinecap="round" strokeLinejoin="round" d="M8.25 9V5.25A2.25 2.25 0 0 1 10.5 3h6a2.25 2.25 0 0 1 2.25 2.25v13.5A2.25 2.25 0 0 1 16.5 21h-6a2.25 2.25 0 0 1-2.25-2.25V15m-3 0-3-3m0 0 3-3m-3 3H15" /></svg>);

            // --- UI COMPONENTS ---
            // Wrapper for scroll animations
            function AnimatedWrapper({ children, index }) {
                const ref = useRef();
                // A bit of rootMargin makes the animation trigger slightly before it's fully in view
                const isVisible = useOnScreen(ref, { threshold: 0.1, rootMargin: '0px 0px -20px 0px' });

                return (
                    <div
                        ref={ref}
                        className={`transform transition-all duration-1000 ease-out ${isVisible ? 'opacity-100 translate-x-0' : 'opacity-0 translate-x-40'}`}
                        style={{ transitionDelay: `${index * 150}ms` }}
                    >
                        {children}
                    </div>
                );
            }

            // --- TOAST NOTIFICATION COMPONENTS ---
            function Toast({ message, type, onDismiss }) {
                const [exiting, setExiting] = useState(false);
                const toastRef = useRef(null);

                useEffect(() => {
                    // This ensures the timer starts only once per toast.
                    if (!toastRef.current) {
                        toastRef.current = setTimeout(() => {
                            setExiting(true);
                            setTimeout(onDismiss, 300);
                        }, 4000);
                    }

                    return () => {
                        if (toastRef.current) {
                            clearTimeout(toastRef.current);
                        }
                    };
                }, [onDismiss]);

                const handleDismiss = () => {
                    if (toastRef.current) clearTimeout(toastRef.current);
                    setExiting(true);
                    setTimeout(onDismiss, 300);
                };

                const typeConfig = {
                    success: {
                        classes: 'bg-green-600/80 border-green-500',
                        icon: <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
                    },
                    error: {
                        classes: 'bg-red-600/80 border-red-500',
                        icon: <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
                    },
                    info: {
                        classes: 'bg-blue-600/80 border-blue-500',
                        icon: <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
                    },
                    warning: {
                        classes: 'bg-yellow-500/80 border-yellow-400',
                        icon: <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" /></svg>
                    }
                };

                const { classes, icon } = typeConfig[type] || typeConfig.info;

                return (
                    <div className={`w-full max-w-sm rounded-lg shadow-lg backdrop-blur-xl ring-1 ring-white/20 p-4 flex items-start gap-3 transition-all duration-300 ease-in-out transform ${classes} ${exiting ? 'opacity-0 translate-x-full' : 'opacity-100 translate-x-0'}`}>
                        <div className="flex-shrink-0 text-white">{icon}</div>
                        <div className="flex-grow text-white text-sm font-medium">{message}</div>
                        <button onClick={handleDismiss} className="text-white/70 hover:text-white flex-shrink-0 ml-2">
                            <XMarkIcon className="w-5 h-5" />
                        </button>
                    </div>
                );
            }

            function ToastContainer({ toasts, dismissToast }) {
                return (
                    <div className="fixed bottom-4 right-4 z-[100] w-full max-w-sm space-y-3">
                        {toasts.map(toast => (
                            <Toast
                                key={toast.id}
                                message={toast.message}
                                type={toast.type}
                                onDismiss={() => dismissToast(toast.id)}
                            />
                        ))}
                    </div>
                );
            }

            function Lightbox({ imageUrl, onClose }) {
                if (!imageUrl) return null;

                useEffect(() => {
                    const handleKeyDown = (e) => {
                        if (e.key === 'Escape') {
                            onClose();
                        }
                    };
                    window.addEventListener('keydown', handleKeyDown);
                    return () => window.removeEventListener('keydown', handleKeyDown);
                }, [onClose]);

                return (
                    <div
                        className="fixed inset-0 bg-black/80 backdrop-blur-sm flex items-center justify-center z-50 animate-fade-in"
                        onClick={onClose}
                    >
                        <div className="relative w-[90vw] h-[90vh] animate-slide-up flex items-center justify-center" onClick={e => e.stopPropagation()}>
                            <img src={imageUrl} alt="Full screen view" className="w-full h-full object-contain rounded-lg shadow-2xl" />
                            <button
                                onClick={onClose}
                                className="absolute top-4 right-4 bg-slate-700/80 text-white rounded-full p-3 hover:bg-slate-600 transition-colors focus:outline-none focus:ring-2 focus:ring-blue-500"
                                aria-label="Close image view"
                            >
                                <XMarkIcon className="w-6 h-6" />
                            </button>
                        </div>
                    </div>
                );
            }

            function ConfirmModal({ isOpen, title, message, onConfirm, onClose, confirmText, confirmClass }) {
                if (!isOpen) return null;

                return (
                    <div className="fixed inset-0 bg-black/70 backdrop-blur-sm flex items-center justify-center z-50 animate-fade-in">
                        <div className="bg-white dark:bg-slate-800/80 backdrop-blur-xl ring-1 dark:ring-white/10 rounded-lg shadow-2xl w-full max-w-md flex flex-col animate-slide-up" onClick={e => e.stopPropagation()}>
                            <header className={`p-4 border-b border-slate-200 dark:border-slate-700 flex justify-between items-center`}>
                                <h2 className={`text-xl font-bold ${confirmClass ? confirmClass.replace(/bg-(.*?)-(\d+)/, 'text-$1-500 dark:text-$1-400') : 'text-slate-900 dark:text-white'}`}>{title}</h2>
                                <button onClick={onClose} className="text-slate-500 dark:text-slate-400 hover:text-slate-800 dark:hover:text-white"><XMarkIcon /></button>
                            </header>
                            <div className="p-6">
                                <p className="text-slate-600 dark:text-slate-300">{message}</p>
                            </div>
                            <footer className="p-4 border-t border-slate-200 dark:border-slate-700 flex justify-end gap-2">
                                <button type="button" onClick={onClose} className="px-4 py-2 bg-slate-200 dark:bg-slate-600 rounded-md hover:bg-slate-300 dark:hover:bg-slate-500 font-semibold transition-colors text-slate-800 dark:text-slate-100">{TRANSLATIONS.cancel}</button>
                                <button type="button" onClick={onConfirm} className={`px-4 py-2 rounded-md font-semibold transition-colors text-white ${confirmClass}`}>{confirmText}</button>
                            </footer>
                        </div>
                    </div>
                );
            }

            function CameraSearchModal({ isOpen, onClose, onCapture, addToast }) {
                const videoRef = useRef(null);
                const canvasRef = useRef(null);
                const streamRef = useRef(null);

                useEffect(() => {
                    const startCamera = async () => {
                        if (isOpen) {
                            try {
                                const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } });
                                streamRef.current = stream;
                                if (videoRef.current) {
                                    videoRef.current.srcObject = stream;
                                }
                            } catch (err) {
                                console.error("Error accessing camera:", err);
                                addToast(TRANSLATIONS.cameraError, 'error');
                                onClose();
                            }
                        }
                    };

                    const stopCamera = () => {
                        if (streamRef.current) {
                            streamRef.current.getTracks().forEach(track => track.stop());
                            streamRef.current = null;
                        }
                    };

                    if (isOpen) {
                        startCamera();
                    }

                    return () => stopCamera();
                }, [isOpen, onClose, addToast]);

                const handleCapture = () => {
                    if (videoRef.current && canvasRef.current) {
                        const video = videoRef.current;
                        const canvas = canvasRef.current;

                        canvas.width = video.videoWidth;
                        canvas.height = video.videoHeight;

                        const context = canvas.getContext('2d');
                        context.drawImage(video, 0, 0, video.videoWidth, video.videoHeight);

                        const imageDataUrl = canvas.toDataURL('image/jpeg', 0.9);
                        onCapture(imageDataUrl);
                    }
                };

                if (!isOpen) return null;

                return (
                    <div className="fixed inset-0 bg-black/90 flex items-center justify-center z-50 animate-fade-in" onClick={onClose}>
                        <div className="bg-black rounded-lg shadow-2xl w-full h-full flex flex-col animate-slide-up relative overflow-hidden" onClick={e => e.stopPropagation()}>
                            <video ref={videoRef} autoPlay playsInline className="w-full h-full object-cover"></video>
                            <canvas ref={canvasRef} className="hidden"></canvas>
                            <div className="absolute bottom-0 left-0 right-0 p-6 bg-gradient-to-t from-black/70 to-transparent flex justify-center gap-6 items-center">
                                <button type="button" onClick={onClose} className="px-8 py-3 bg-slate-600/80 rounded-full hover:bg-slate-500 font-semibold transition-colors text-lg ring-1 ring-white/20 backdrop-blur-sm">{TRANSLATIONS.cancel}</button>
                                <button type="button" onClick={handleCapture} className="w-20 h-20 bg-white rounded-full ring-4 ring-white/30 hover:ring-white/50 transition-all flex items-center justify-center">
                                    <div className="w-16 h-16 bg-white rounded-full ring-2 ring-slate-800"></div>
                                </button>
                            </div>
                            <button onClick={onClose} className="absolute top-4 right-4 bg-black/50 text-white rounded-full p-2 hover:bg-black/80 transition-colors">
                                <XMarkIcon className="w-8 h-8" />
                            </button>
                        </div>
                    </div>
                );
            }

            function ApiKeyModal({ isOpen, onClose, onSave }) {
                if (!isOpen) return null;
                const [keyInput, setKeyInput] = useState('');

                const handleSave = () => {
                    if (keyInput.trim()) {
                        onSave(keyInput.trim());
                    }
                };

                return (
                    <div className="fixed inset-0 bg-black/70 backdrop-blur-sm flex items-start justify-center z-50 p-4 pt-16 sm:pt-24" onClick={onClose}>
                        <div className="bg-white dark:bg-slate-800/80 backdrop-blur-xl ring-1 dark:ring-white/10 rounded-lg shadow-2xl w-full max-w-md flex flex-col animate-slide-up" onClick={e => e.stopPropagation()}>
                            <header className="p-4 border-b border-slate-200 dark:border-slate-700 flex justify-between items-center">
                                <h2 className="text-xl font-bold text-yellow-500 dark:text-yellow-400">{TRANSLATIONS.apiKeyModalTitle}</h2>
                                <button onClick={onClose} className="text-slate-500 dark:text-slate-400 hover:text-slate-800 dark:hover:text-white"><XMarkIcon /></button>
                            </header>
                            <div className="p-6 space-y-4">
                                <p className="text-slate-600 dark:text-slate-300">{TRANSLATIONS.apiKeyModalMessage}</p>
                                <input
                                    type="password"
                                    value={keyInput}
                                    onChange={e => setKeyInput(e.target.value)}
                                    placeholder={TRANSLATIONS.apiKeyModalPlaceholder}
                                    className="w-full bg-slate-100 dark:bg-slate-900/80 rounded-md p-2 text-slate-800 dark:text-slate-200 ring-1 ring-slate-300 dark:ring-slate-700 focus:ring-blue-500 focus:outline-none"
                                    onKeyPress={(e) => e.key === 'Enter' && handleSave()}
                                />
                            </div>
                            <footer className="p-4 border-t border-slate-200 dark:border-slate-700 flex justify-end gap-2">
                                <button type="button" onClick={onClose} className="px-4 py-2 bg-slate-200 dark:bg-slate-600 rounded-md hover:bg-slate-300 dark:hover:bg-slate-500 font-semibold transition-colors text-slate-800 dark:text-slate-100">{TRANSLATIONS.cancel}</button>
                                <button type="button" onClick={handleSave} className="px-4 py-2 bg-blue-600 rounded-md hover:bg-blue-500 font-semibold transition-colors text-white">{TRANSLATIONS.save}</button>
                            </footer>
                        </div>
                    </div>
                );
            }

            function WelcomeSettingsModal({ isOpen, onClose, onSave, addToast }) {
                if (!isOpen) return null;

                const [backgroundType, setBackgroundType] = useState('photos');
                const [images, setImages] = useState([]);
                const [backgroundVideo, setBackgroundVideo] = useState(null);
                const [promoVideo, setPromoVideo] = useState(null);
                const [heroMediaType, setHeroMediaType] = useState('video');
                const [heroMediaUrl, setHeroMediaUrl] = useState(null);
                const [heroHeading, setHeroHeading] = useState('');
                const [heroBody, setHeroBody] = useState('');
                const [isProcessing, setIsProcessing] = useState(true);

                const imageInputRef = useRef(null);
                const bgVideoInputRef = useRef(null);
                const promoVideoInputRef = useRef(null);
                const heroMediaInputRef = useRef(null);

                useEffect(() => {
                    const loadData = async () => {
                        setIsProcessing(true);
                        const [imgConf, promoVidConf, bgTypeConf, bgVidConf, heroBlockConf] = await Promise.all([
                            dbGet(STORES.CONFIG, 'welcome_images'),
                            dbGet(STORES.CONFIG, 'welcome_video'),
                            dbGet(STORES.CONFIG, 'welcome_background_type'),
                            dbGet(STORES.CONFIG, 'welcome_background_video')
                            , dbGet(STORES.CONFIG, 'hero_media_block')
                        ]);
                        setImages(imgConf?.value || []);
                        setPromoVideo(promoVidConf?.value || null);
                        setBackgroundType(bgTypeConf?.value || 'photos');
                        setBackgroundVideo(bgVidConf?.value || null);
                        const heroConf = heroBlockConf?.value || null;
                        setHeroMediaType(heroConf?.mediaType || 'video');
                        setHeroMediaUrl(heroConf?.mediaUrl || null);
                        setHeroHeading(heroConf?.heading || '');
                        setHeroBody(heroConf?.body || '');
                        setIsProcessing(false);
                    };
                    loadData();
                }, []);

                const handleImageUpload = async (e) => {
                    const files = Array.from(e.target.files).slice(0, 40 - images.length);
                    if (!files.length) return;

                    setIsProcessing(true);
                    addToast(`Processing ${files.length} image(s)...`, 'info');

                    try {
                        const base64files = await Promise.all(
                            files.map(file => fileToBase64(file).catch(err => {
                                console.error("Error processing a file:", file.name, err);
                                return null;
                            }))
                        );

                        const successfulUploads = base64files.filter(Boolean);
                        setImages(prev => [...prev, ...successfulUploads].slice(0, 40));

                        if (successfulUploads.length < files.length) {
                            addToast(`Could not process ${files.length - successfulUploads.length} image(s).`, 'warning');
                        }
                    } catch (error) {
                        addToast(`An unexpected error occurred during image processing.`, 'error');
                    } finally {
                        setIsProcessing(false);
                    }
                };

                const createVideoHandler = (setter) => async (e) => {
                    const file = e.target.files[0];
                    if (!file) return;
                    if (file.size > 50 * 1024 * 1024) { // 50MB limit
                        addToast("Video file is too large. Please select a file smaller than 50MB.", "error");
                        return;
                    }
                    setIsProcessing(true);
                    addToast("Processing video...", 'info');
                    try {
                        const dataUrl = await fileToDataURL(file);
                        setter(dataUrl);
                    } catch (error) {
                        console.error("Video processing error:", error);
                        addToast("Failed to process video file.", 'error');
                    } finally {
                        setIsProcessing(false);
                    }
                };

                const handleBackgroundVideoUpload = createVideoHandler(setBackgroundVideo);
                const handlePromoVideoUpload = createVideoHandler(setPromoVideo);
                const handleHeroMediaUpload = createVideoHandler(setHeroMediaUrl);

                const handleRemoveImage = (indexToRemove) => {
                    setImages(prev => prev.filter((_, index) => index !== indexToRemove));
                };

                const handleSave = () => {
                    const heroMediaBlock = {
                        mediaType: heroMediaType,
                        mediaUrl: heroMediaUrl,
                        heading: heroHeading,
                        body: heroBody
                    };
                    onSave({ images, promoVideo, backgroundType, backgroundVideo, heroMediaBlock });
                };

                return (
                    <div className="fixed inset-0 bg-black/70 backdrop-blur-sm flex items-start justify-center z-50 p-4 pt-16 sm:pt-24" onClick={onClose}>
                        <div className="bg-white dark:bg-slate-800/80 backdrop-blur-xl ring-1 dark:ring-white/10 rounded-lg shadow-2xl w-full max-w-4xl max-h-[80vh] flex flex-col animate-slide-up text-slate-800 dark:text-slate-200" onClick={e => e.stopPropagation()}>
                            <header className="p-4 border-b border-slate-200 dark:border-slate-700 flex justify-between items-center flex-shrink-0">
                                <h2 className="text-xl font-bold text-blue-600 dark:text-blue-400">{TRANSLATIONS.welcomeSettingsTitle}</h2>
                                <button onClick={onClose} className="text-slate-500 dark:text-slate-400 hover:text-slate-800 dark:hover:text-white"><XMarkIcon /></button>
                            </header>

                            <div className="p-6 space-y-8 overflow-y-auto">
                                {/* Section 1: Welcome Background */}
                                <div className="space-y-4">
                                    <h3 className="text-lg font-semibold border-b border-slate-200 dark:border-slate-700 pb-2">{TRANSLATIONS.welcomeBackground}</h3>
                                    <fieldset className="flex gap-4">
                                        <legend className="sr-only">{TRANSLATIONS.backgroundType}</legend>
                                        <div>
                                            <input type="radio" id="bg_type_photos" name="bg_type" value="photos" checked={backgroundType === 'photos'} onChange={() => setBackgroundType('photos')} className="sr-only" />
                                            <label htmlFor="bg_type_photos" className={`px-4 py-2 rounded-md font-medium cursor-pointer transition-colors ${backgroundType === 'photos' ? 'bg-blue-600 text-white' : 'bg-slate-200 dark:bg-slate-700 hover:bg-slate-300 dark:hover:bg-slate-600'}`}>{TRANSLATIONS.imageSlideshow}</label>
                                        </div>
                                        <div>
                                            <input type="radio" id="bg_type_video" name="bg_type" value="video" checked={backgroundType === 'video'} onChange={() => setBackgroundType('video')} className="sr-only" />
                                            <label htmlFor="bg_type_video" className={`px-4 py-2 rounded-md font-medium cursor-pointer transition-colors ${backgroundType === 'video' ? 'bg-blue-600 text-white' : 'bg-slate-200 dark:bg-slate-700 hover:bg-slate-300 dark:hover:bg-slate-600'}`}>{TRANSLATIONS.backgroundVideo}</label>
                                        </div>
                                    </fieldset>

                                    {backgroundType === 'photos' ? (
                                        <>
                                            <div className="grid grid-cols-3 sm:grid-cols-4 md:grid-cols-5 lg:grid-cols-6 gap-4">
                                                {images.map((img, index) => (
                                                    <div key={index} className="relative group aspect-square">
                                                        <img src={img} className="w-full h-full object-cover rounded-md bg-slate-200 dark:bg-slate-700" />
                                                        <div className="absolute inset-0 bg-black/50 opacity-0 group-hover:opacity-100 transition-opacity flex items-center justify-center">
                                                            <button onClick={() => handleRemoveImage(index)} className="p-2 bg-red-600/80 rounded-full text-white hover:bg-red-500" title="Delete Image"><TrashIcon className="w-5 h-5" /></button>
                                                        </div>
                                                    </div>
                                                ))}
                                                {images.length < 40 && (
                                                    <button onClick={() => imageInputRef.current?.click()} disabled={isProcessing} className="aspect-square flex items-center justify-center bg-slate-100 dark:bg-slate-900/50 border-2 border-dashed border-slate-300 dark:border-slate-600 rounded-lg cursor-pointer hover:bg-slate-200 dark:hover:bg-slate-700/60 hover:border-blue-500 transition-all text-slate-500 dark:text-slate-400 disabled:cursor-wait">
                                                        {isProcessing ? <svg className="animate-spin h-8 w-8 text-slate-800 dark:text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle><path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg> : <div className="text-center"><PlusIcon className="mx-auto h-8 w-8" /><span className="mt-1 block text-xs font-medium">{TRANSLATIONS.addWelcomeImages}</span></div>}
                                                    </button>
                                                )}
                                            </div>
                                            <input ref={imageInputRef} type="file" accept="image/jpeg, image/png, image/webp" multiple className="hidden" onChange={handleImageUpload} />
                                        </>
                                    ) : (
                                        <>
                                            <p className="text-slate-600 dark:text-slate-300 text-sm">{TRANSLATIONS.backgroundVideoInfo}</p>
                                            <div className="w-full max-w-sm">
                                                {!isProcessing && backgroundVideo ? (
                                                    <div className="space-y-2">
                                                        <video src={backgroundVideo} controls className="w-full rounded-lg"></video>
                                                        <div className="flex gap-2">
                                                            <button onClick={() => bgVideoInputRef.current?.click()} className="px-4 py-2 bg-slate-200 dark:bg-slate-600 rounded-md hover:bg-slate-300 dark:hover:bg-slate-500 font-semibold transition-colors">{TRANSLATIONS.replaceVideo}</button>
                                                            <button onClick={() => setBackgroundVideo(null)} className="px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-500 font-semibold transition-colors">{TRANSLATIONS.deleteVideo}</button>
                                                        </div>
                                                    </div>
                                                ) : (
                                                    <button onClick={() => bgVideoInputRef.current?.click()} disabled={isProcessing} className="w-full h-32 flex items-center justify-center bg-slate-100 dark:bg-slate-900/50 border-2 border-dashed border-slate-300 dark:border-slate-600 rounded-lg cursor-pointer hover:bg-slate-200 dark:hover:bg-slate-700/60 hover:border-blue-500 transition-all text-slate-500 dark:text-slate-400 disabled:cursor-wait">
                                                        {isProcessing ? <svg className="animate-spin h-8 w-8 text-slate-800 dark:text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle><path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg> : <div className="text-center"><PlusIcon className="mx-auto h-8 w-8" /><span className="mt-1 block text-xs font-medium">{TRANSLATIONS.uploadBackgroundVideo}</span></div>}
                                                    </button>
                                                )}
                                            </div>
                                            <input ref={bgVideoInputRef} type="file" accept="video/mp4,video/webm" className="hidden" onChange={handleBackgroundVideoUpload} />
                                        </>
                                    )}
                                </div>

                                {/* Section 3: Hero Media Block (right: video/image muted autoplay, left: text) */}
                                <div className="space-y-4">
                                    <h3 className="text-lg font-semibold border-b border-slate-200 dark:border-slate-700 pb-2">Hero Media Block</h3>
                                    <fieldset className="flex gap-4 items-center">
                                        <legend className="sr-only">Media Type</legend>
                                        <label className={`px-3 py-1 rounded-md cursor-pointer ${heroMediaType === 'video' ? 'bg-blue-600 text-white' : 'bg-slate-200'}`}>
                                            <input type="radio" name="hero_media_type" value="video" checked={heroMediaType === 'video'} onChange={() => setHeroMediaType('video')} className="sr-only" /> Video
                                        </label>
                                        <label className={`px-3 py-1 rounded-md cursor-pointer ${heroMediaType === 'image' ? 'bg-blue-600 text-white' : 'bg-slate-200'}`}>
                                            <input type="radio" name="hero_media_type" value="image" checked={heroMediaType === 'image'} onChange={() => setHeroMediaType('image')} className="sr-only" /> Image
                                        </label>
                                    </fieldset>
                                    <div className="w-full max-w-sm">
                                        {!isProcessing && heroMediaUrl ? (
                                            <div className="space-y-2">
                                                {heroMediaType === 'video' ? (
                                                    <video src={heroMediaUrl} controls className="w-full rounded-lg"></video>
                                                ) : (
                                                    <img src={heroMediaUrl} alt={heroHeading || 'Hero media'} className="w-full rounded-lg" />
                                                )}
                                                <div className="flex gap-2">
                                                    <button onClick={() => heroMediaInputRef.current?.click()} className="px-4 py-2 bg-slate-200 rounded-md hover:bg-slate-300 font-semibold">Replace</button>
                                                    <button onClick={() => setHeroMediaUrl(null)} className="px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-500 font-semibold">Delete</button>
                                                </div>
                                            </div>
                                        ) : (
                                            <button onClick={() => heroMediaInputRef.current?.click()} disabled={isProcessing} className="w-full h-32 flex items-center justify-center bg-slate-100 border-2 border-dashed border-slate-300 rounded-lg cursor-pointer hover:bg-slate-200 transition-all text-slate-500 disabled:cursor-wait">
                                                <div className="text-center"><PlusIcon className="mx-auto h-8 w-8" /><span className="mt-1 block text-xs font-medium">Upload media for hero block</span></div>
                                            </button>
                                        )}
                                    </div>
                                    <input ref={heroMediaInputRef} type="file" accept="image/*,video/mp4,video/webm" className="hidden" onChange={handleHeroMediaUpload} />

                                    <div>
                                        <label className="block text-sm font-medium text-slate-700">Heading</label>
                                        <input value={heroHeading} onChange={e => setHeroHeading(e.target.value)} className="w-full mt-1 p-2 rounded-md border ring-1 ring-slate-200 text-black" />
                                    </div>
                                    <div>
                                        <label className="block text-sm font-medium text-slate-700">Body</label>
                                        <textarea value={heroBody} onChange={e => setHeroBody(e.target.value)} rows={4} className="w-full mt-1 p-2 rounded-md border ring-1 ring-slate-200 text-black" />
                                    </div>
                                </div>

                                {/* Section 2: Promotional Video */}
                                <div className="space-y-4">
                                    <h3 className="text-lg font-semibold border-b border-slate-200 dark:border-slate-700 pb-2">{TRANSLATIONS.promotionalVideo}</h3>
                                    <p className="text-slate-600 dark:text-slate-300 text-sm">{TRANSLATIONS.promotionalVideoInfo}</p>
                                    <div className="w-full max-w-sm">
                                        {!isProcessing && promoVideo ? (
                                            <div className="space-y-2">
                                                <video src={promoVideo} controls className="w-full rounded-lg"></video>
                                                <div className="flex gap-2">
                                                    <button onClick={() => promoVideoInputRef.current?.click()} className="px-4 py-2 bg-slate-200 dark:bg-slate-600 rounded-md hover:bg-slate-300 dark:hover:bg-slate-500 font-semibold transition-colors">{TRANSLATIONS.replaceVideo}</button>
                                                    <button onClick={() => setPromoVideo(null)} className="px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-500 font-semibold transition-colors">{TRANSLATIONS.deleteVideo}</button>
                                                </div>
                                            </div>
                                        ) : (
                                            <button onClick={() => promoVideoInputRef.current?.click()} disabled={isProcessing} className="w-full h-32 flex items-center justify-center bg-slate-100 dark:bg-slate-900/50 border-2 border-dashed border-slate-300 dark:border-slate-600 rounded-lg cursor-pointer hover:bg-slate-200 dark:hover:bg-slate-700/60 hover:border-blue-500 transition-all text-slate-500 dark:text-slate-400 disabled:cursor-wait">
                                                {isProcessing ? <svg className="animate-spin h-8 w-8 text-slate-800 dark:text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle><path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg> : <div className="text-center"><PlusIcon className="mx-auto h-8 w-8" /><span className="mt-1 block text-xs font-medium">{TRANSLATIONS.promotionalVideo}</span></div>}
                                            </button>
                                        )}
                                    </div>
                                    <input ref={promoVideoInputRef} type="file" accept="video/mp4,video/webm" className="hidden" onChange={handlePromoVideoUpload} />
                                </div>

                            </div>

                            <footer className="p-4 border-t border-slate-200 dark:border-slate-700 flex justify-end gap-2 flex-shrink-0">
                                <button type="button" onClick={onClose} className="px-4 py-2 bg-slate-200 dark:bg-slate-600 rounded-md hover:bg-slate-300 dark:hover:bg-slate-500 font-semibold transition-colors">{TRANSLATIONS.cancel}</button>
                                <button type="button" onClick={handleSave} className="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-500 font-semibold transition-colors">{TRANSLATIONS.save}</button>
                            </footer>
                        </div>
                    </div>
                );
            }

            function HeroSection({ onEnterManagement, welcomeImages, welcomeBackgroundType, welcomeBackgroundVideo }) {
                const clickCountRef = useRef(0);
                const clickTimeoutRef = useRef(null);

                const [currentImageIndex, setCurrentImageIndex] = useState(0);
                const useVideo = welcomeBackgroundType === 'video' && welcomeBackgroundVideo;
                const images = welcomeImages && welcomeImages.length > 0 ? welcomeImages : DEFAULT_WELCOME_IMAGES;

                useEffect(() => {
                    if (useVideo || images.length <= 1) return;
                    const timer = setInterval(() => {
                        setCurrentImageIndex(prevIndex => (prevIndex + 1) % images.length);
                    }, 7000);
                    return () => clearInterval(timer);
                }, [useVideo, images, images.length]);


                const handleLogoClick = () => {
                    clearTimeout(clickTimeoutRef.current);
                    clickCountRef.current += 1;
                    if (clickCountRef.current === 7) {
                        onEnterManagement();
                        clickCountRef.current = 0;
                    } else {
                        clickTimeoutRef.current = setTimeout(() => {
                            clickCountRef.current = 0;
                        }, 800);
                    }
                };

                useEffect(() => {
                    // Load base64 file at runtime and set img src to data URI if available
                    if (window.IS_FILE_PROTOCOL) {
                        // Avoid fetch on file:// — keep default logo if present in DOM or assets
                        return;
                    }
                    fetch('assets/galstian-logo.b64').then(r => r.text()).then(b64 => {
                        if (b64 && b64.length > 50) {
                            const img = document.getElementById('appLogo');
                            if (img) img.src = 'data:image/png;base64,' + b64.trim();
                        }
                    }).catch(() => {
                        // ignore errors
                    });
                }, []);

                return (
                    <div className="h-screen w-full relative flex items-center justify-center text-center bg-slate-200 dark:bg-slate-950">
                        {useVideo ? (
                            <video
                                key={welcomeBackgroundVideo}
                                src={welcomeBackgroundVideo}
                                autoPlay
                                muted
                                loop
                                playsInline
                                className="absolute top-0 left-0 w-full h-full object-cover"
                            />
                        ) : (
                            images.map((image, index) => (
                                <div
                                    key={index}
                                    className={`hero-bg-slide ${index === currentImageIndex ? 'visible' : ''}`}
                                            style={ image ? { backgroundImage: `url(${image})` } : undefined }
                                />
                            ))
                        )}
                        <div className="absolute inset-0 bg-black/20"></div>

                        <div
                            id="logoContainer"
                            className="absolute top-20 left-6 sm:top-8 sm:left-8 z-20 cursor-pointer bg-transparent p-0 hover:opacity-95 transition-all duration-300"
                            onClick={handleLogoClick}
                        >
                            <img
                                id="appLogo"
                                src="assets/galstian-logo.png"
                                alt="GALSTIAN Logo"
                                className="h-14 sm:h-20 md:h-24 w-auto filter drop-shadow-2xl object-contain"
                                loading="eager"
                                style={{ 
                                    filter: 'brightness(1.2) contrast(1.1)',
                                    textShadow: '2px 2px 4px rgba(0,0,0,0.8)',
                                    background: 'transparent',
                                    ...(typeof window !== 'undefined' && window.innerWidth <= 900 ? { transform: 'translateY(12px)' } : {})
                                }}
                                onError={(e) => {
                                    const img = e.target;
                                    if (!img.dataset.triedFallback) {
                                        img.dataset.triedFallback = '1';
                                        img.src = 'https://cdn.imgurl.ir/uploads/i486287_logo01.png';
                                        return;
                                    }
                                    img.style.display = 'none';
                                    const fallback = document.createElement('div');
                                    fallback.className = 'text-white font-bold text-2xl md:text-4xl tracking-widest drop-shadow-lg font-vazir';
                                    fallback.textContent = 'گالستیان';
                                    img.parentElement.appendChild(fallback);
                                }}
                            />
                        </div>
                        <div className="absolute bottom-24 z-20 animate-bounce">
                            <svg className="w-8 h-8 text-white/70" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M19 9l-7 7-7-7"></path></svg>
                        </div>
                    </div>
                );
            }

            function HeroMediaBlock({ block }) {
                if (!block) return null;
                const { mediaType, mediaUrl, heading, body } = block;
                const allowedMedia = typeof mediaUrl === 'string' && (
                    mediaUrl.startsWith('data:') || mediaUrl.startsWith('blob:') || mediaUrl.startsWith('/') || mediaUrl.startsWith('./') || mediaUrl.startsWith('http') || mediaUrl.includes('uploaded_media') || mediaUrl.includes('assets')
                );
                return (
                    <section className="w-full mt-12" style={{ backgroundColor: '#F0EEE9' }}>
                        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-10">
                            <div className={`grid grid-cols-1 ${allowedMedia ? 'md:grid-cols-2' : ''} gap-6 items-center`}>
                                <div className="order-1 md:order-1">
                                    {heading && <h2 className="text-2xl md:text-3xl font-bold text-black">{heading}</h2>}
                                    {body && <p className="mt-3 text-base text-black leading-relaxed">{body}</p>}
                                </div>
                                {allowedMedia && (
                                    <div className="order-2 md:order-2">
                                        {mediaType === 'video' ? (
                                            <video src={mediaUrl} autoPlay muted loop playsInline className="w-full rounded-lg object-cover" />
                                        ) : (
                                            <img src={mediaUrl} alt={heading || 'Media'} className="w-full rounded-lg object-cover" />
                                        )}
                                    </div>
                                )}
                            </div>
                        </div>
                    </section>
                );
            }

            function WelcomeVideoSection({ videoSrc }) {
                if (!videoSrc) return null;

                return (
                    <div className="py-12 px-4 sm:px-8">
                        <div className="max-w-screen-xl mx-auto">
                            <div className="relative aspect-video bg-black rounded-lg shadow-2xl dark:shadow-[0_20px_50px_rgba(0,0,0,0.7)] ring-1 ring-black/5 dark:ring-white/10 overflow-hidden">
                                <video
                                    key={videoSrc}
                                    src={videoSrc}
                                    autoPlay
                                    muted
                                    loop
                                    playsInline
                                    className="w-full h-full object-cover"
                                >
                                    Your browser does not support the video tag.
                                </video>
                            </div>
                        </div>
                    </div>
                );
            }

            function BrandInfoSection({ brand, isManagementMode, onEdit, lang, scrollRef }) {
                const history = brand?.history;
                const hasContent = (history?.text?.en?.trim() || history?.text?.fa?.trim() || history?.logo);

                if (!hasContent && !isManagementMode) {
                    return null;
                }

                if (!brand) return null;

                return (
                    <div ref={scrollRef} className="py-12 px-4 sm:px-8">
                        <div className="relative max-w-4xl mx-auto my-8 bg-white dark:bg-slate-800 rounded-lg shadow-2xl dark:shadow-[0_20px_50px_rgba(0,0,0,0.7)] ring-1 ring-black/5 dark:ring-white/10">
                            {isManagementMode && (
                                <button
                                    onClick={onEdit}
                                    className="absolute top-4 right-4 z-10 p-2 bg-slate-100/80 dark:bg-slate-700/80 rounded-full text-blue-500 dark:text-blue-400 hover:bg-slate-200 dark:hover:bg-slate-600 transition-colors"
                                    aria-label={TRANSLATIONS.editBrandHistory}
                                >
                                    <PencilIcon className="w-5 h-5" />
                                </button>
                            )}

                            <div className="p-8">
                                {history?.logo && (
                                    <div className="mb-6 flex justify-center">
                                        <img src={history.logo} className="max-h-24 w-auto object-contain" alt="Brand history logo" />
                                    </div>
                                )}
                                {!hasContent && isManagementMode ? (
                                    <div className="text-center text-slate-500 dark:text-slate-400 py-8">
                                        <p>Click the edit button to add this brand's story.</p>
                                    </div>
                                ) : (
                                    <div className="space-y-4">
                                        {history?.text?.en && <p className="whitespace-pre-wrap text-slate-700 dark:text-slate-300 leading-relaxed font-sans">{history.text.en}</p>}
                                        {history?.text?.fa && <p className="whitespace-pre-wrap text-slate-700 dark:text-slate-300 leading-relaxed font-vazir text-right" dir="rtl">{history.text.fa}</p>}
                                    </div>
                                )}
                            </div>
                        </div>
                    </div>
                );
            }

            function HomePageContent({ brands, categories, setView, isManagementMode, openModal, openConfirm, handleDelete, lang, welcomeVideo }) {
                const [selectedBrandId, setSelectedBrandId] = useState(null);
                const [selectedBrand, setSelectedBrand] = useState(null);
                const categoriesContainerRef = useRef(null);
                const brandInfoRef = useRef(null);

                useEffect(() => {
                    if (selectedBrand) {
                        const updatedBrandData = brands.find(b => b.id === selectedBrand.id);
                        if (updatedBrandData) {
                            if (JSON.stringify(updatedBrandData) !== JSON.stringify(selectedBrand)) {
                                setSelectedBrand(updatedBrandData);
                            }
                        } else {
                            setSelectedBrand(null);
                            setSelectedBrandId(null);
                        }
                    }
                }, [brands, selectedBrand]);

                const filteredCategories = useMemo(() => {
                    if (!selectedBrandId) return [];
                    return categories.filter(c => c.brandId === selectedBrandId);
                }, [categories, selectedBrandId]);

                const handleBrandClick = async (brandId) => {
                    setSelectedBrandId(brandId);
                    const brandData = await dbGet(STORES.BRANDS, brandId);
                    setSelectedBrand(brandData);
                    setTimeout(() => {
                        brandInfoRef.current?.scrollIntoView({
                            behavior: 'smooth',
                            block: 'start'
                        });
                    }, 100);
                };

                return (
                    <>
                        <WelcomeVideoSection videoSrc={welcomeVideo} />
                        <div className="py-12">
                            <div className="max-w-screen-xl mx-auto px-4 sm:px-6 lg:px-8">
                                <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-4">
                                    {brands.map((brand, index) => (
                                        <AnimatedWrapper key={brand.id} index={index}>
                                            <div
                                                onClick={() => handleBrandClick(brand.id)}
                                                className={`group relative aspect-square transition-all duration-300 cursor-pointer rounded-lg overflow-hidden shadow-xl dark:shadow-[0_15px_30px_rgba(0,0,0,0.6)] hover:shadow-2xl dark:hover:shadow-[0_20px_40px_rgba(59,130,246,0.5)] ring-2 ${selectedBrandId === brand.id ? 'ring-blue-500 scale-105' : 'ring-transparent opacity-80 hover:opacity-100 hover:scale-105 hover:shadow-blue-500/40'}`}
                                            >
                                                <div className="absolute inset-0 bg-white dark:bg-slate-800 flex items-center justify-center p-4">
                                                    {brand.logo ? (
                                                        <img src={brand.logo} alt={getLocalizedTitle(brand.name, 'en')} className="max-w-full max-h-full object-contain transition-transform duration-300 group-hover:scale-105" />
                                                    ) : (
                                                        <BuildingStorefrontIcon className="w-1/2 h-1/2 text-slate-400 dark:text-slate-500 transition-transform duration-300 group-hover:scale-105" />
                                                    )}
                                                </div>
                                                <div className="absolute bottom-0 left-0 right-0 p-3 bg-gradient-to-t from-black/80 to-transparent">
                                                    <h3 className="text-sm font-bold text-white text-center truncate">
                                                        {getLocalizedTitle(brand.name, 'en', TRANSLATIONS.untitled)}
                                                    </h3>
                                                </div>

                                                {isManagementMode && (
                                                    <div className="absolute top-2 right-2 flex gap-1 opacity-0 group-hover:opacity-100 transition-opacity z-10">
                                                        <button onClick={(e) => { e.stopPropagation(); openModal('brand', 'edit', brand, {}) }} className="p-1.5 bg-slate-100/90 dark:bg-slate-800/90 rounded-full text-blue-500 dark:text-blue-400 hover:bg-slate-200 dark:hover:bg-slate-600 shadow-md"><PencilIcon className="w-4 h-4" /></button>
                                                        <button
                                                            onClick={(e) => {
                                                                e.stopPropagation();
                                                                openConfirm({
                                                                    title: `${TRANSLATIONS.delete} "${getLocalizedTitle(brand.name, lang, TRANSLATIONS.untitled)}"`,
                                                                    message: TRANSLATIONS.confirmDelete,
                                                                    confirmText: TRANSLATIONS.confirmDeleteAction,
                                                                    confirmClass: 'bg-red-600 hover:bg-red-500',
                                                                    onConfirm: () => handleDelete('brand', { brandId: brand.id })
                                                                })
                                                            }}
                                                            className="p-1.5 bg-slate-100/90 dark:bg-slate-800/90 rounded-full text-red-500 dark:text-red-400 hover:bg-slate-200 dark:hover:bg-slate-600 shadow-md"
                                                        >
                                                            <TrashIcon className="w-4 h-4" />
                                                        </button>
                                                    </div>
                                                )}
                                            </div>
                                        </AnimatedWrapper>
                                    ))}
                                    {isManagementMode && (
                                        <AnimatedWrapper index={brands.length}>
                                            <div
                                                onClick={() => openModal('brand', 'add', { id: generateId(), name: { en: '', fa: '' }, logo: null }, {})}
                                                className="aspect-square h-full transition-all duration-300 flex flex-col items-center justify-center gap-2 cursor-pointer rounded-lg bg-slate-200/50 dark:bg-slate-800/40 border-2 border-dashed border-slate-400 dark:border-slate-600 hover:bg-slate-200 dark:hover:bg-slate-700/60 hover:border-blue-500 text-slate-500 dark:text-slate-400"
                                            >
                                                <PlusIcon className="w-10 h-10" />
                                                <span className="text-sm font-semibold">{TRANSLATIONS.addBrand}</span>
                                            </div>
                                        </AnimatedWrapper>
                                    )}
                                </div>
                            </div>
                        </div>

                        {selectedBrandId && (
                            <BrandInfoSection
                                scrollRef={brandInfoRef}
                                brand={selectedBrand}
                                isManagementMode={isManagementMode}
                                onEdit={() => openModal('brand', 'edit', selectedBrand, {})}
                                lang={lang}
                            />
                        )}

                        <div ref={categoriesContainerRef} className="px-4 sm:px-8 pb-16">
                            {selectedBrandId ? (
                                <GridView
                                    items={filteredCategories}
                                    type="category"
                                    context={{ brandId: selectedBrandId }}
                                    setView={setView}
                                    openModal={openModal}
                                    openConfirm={openConfirm}
                                    handleDelete={handleDelete}
                                    isManagementMode={isManagementMode}
                                    lang={lang}
                                />
                            ) : (
                                <div className="text-center py-16 text-slate-500 dark:text-slate-400">
                                    <h3 className="text-2xl">Select a brand to view its collections</h3>
                                </div>
                            )}
                        </div>
                    </>
                );
            }

            function DropdownMenu({ name, activeMenu, setActiveMenu, triggerContent, children, triggerClassName = "header-tab-button flex items-center gap-1" }) {
                const dropdownRef = useRef(null);
                const isOpen = activeMenu === name;

                const handleToggle = useCallback((e) => {
                    e.stopPropagation();
                    setActiveMenu(prev => (prev === name ? null : name));
                }, [name, setActiveMenu]);

                const closeMenu = useCallback(() => {
                    setActiveMenu(null);
                }, [setActiveMenu]);

                useEffect(() => {
                    const handleClickOutside = (event) => {
                        if (dropdownRef.current && !dropdownRef.current.contains(event.target)) {
                            closeMenu();
                        }
                    };

                    if (isOpen) {
                        document.addEventListener('mousedown', handleClickOutside);
                    }

                    return () => {
                        document.removeEventListener('mousedown', handleClickOutside);
                    };
                }, [isOpen, closeMenu]);

                return (
                    <div className="relative" ref={dropdownRef}>
                        <button
                            onClick={handleToggle}
                            aria-haspopup="true"
                            aria-expanded={isOpen}
                            className={triggerClassName}
                        >
                            {triggerContent}
                        </button>

                        {isOpen && (
                            <div
                                className="absolute right-0 mt-2 w-56 origin-top-right rounded-md bg-white/80 dark:bg-slate-800/90 backdrop-blur-xl shadow-lg ring-1 ring-black/5 dark:ring-white/10 focus:outline-none z-30 animate-fade-in"
                                onClick={closeMenu}
                            >
                                <div className="py-1" role="menu" aria-orientation="vertical">
                                    {children}
                                </div>
                            </div>
                        )}
                    </div>
                );
            }

            function DropdownMenuItem({ children, onClick, disabled, className = '' }) {
                const baseClasses = "w-full text-left flex items-center px-4 py-2 text-sm text-slate-700 dark:text-slate-200 hover:bg-slate-100 dark:hover:bg-slate-700/80 disabled:text-slate-400 dark:disabled:text-slate-500 disabled:cursor-not-allowed disabled:hover:bg-transparent transition-colors";
                return (
                    <button
                        onClick={onClick}
                        disabled={disabled}
                        className={`${baseClasses} ${className}`}
                        role="menuitem"
                    >
                        {children}
                    </button>
                );
            }

            function DropdownMenuSeparator() {
                return <hr className="border-slate-200 dark:border-slate-700 my-1 mx-2" />;
            }

            const DesktopHeader = ({
                searchTerm, setSearchTerm, performSearch,
                handleAiFeatureClick, setIsAssistantOpen, setIsCameraSearchOpen,
                activeSearch, clearSearch, handleHomeClick, setIsWelcomeSettingsOpen,
                handleImportFromExcel, isImporting, handleExportToExcel, isExportingExcel,
                handleExportForSharing, setIsApiKeyModalOpen, handleImport, handleExport,
                theme, setTheme, exitManagementMode, setIsFooterSettingsOpen
            }) => {
                const [activeDropdown, setActiveDropdown] = useState(null);

                return (
                    <header className="hidden lg:block w-full p-4 flex-shrink-0 relative z-40">
                        <div className="mx-auto w-fit bg-white/60 dark:bg-black/40 backdrop-blur-2xl rounded-full shadow-[0_10px_40px_rgba(99,102,241,0.3),0_0_0_1px_rgba(0,0,0,0.1)] dark:shadow-[0_10px_40px_rgba(99,102,241,0.3),0_0_0_1px_rgba(255,255,255,0.1)] p-2 flex items-center gap-1">
                            <div className="flex-grow flex gap-1 items-center">
                                <input type="text" value={searchTerm} onChange={(e) => setSearchTerm(e.target.value)} onKeyPress={(e) => e.key === 'Enter' && performSearch()} placeholder={TRANSLATIONS.searchPlaceholder} className="w-full lg:w-64 bg-transparent placeholder-slate-500 dark:placeholder-white rounded-full px-4 py-2 focus:ring-0 focus:outline-none transition-shadow text-sm text-slate-800 dark:text-white" />
                                <button onClick={() => handleAiFeatureClick(() => setIsAssistantOpen(true))} className='header-tab-icon-button' title={TRANSLATIONS.searchWithVoice}><MicrophoneIcon /></button>
                                <button onClick={() => handleAiFeatureClick(() => setIsCameraSearchOpen(true))} className="header-tab-icon-button" title={TRANSLATIONS.searchWithImage}><CameraIcon /></button>
                                <button onClick={() => performSearch()} className="header-tab-button">{TRANSLATIONS.search}</button>
                                {activeSearch && <button onClick={clearSearch} className="header-tab-button">{TRANSLATIONS.clear}</button>}
                            </div>

                            <DropdownMenu
                                name="main-menu"
                                activeMenu={activeDropdown}
                                setActiveMenu={setActiveDropdown}
                                triggerContent={<EllipsisVerticalIcon className="w-5 h-5" />}
                                triggerClassName="header-tab-icon-button"
                            >
                                <DropdownMenuItem onClick={() => handleHomeClick()}>{TRANSLATIONS.brands}</DropdownMenuItem>
                                <DropdownMenuItem onClick={() => handleHomeClick({ type: 'controlPanel' })}>
                                    {TRANSLATIONS.controlPanel}
                                </DropdownMenuItem>
                                <DropdownMenuItem onClick={exitManagementMode} className="!text-yellow-600 dark:!text-yellow-400 hover:!bg-yellow-500/10 dark:hover:!bg-yellow-400/10">{TRANSLATIONS.exitShowroomMode}</DropdownMenuItem>
                                <DropdownMenuItem onClick={() => setIsWelcomeSettingsOpen(true)}>{TRANSLATIONS.welcomeSettings}</DropdownMenuItem>

                                <DropdownMenuSeparator />

                                <DropdownMenuItem onClick={handleImportFromExcel} disabled={isImporting}>{TRANSLATIONS.importFromExcel}</DropdownMenuItem>
                                <DropdownMenuItem onClick={handleImport} disabled={isImporting}>{TRANSLATIONS.importData}</DropdownMenuItem>

                                <DropdownMenuSeparator />

                                <DropdownMenuItem onClick={handleExportToExcel} disabled={isExportingExcel}>{isExportingExcel ? TRANSLATIONS.exporting : TRANSLATIONS.exportToExcel}</DropdownMenuItem>
                                <DropdownMenuItem onClick={handleExport}>{TRANSLATIONS.exportData}</DropdownMenuItem>
                                <DropdownMenuItem onClick={handleExportForSharing}>{TRANSLATIONS.exportForSharing}</DropdownMenuItem>

                                <DropdownMenuSeparator />

                                <DropdownMenuItem onClick={() => setIsFooterSettingsOpen(true)}>{TRANSLATIONS.footerSettings}</DropdownMenuItem>
                                <DropdownMenuItem onClick={() => setIsApiKeyModalOpen(true)}>{TRANSLATIONS.setApiKey}</DropdownMenuItem>
                                <DropdownMenuItem onClick={() => setTheme(t => t === 'dark' ? 'light' : 'dark')}>
                                    <div className="flex justify-between items-center w-full">
                                        <span>{TRANSLATIONS.theme}</span>
                                        {theme === 'dark' ? <SunIcon className="w-5 h-5" /> : <MoonIcon className="w-5 h-5" />}
                                    </div>
                                </DropdownMenuItem>
                            </DropdownMenu>
                        </div>
                    </header>
                )
            };

            const MobileHeader = ({
                isHeaderMenuOpen, setIsHeaderMenuOpen, lightboxImage,
                searchTerm, setSearchTerm, performSearch, activeSearch, clearSearch,
                handleAiFeatureClick, setIsAssistantOpen, setIsCameraSearchOpen,
                handleHomeClick, setIsWelcomeSettingsOpen, handleImportFromExcel, isImporting,
                handleExportToExcel, isExportingExcel, handleExportForSharing,
                setIsApiKeyModalOpen, handleImport, handleExport,
                theme, setTheme, exitManagementMode, setIsFooterSettingsOpen
            }) => {
                const [isImportOpen, setIsImportOpen] = useState(false);
                const [isExportOpen, setIsExportOpen] = useState(false);

                return (
                    <header className="lg:hidden">
                        <button
                            onClick={() => setIsHeaderMenuOpen(!isHeaderMenuOpen)}
                            className={`fixed top-4 right-4 z-50 text-slate-800 dark:text-white bg-white/80 dark:bg-slate-800/80 backdrop-blur-xl p-2 rounded-full shadow-lg ring-1 ring-black/10 dark:ring-white/20 transition-transform duration-300 hover:scale-110 ${lightboxImage ? 'hidden' : ''}`}
                        >
                            {isHeaderMenuOpen ? <XMarkIcon className="w-6 h-6" /> : <Bars3Icon className="w-6 h-6" />}
                        </button>
                        <div
                            className={`fixed top-0 left-0 right-0 z-40 bg-white/80 dark:bg-slate-900/80 backdrop-blur-xl shadow-2xl ring-1 ring-black/10 dark:ring-white/10 transition-transform duration-500 ease-in-out ${isHeaderMenuOpen ? 'translate-y-0' : '-translate-y-full'}`}
                        >
                            <div className="p-4 pt-20 flex flex-col gap-4">
                                <div className="w-full lg:w-auto flex-grow flex gap-1 items-center bg-black/5 dark:bg-black/20 rounded-full">
                                    <input type="text" value={searchTerm} onChange={(e) => setSearchTerm(e.target.value)} onKeyPress={(e) => e.key === 'Enter' && performSearch()} placeholder={TRANSLATIONS.searchPlaceholder} className="w-full bg-transparent placeholder-slate-500 dark:placeholder-white rounded-full px-4 py-2 focus:ring-0 focus:outline-none transition-shadow text-sm text-slate-800 dark:text-white" />
                                    <button onClick={() => handleAiFeatureClick(() => setIsAssistantOpen(true))} className='header-tab-icon-button' title={TRANSLATIONS.searchWithVoice}><MicrophoneIcon /></button>
                                    <button onClick={() => handleAiFeatureClick(() => setIsCameraSearchOpen(true))} className="header-tab-icon-button" title={TRANSLATIONS.searchWithImage}><CameraIcon /></button>
                                </div>
                                <div className="flex gap-2">
                                    <button onClick={() => performSearch()} className="header-tab-button flex-grow">{TRANSLATIONS.search}</button>
                                    {activeSearch && <button onClick={clearSearch} className="header-tab-button flex-grow">{TRANSLATIONS.clear}</button>}
                                </div>
                                <div className="flex flex-col gap-2">
                                    <button onClick={() => { handleHomeClick(); setIsHeaderMenuOpen(false); }} className="header-tab-button w-full text-left">{TRANSLATIONS.brands}</button>
                                    <button onClick={() => { handleHomeClick({ type: 'controlPanel' }); setIsHeaderMenuOpen(false); }} className="header-tab-button w-full text-left">{TRANSLATIONS.controlPanel}</button>
                                    <button onClick={() => { exitManagementMode(); setIsHeaderMenuOpen(false); }} className="header-tab-button w-full text-left !text-yellow-600 dark:!text-yellow-400 hover:!bg-yellow-500/20 hover:!text-yellow-500 dark:hover:!text-yellow-300">{TRANSLATIONS.exitShowroomMode}</button>
                                    <button onClick={() => { setIsWelcomeSettingsOpen(true); setIsHeaderMenuOpen(false); }} className="header-tab-button w-full text-left">{TRANSLATIONS.welcomeSettings}</button>

                                    <div>
                                        <button onClick={() => setIsImportOpen(p => !p)} className="header-tab-button w-full text-left flex justify-between items-center">
                                            {TRANSLATIONS.import}
                                            <ChevronDownIcon className={`w-5 h-5 transition-transform ${isImportOpen ? 'rotate-180' : ''}`} />
                                        </button>
                                        {isImportOpen && (
                                            <div className="pl-4 pt-2 flex flex-col gap-2 animate-fade-in">
                                                <button onClick={() => { handleImportFromExcel(); setIsHeaderMenuOpen(false); }} disabled={isImporting} className="header-tab-button w-full text-left">{TRANSLATIONS.importFromExcel}</button>
                                                <button onClick={() => { handleImport(); setIsHeaderMenuOpen(false); }} disabled={isImporting} className="header-tab-button w-full text-left">{TRANSLATIONS.importData}</button>
                                            </div>
                                        )}
                                    </div>
                                    <div>
                                        <button onClick={() => setIsExportOpen(p => !p)} className="header-tab-button w-full text-left flex justify-between items-center">
                                            {TRANSLATIONS.export}
                                            <ChevronDownIcon className={`w-5 h-5 transition-transform ${isExportOpen ? 'rotate-180' : ''}`} />
                                        </button>
                                        {isExportOpen && (
                                            <div className="pl-4 pt-2 flex flex-col gap-2 animate-fade-in">
                                                <button onClick={() => { handleExportToExcel(); setIsHeaderMenuOpen(false); }} disabled={isExportingExcel} className="header-tab-button w-full text-left">{isExportingExcel ? TRANSLATIONS.exporting : TRANSLATIONS.exportToExcel}</button>
                                                <button onClick={() => { handleExport(); setIsHeaderMenuOpen(false); }} className="header-tab-button w-full text-left">{TRANSLATIONS.exportData}</button>
                                                <button onClick={() => { handleExportForSharing(); setIsHeaderMenuOpen(false); }} className="header-tab-button w-full text-left">{TRANSLATIONS.exportForSharing}</button>
                                            </div>
                                        )}
                                    </div>
                                    <button onClick={() => { setIsFooterSettingsOpen(true); setIsHeaderMenuOpen(false); }} className="header-tab-button w-full text-left">{TRANSLATIONS.footerSettings}</button>
                                    <button onClick={() => { setIsApiKeyModalOpen(true); setIsHeaderMenuOpen(false); }} className="header-tab-button w-full text-left">{TRANSLATIONS.setApiKey}</button>
                                    <button onClick={() => setTheme(t => t === 'dark' ? 'light' : 'dark')} className="header-tab-button w-full text-left flex justify-between items-center">
                                        {TRANSLATIONS.theme}
                                        {theme === 'dark' ? <SunIcon className="w-5 h-5" /> : <MoonIcon className="w-5 h-5" />}
                                    </button>
                                </div>
                            </div>
                        </div>
                    </header>
                )
            };

            // --- CONTROL PANEL COMPONENTS ---

            function ControlPanelSidebar({ adminView, setAdminView, setView }) {
                const navItems = [
                    { id: 'overview', label: TRANSLATIONS.overview, icon: ChartPieIcon },
                    { id: 'products', label: TRANSLATIONS.manageProducts, icon: CubeIcon },
                    { id: 'brands', label: TRANSLATIONS.manageBrands, icon: TagIcon },
                    { id: 'categories', label: TRANSLATIONS.manageCategories, icon: Squares2X2Icon },
                    { id: 'settings', label: TRANSLATIONS.appSettings, icon: Cog6ToothIcon },
                ];

                return (
                    <aside className="w-64 bg-admin-sidebar border-r border-admin-border flex-shrink-0 flex flex-col backdrop-blur-lg">
                        <div className="p-4 border-b border-admin-border flex items-center gap-2">
                            <img
                                src="https://cdn.imgurl.ir/uploads/i486287_logo01.png"
                                alt="Logo"
                                className="h-10 w-auto filter dark:invert object-contain"
                                loading="eager"
                            />
                            <h1 className="text-xl font-bold">{TRANSLATIONS.controlPanel}</h1>
                        </div>
                        <nav className="flex-grow p-4 space-y-2">
                            {navItems.map(item => (
                                <button
                                    key={item.id}
                                    onClick={() => setAdminView(item.id)}
                                    className={`w-full flex items-center gap-3 px-3 py-2 rounded-md text-sm font-medium transition-colors ${adminView === item.id
                                        ? 'bg-admin-accent text-white'
                                        : 'text-admin-text-secondary hover:bg-admin-bg hover:text-admin-text-primary'
                                        }`}
                                >
                                    <item.icon className="w-5 h-5" />
                                    <span>{item.label}</span>
                                </button>
                            ))}
                        </nav>
                        <div className="p-4 border-t border-admin-border">
                            <button
                                onClick={() => setView({ type: 'brands' })}
                                className="w-full flex items-center gap-3 px-3 py-2 rounded-md text-sm font-medium text-admin-text-secondary hover:bg-admin-bg hover:text-admin-text-primary transition-colors"
                            >
                                <ArrowLeftOnRectangleIcon className="w-5 h-5" />
                                <span>{TRANSLATIONS.backToShowroom}</span>
                            </button>
                        </div>
                    </aside>
                );
            }

            function DashboardOverview({ setAdminView, openModal }) {
                const [stats, setStats] = useState({ brands: 0, categories: 0, products: 0 });

                useEffect(() => {
                    const fetchStats = async () => {
                        const [brands, categories, products] = await Promise.all([
                            dbGetAll(STORES.BRANDS),
                            dbGetAll(STORES.CATEGORIES),
                            dbGetAll(STORES.PRODUCTS),
                        ]);
                        setStats({
                            brands: brands.length,
                            categories: categories.length,
                            products: products.length,
                        });
                    };
                    fetchStats();
                }, []);

                const StatCard = ({ title, value, icon: Icon }) => (
                    <div className="bg-admin-sidebar p-6 rounded-lg shadow-md border border-admin-border flex items-center gap-4">
                        <div className="bg-admin-accent/20 text-admin-accent p-3 rounded-full">
                            <Icon className="w-8 h-8" />
                        </div>
                        <div>
                            <p className="text-sm font-medium text-admin-text-secondary">{title}</p>
                            <p className="text-3xl font-bold text-admin-text-primary">{value}</p>
                        </div>
                    </div>
                );

                const QuickActionButton = ({ label, icon: Icon, onClick }) => (
                    <button onClick={onClick} className="w-full bg-admin-sidebar p-4 rounded-lg shadow-md border border-admin-border flex items-center justify-center gap-3 hover:bg-admin-accent/10 hover:border-admin-accent transition-colors">
                        <Icon className="w-6 h-6 text-admin-accent" />
                        <span className="font-semibold text-admin-text-primary">{label}</span>
                    </button>
                );

                return (
                    <div className="space-y-8 animate-fade-in">
                        <h1 className="text-3xl font-bold">{TRANSLATIONS.dashboard}</h1>
                        <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
                            <StatCard title={TRANSLATIONS.totalBrands} value={stats.brands} icon={TagIcon} />
                            <StatCard title={TRANSLATIONS.totalCategories} value={stats.categories} icon={Squares2X2Icon} />
                            <StatCard title={TRANSLATIONS.totalProducts} value={stats.products} icon={CubeIcon} />
                        </div>
                        <div>
                            <h2 className="text-2xl font-bold mb-4">{TRANSLATIONS.quickActions}</h2>
                            <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
                                <QuickActionButton label={TRANSLATIONS.addProduct} icon={PlusIcon} onClick={() => setAdminView('products')} />
                                <QuickActionButton label={TRANSLATIONS.addBrand} icon={PlusIcon} onClick={() => setAdminView('brands')} />
                                <QuickActionButton label={TRANSLATIONS.addCategory} icon={PlusIcon} onClick={() => setAdminView('categories')} />
                            </div>
                        </div>
                    </div>
                );
            }

            function ProductManagementTable({ openModal, openConfirm, handleDelete, lang }) {
                const [products, setProducts] = useState([]);
                const [allBrands, setAllBrands] = useState([]);
                const [allCategories, setAllCategories] = useState([]);
                const [searchTerm, setSearchTerm] = useState('');
                const [isLoading, setIsLoading] = useState(true);

                const fetchData = useCallback(async () => {
                    setIsLoading(true);
                    if (window.PRELOADED_DATA_PROMISE) {
                        try { await window.PRELOADED_DATA_PROMISE; } catch(e) { console.warn('PRELOADED_DATA_PROMISE error', e); }
                    }
                    const [p, b, c] = await Promise.all([
                        dbGetAll(STORES.PRODUCTS),
                        dbGetAll(STORES.BRANDS),
                        dbGetAll(STORES.CATEGORIES),
                    ]);
                    // Apply conservative cleanup: only clean Persian names for display,
                    // keep English names as-is so imported EN titles remain visible.
                    const sanitizedProducts = p.map(orig => {
                        const item = { ...orig };
                        try {
                            if (item.name && item.name.fa) item.name.fa = cleanProductName(item.name.fa);
                        } catch (e) {
                            // ignore cleaning errors
                        }
                        return item;
                    });
                    // Preserve insertion sequence where possible
                    sanitizedProducts.sort((a, b) => (Number(a.createdAt) || 0) - (Number(b.createdAt) || 0));
                    setProducts(sanitizedProducts);
                    setAllBrands(b);
                    setAllCategories(c);
                    setIsLoading(false);
                }, []);

                useEffect(() => {
                    fetchData();
                }, [fetchData]);

                const brandMap = useMemo(() => new Map(allBrands.map(b => [b.id, b])), [allBrands]);
                const categoryMap = useMemo(() => new Map(allCategories.map(c => [c.id, c])), [allCategories]);

                const filteredProducts = useMemo(() => {
                    if (!searchTerm) return products;
                    const lowercasedTerm = searchTerm.toLowerCase();
                    return products.filter(p => {
                        const brand = brandMap.get(p.brandId);
                        const category = categoryMap.get(p.categoryId);
                        return (
                            p.name?.en?.toLowerCase().includes(lowercasedTerm) ||
                            p.name?.fa?.toLowerCase().includes(lowercasedTerm) ||
                            p.id.toLowerCase().includes(lowercasedTerm) ||
                            brand?.name?.en?.toLowerCase().includes(lowercasedTerm) ||
                            brand?.name?.fa?.toLowerCase().includes(lowercasedTerm) ||
                            category?.name?.en?.toLowerCase().includes(lowercasedTerm) ||
                            category?.name?.fa?.toLowerCase().includes(lowercasedTerm)
                        );
                    });
                }, [products, searchTerm, brandMap, categoryMap]);

                const handleOpenModal = (type, mode, item, context) => {
                    openModal(type, mode, item, context, fetchData);
                };

                return (
                    <div className="space-y-6 animate-fade-in">
                        <div className="flex justify-between items-center">
                            <h1 className="text-3xl font-bold">{TRANSLATIONS.manageProducts}</h1>
                            <button onClick={() => handleOpenModal('product', 'add', { id: generateId(), name: { en: '', fa: '' }, description: { en: '', fa: '' }, price: 0, currency: '€', quantity: 0, images: [] }, {})} className="flex items-center gap-2 px-4 py-2 bg-admin-accent text-white rounded-md hover:opacity-90 font-semibold transition-opacity">
                                <PlusIcon className="w-5 h-5" />
                                {TRANSLATIONS.addProduct}
                            </button>
                        </div>
                        <div className="bg-admin-sidebar p-4 rounded-lg shadow-md border border-admin-border">
                            <input
                                type="text"
                                placeholder={TRANSLATIONS.searchProducts}
                                value={searchTerm}
                                onChange={e => setSearchTerm(e.target.value)}
                                className="w-full bg-admin-bg p-2 rounded-md border border-admin-border focus:ring-2 focus:ring-admin-accent focus:outline-none"
                            />
                        </div>
                        <div className="bg-admin-sidebar rounded-lg shadow-md border border-admin-border overflow-x-auto">
                            <table className="w-full text-sm text-left">
                                <thead className="bg-admin-bg border-b border-admin-border">
                                    <tr>
                                        <th className="p-4">{TRANSLATIONS.productTableId}</th>
                                        <th className="p-4">{TRANSLATIONS.productTableName}</th>
                                        <th className="p-4">{TRANSLATIONS.productTableBrand}</th>
                                        <th className="p-4">{TRANSLATIONS.productTableCategory}</th>
                                        <th className="p-4">{TRANSLATIONS.productTablePrice}</th>
                                        <th className="p-4">{TRANSLATIONS.productTableQuantity}</th>
                                        <th className="p-4">{TRANSLATIONS.productTableActions}</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    {isLoading ? (
                                        <tr><td colSpan="7" className="text-center p-8 text-admin-text-secondary">Loading products...</td></tr>
                                    ) : filteredProducts.length === 0 ? (
                                        <tr><td colSpan="7" className="text-center p-8 text-admin-text-secondary">{TRANSLATIONS.noProductsFoundInPanel}</td></tr>
                                    ) : (
                                        filteredProducts.map(product => (
                                            <tr key={product.id} className="border-b border-admin-border hover:bg-admin-bg/50">
                                                <td className="p-4 font-mono text-xs">{product.id.substring(3, 11)}</td>
                                                <td className="p-4 font-semibold">
                                                    {(() => {
                                                        const title = getLocalizedTitle(product.name, lang, product.id.substring(0,8));
                                                        return title || product.id.substring(0,8);
                                                    })()}
                                                </td>
                                                <td className="p-4">{getLocalizedTitle(brandMap.get(product.brandId)?.name, lang)}</td>
                                                <td className="p-4">{getLocalizedTitle(categoryMap.get(product.categoryId)?.name, lang)}</td>
                                                <td className="p-4">{formatPrice(product.price, product.currency, lang)}</td>
                                                <td className="p-4">{product.quantity > 0 ? product.quantity : ''}</td>
                                                <td className="p-4 flex gap-2">
                                                    <button
                                                        onClick={() => handleOpenModal('product', 'edit', product, { brandId: product.brandId, categoryId: product.categoryId })}
                                                        className="p-1.5 text-admin-accent hover:bg-admin-accent/10 rounded-md"
                                                    ><PencilIcon className="w-4 h-4" /></button>
                                                    <button
                                                        onClick={() => openConfirm({
                                                            title: `${TRANSLATIONS.delete} "${getLocalizedTitle(product.name, lang, TRANSLATIONS.untitled)}"`,
                                                            message: TRANSLATIONS.confirmDelete,
                                                            confirmText: TRANSLATIONS.confirmDeleteAction,
                                                            confirmClass: 'bg-red-600 hover:bg-red-500',
                                                            onConfirm: () => handleDelete('product', { productId: product.id }).then(fetchData)
                                                        })}
                                                        className="p-1.5 text-red-500 hover:bg-red-500/10 rounded-md"
                                                    ><TrashIcon className="w-4 h-4" /></button>
                                                </td>
                                            </tr>
                                        ))
                                    )}
                                </tbody>
                            </table>
                        </div>
                    </div>
                );
            }

            function ManagementListView({ type, title, openModal, openConfirm, handleDelete, lang }) {
                const [items, setItems] = useState([]);
                const [isLoading, setIsLoading] = useState(true);

                const storeName = type === 'brand' ? STORES.BRANDS : STORES.CATEGORIES;
                const addText = type === 'brand' ? TRANSLATIONS.addBrand : TRANSLATIONS.addCategory;

                const fetchData = useCallback(async () => {
                    setIsLoading(true);
                    const data = await dbGetAll(storeName);
                    setItems(data);
                    setIsLoading(false);
                }, [storeName]);

                useEffect(() => {
                    fetchData();
                }, [fetchData]);

                const handleOpenModal = (type, mode, item, context) => {
                    openModal(type, mode, item, context, fetchData);
                };

                return (
                    <div className="space-y-6 animate-fade-in">
                        <div className="flex justify-between items-center">
                            <h1 className="text-3xl font-bold">{title}</h1>
                            <button onClick={() => handleOpenModal(type, 'add', { id: generateId(), name: { en: '', fa: '' } }, {})} className="flex items-center gap-2 px-4 py-2 bg-admin-accent text-white rounded-md hover:opacity-90 font-semibold transition-opacity">
                                <PlusIcon className="w-5 h-5" />
                                {addText}
                            </button>
                        </div>

                        <div className="bg-admin-sidebar rounded-lg shadow-md border border-admin-border">
                            {isLoading ? (
                                <div className="p-8 text-center text-admin-text-secondary">Loading...</div>
                            ) : items.length === 0 ? (
                                <div className="p-8 text-center text-admin-text-secondary">No items found.</div>
                            ) : (
                                <ul className="divide-y divide-admin-border">
                                    {items.map(item => (
                                        <li key={item.id} className="p-4 flex justify-between items-center hover:bg-admin-bg/50">
                                            <div className="flex items-center gap-4">
                                                {item.logo && <img src={item.logo} className="w-10 h-10 object-contain rounded-md" />}
                                                <span className="font-semibold">{getLocalizedTitle(item.name, lang)}</span>
                                            </div>
                                            <div className="flex gap-2">
                                                <button
                                                    onClick={() => handleOpenModal(type, 'edit', item, { brandId: item.id })}
                                                    className="p-1.5 text-admin-accent hover:bg-admin-accent/10 rounded-md"
                                                ><PencilIcon className="w-4 h-4" /></button>
                                                <button
                                                    onClick={() => openConfirm({
                                                        title: `${TRANSLATIONS.delete} "${getLocalizedTitle(item.name, lang, TRANSLATIONS.untitled)}"`,
                                                        message: TRANSLATIONS.confirmDelete,
                                                        confirmText: TRANSLATIONS.confirmDeleteAction,
                                                        confirmClass: 'bg-red-600 hover:bg-red-500',
                                                        onConfirm: () => handleDelete(type, { [`${type}Id`]: item.id }).then(fetchData)
                                                    })}
                                                    className="p-1.5 text-red-500 hover:bg-red-500/10 rounded-md"
                                                ><TrashIcon className="w-4 h-4" /></button>
                                            </div>
                                        </li>
                                    ))}
                                </ul>
                            )}
                        </div>
                    </div>
                );
            }

            const BrandManagementView = (props) => <ManagementListView type="brand" title={TRANSLATIONS.manageBrands} {...props} />;
            const CategoryManagementView = (props) => <ManagementListView type="category" title={TRANSLATIONS.manageCategories} {...props} />;

            function SettingsView({
                handleWipeAllData, openConfirm, setIsWelcomeSettingsOpen, setIsFooterSettingsOpen,
                setIsApiKeyModalOpen, handleImport, handleExport, handleImportFromExcel, handleExportToExcel,
                isImporting, isExportingExcel, addToast
            }) {

                const SettingCard = ({ title, description, buttonText, onClick, isDanger = false, disabled = false }) => (
                    <div className="bg-admin-sidebar p-4 rounded-lg shadow-md border border-admin-border flex justify-between items-center">
                        <div>
                            <h3 className="font-bold text-admin-text-primary">{title}</h3>
                            <p className="text-sm text-admin-text-secondary">{description}</p>
                        </div>
                        <button
                            onClick={onClick}
                            disabled={disabled}
                            className={`px-4 py-2 rounded-md font-semibold transition-colors disabled:opacity-50 disabled:cursor-not-allowed ${isDanger
                                ? 'bg-red-600 text-white hover:bg-red-500'
                                : 'bg-admin-accent text-white hover:opacity-90'
                                }`}
                        >{buttonText}</button>
                    </div>
                );

                const handleWipeClick = () => {
                    openConfirm({
                        title: TRANSLATIONS.wipeAllData,
                        message: TRANSLATIONS.wipeAllDataConfirm,
                        confirmText: TRANSLATIONS.wipeAllDataAction,
                        confirmClass: 'bg-red-600 hover:bg-red-500',
                        onConfirm: handleWipeAllData
                    });
                };

                // local state for report options
                const [reportIncludeBodies, setReportIncludeBodies] = React.useState(window.__REPORT_INCLUDE_BODIES ?? true);
                const [reportBodyLimit, setReportBodyLimit] = React.useState(window.__REPORT_BODY_SIZE_LIMIT ?? (2 * 1024 * 1024));

                // ----------------- Service Worker / Browser backup helpers (in Settings scope) -----------------
                // Safe helper to send a message to the Service Worker and wait for a response.
                // Uses `navigator.serviceWorker.ready` and falls back to `registration.active`.
                async function sendMessageToSWAndWait(msg, expectedTypes = ['RUNTIME_STATS', 'CLEAN_OLD_CACHES_DONE'], timeout = 3000) {
                    if (!('serviceWorker' in navigator)) return { error: 'no-sw' };
                    try {
                        const registration = await navigator.serviceWorker.ready.catch(() => null);
                        const target = navigator.serviceWorker.controller || (registration && registration.active);
                        if (!target) return { error: 'no-controller' };

                        return await new Promise((resolve) => {
                            const onMsg = (ev) => {
                                if (ev.data && expectedTypes.includes(ev.data.type)) {
                                    navigator.serviceWorker.removeEventListener('message', onMsg);
                                    resolve(ev.data);
                                }
                            };
                            navigator.serviceWorker.addEventListener('message', onMsg);
                            try { target.postMessage(msg); } catch (e) { navigator.serviceWorker.removeEventListener('message', onMsg); resolve({ error: String(e) }); }
                            setTimeout(() => {
                                navigator.serviceWorker.removeEventListener('message', onMsg);
                                resolve({ timeout: true });
                            }, timeout);
                        });
                    } catch (e) {
                        return { error: String(e) };
                    }
                }
                const handleRequestSwStats = async () => {
                    try {
                        const res = await sendMessageToSWAndWait({ type: 'LOG_STATS' }, ['RUNTIME_STATS'], 3000);
                        if (res && res.count !== undefined) {
                            addToast('SW Runtime entries: ' + res.count, 'info');
                        } else if (res && res.timeout) {
                            addToast('SW did not respond in time.', 'warning');
                        } else if (res && res.error === 'no-sw') {
                            addToast('No Service Worker available in this browser.', 'error');
                        } else if (res && res.error === 'no-controller') {
                            addToast('Service Worker not controlling this page yet. Try reloading.', 'warning');
                        } else if (res && res.error) {
                            addToast('SW error: ' + res.error, 'error');
                        } else {
                            addToast('SW stats not available.', 'error');
                        }
                    } catch (e) {
                        console.error('requestSwStats error', e);
                        addToast('Failed to request SW stats: ' + (e.message || e), 'error');
                    }
                };

                const handleCleanOldCaches = async () => {
                    try {
                        const ok = confirm('This will delete old Cache Storage entries (not IndexedDB). Proceed?');
                        if (!ok) return;
                        const res = await sendMessageToSWAndWait({ type: 'CLEAN_OLD_CACHES' }, ['CLEAN_OLD_CACHES_DONE'], 5000);
                        if (res && res.timeout) {
                            addToast('SW did not acknowledge cache cleanup in time.', 'warning');
                        } else if (res && res.error === 'no-sw') {
                            addToast('No Service Worker available in this browser.', 'error');
                        } else if (res && res.error === 'no-controller') {
                            addToast('Service Worker not controlling this page yet. Try reloading.', 'warning');
                        } else if (res && res.deleted) {
                            addToast('SW cleaned old caches: ' + (res.deleted.join(', ') || '(none)'), 'success');
                        } else {
                            addToast('Requested SW to clean old caches. Check console for progress.', 'info');
                        }
                    } catch (e) {
                        console.error('cleanOldCaches error', e);
                        addToast('Failed to request cache cleanup: ' + (e.message || e), 'error');
                    }
                };

                const handleExportBrowserBackup = async () => {
                    try {
                        addToast('Preparing browser backup (cache metadata + IndexedDB)...', 'info');
                        const out = { cacheNames: [], caches: {}, indexedDB: {} };
                        try {
                            const keys = await caches.keys();
                            out.cacheNames = keys;
                            for (const k of keys) {
                                try {
                                    const c = await caches.open(k);
                                    const reqs = await c.keys();
                                    out.caches[k] = reqs.map(r => r.url).slice(0, 1000); // limit entries to avoid huge files
                                } catch (e) {
                                    out.caches[k] = { error: String(e) };
                                }
                            }
                        } catch (e) {
                            out.cachesError = String(e);
                        }

                        // Export IndexedDB stores used by the app
                        try {
                            const brands = await dbGetAll(STORES.BRANDS);
                            const categories = await dbGetAll(STORES.CATEGORIES);
                            const products = await dbGetAll(STORES.PRODUCTS);
                            const configItems = await dbGetAll(STORES.CONFIG);
                            out.indexedDB = { brands, categories, products, config: configItems };
                        } catch (e) {
                            out.indexedDBError = String(e);
                        }

                        // Try to embed hero media (if configured) into this browser backup for easier debugging/sharing
                        try {
                            const cfg = (out.indexedDB && out.indexedDB.config) || [];
                            const heroItem = cfg.find(it => it && it.key === 'hero_media_block');
                            if (heroItem && heroItem.value && heroItem.value.mediaUrl) {
                                let heroUrl = heroItem.value.mediaUrl;
                                if (typeof heroUrl !== 'string') heroUrl = String(heroUrl || '');
                                heroUrl = heroUrl.trim();
                                // Skip empty or literal "null" strings that may come from imported backups
                                if (!heroUrl || heroUrl.toLowerCase() === 'null') {
                                    console.warn('Skipping invalid hero media URL:', heroUrl);
                                } else {
                                const MAX_EMBED_BYTES = 12 * 1024 * 1024; // 12MB

                                const readBufferToDataUrl = (buf, srcUrl) => {
                                    if (!buf) return null;
                                    if (buf.byteLength > MAX_EMBED_BYTES) return null;
                                    let binary = '';
                                    const bytes = new Uint8Array(buf);
                                    const chunkSize = 0x8000;
                                    for (let i = 0; i < bytes.length; i += chunkSize) {
                                        binary += String.fromCharCode.apply(null, bytes.subarray(i, i + chunkSize));
                                    }
                                    const b64 = btoa(binary);
                                    const ext = (srcUrl.split('.').pop() || '').toLowerCase();
                                    const mime = ext === 'mp4' ? 'video/mp4' : ext === 'webm' ? 'video/webm' : 'application/octet-stream';
                                    return `data:${mime};base64,${b64}`;
                                };

                                const tryFetch = async (u, options = {}) => {
                                    try {
                                        const resp = await fetch(u, options);
                                        if (!resp || !resp.ok) return null;
                                        const buf = await resp.arrayBuffer();
                                        return readBufferToDataUrl(buf, u);
                                    } catch (e) {
                                        return null;
                                    }
                                };

                                // build candidates
                                const candidates = [heroUrl];
                                try {
                                    if (heroUrl.startsWith('/')) candidates.push(window.location.origin + heroUrl);
                                    const resolved = new URL(heroUrl, window.location.href).href;
                                    if (!candidates.includes(resolved)) candidates.push(resolved);
                                } catch (e) { /* ignore */ }
                                if (heroUrl.includes('uploaded_media') && !heroUrl.startsWith('/')) {
                                    const withOrigin = window.location.origin + (heroUrl.startsWith('.') ? heroUrl.slice(1) : '/' + heroUrl);
                                    candidates.push(withOrigin);
                                }

                                let dataUrl = null;
                                for (const c of candidates) {
                                    dataUrl = await tryFetch(c, { cache: 'no-store' });
                                    if (dataUrl) break;
                                }

                                if (dataUrl) {
                                    out._embedded_media = out._embedded_media || {};
                                    out._embedded_media.hero_video = { src: heroUrl, dataUrl };
                                    addToast('Included hero video in browser backup (debug).', 'info');
                                } else {
                                    console.warn('Could not fetch hero media for embedding. Tried:', candidates);
                                }
                                }
                            }
                        } catch (e) {
                            console.warn('Embedding hero media into browser backup failed', e);
                        }

                        const blob = new Blob([JSON.stringify(out, null, 2)], { type: 'application/json' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        const filename = `browser_backup_${new Date().toISOString().replace(/[:.]/g, '-')}.json`;
                        a.href = url;
                        a.download = filename;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                        addToast('Browser backup downloaded.', 'success');
                    } catch (e) {
                        console.error('exportBrowserBackup error', e);
                        addToast('Failed to create browser backup: ' + (e.message || e), 'error');
                    }
                };

                const unregisterServiceWorkersAndClearCaches = async () => {
                    try {
                        if (!('serviceWorker' in navigator)) {
                            addToast('Service Worker not supported in this browser.', 'warning');
                            return { error: 'no-sw' };
                        }
                        const regs = await navigator.serviceWorker.getRegistrations();
                        if (!regs || !regs.length) {
                            addToast('No Service Worker registrations found.', 'info');
                        }
                        const results = [];
                        for (const r of regs) {
                            try {
                                const ok = await r.unregister();
                                results.push({ scope: r.scope, unregistered: !!ok });
                            } catch (e) {
                                results.push({ scope: r.scope, error: String(e) });
                            }
                        }
                        // Attempt to clear caches used by the site (non-destructive best-effort)
                        let deleted = [];
                        if (window.caches && caches.keys) {
                            try {
                                const keys = await caches.keys();
                                for (const k of keys) {
                                    try {
                                        const ok = await caches.delete(k);
                                        if (ok) deleted.push(k);
                                    } catch (e) {
                                        // ignore per-cache errors
                                    }
                                }
                            } catch (e) {
                                console.warn('Failed listing caches', e);
                            }
                        }
                        addToast('Service Workers unregistered and caches cleared.', 'success');
                        console.log('unregister results', results, 'deleted caches', deleted);
                        return { deleted };
                    } catch (e) {
                        console.error('unregisterServiceWorkersAndClearCaches failed', e);
                        addToast('Failed to unregister SW or clear caches: ' + (e.message || e), 'error');
                        return { error: String(e) };
                    }
                };

                const handleDownloadBugReport = async () => {
                    try {
                        addToast('Collecting detailed bug report...', 'info');
                        if (window.__generateDetailedReport) {
                            const report = await window.__generateDetailedReport({ includeBodies: reportIncludeBodies, bodyLimit: reportBodyLimit });
                            try {
                                const blob = new Blob([JSON.stringify(report, null, 2)], { type: 'application/json' });
                                const url = URL.createObjectURL(blob);
                                const a = document.createElement('a');
                                a.href = url;
                                a.download = `detailed_bug_report_${new Date().toISOString().replace(/[:.]/g, '-')}.json`;
                                document.body.appendChild(a);
                                a.click();
                                document.body.removeChild(a);
                                URL.revokeObjectURL(url);
                                addToast('Detailed bug report downloaded.', 'success');
                            } catch (e) { console.error('download final error', e); addToast('Failed to generate final report: ' + (e.message || e), 'error'); }
                        } else {
                            addToast('Detailed report generator not available.', 'error');
                        }
                    } catch (e) {
                        console.error('downloadBugReport error', e);
                        addToast('Failed to generate bug report: ' + (e.message || e), 'error');
                    }
                };

                return (
                    <div className="space-y-8 animate-fade-in max-w-4xl mx-auto">
                        <h1 className="text-3xl font-bold">{TRANSLATIONS.appSettings}</h1>
                        {/* Container for file:// protocol banner (so it appears inside Settings, not over hero) */}
                        <div id="file-protocol-area" />

                        <div className="space-y-4">
                            <h2 className="text-xl font-semibold text-admin-text-secondary border-b border-admin-border pb-2">Customization</h2>
                            <SettingCard title={TRANSLATIONS.welcomeSettings} description="Manage photos and video for the welcome screen." buttonText={TRANSLATIONS.edit} onClick={() => setIsWelcomeSettingsOpen(true)} />
                            <SettingCard title={TRANSLATIONS.footerSettings} description="Manage address, contacts, and logo for the footer." buttonText={TRANSLATIONS.edit} onClick={() => setIsFooterSettingsOpen(true)} />
                        </div>

                        <div className="space-y-4">
                            <h2 className="text-xl font-semibold text-admin-text-secondary border-b border-admin-border pb-2">Data Management</h2>
                            <SettingCard title={TRANSLATIONS.importData} description="Import a full catalog backup (.json)." buttonText={TRANSLATIONS.import} onClick={handleImport} disabled={isImporting} />
                            <SettingCard title={TRANSLATIONS.exportData} description="Export a full catalog backup (.json)." buttonText={TRANSLATIONS.export} onClick={handleExport} />
                            <SettingCard title={TRANSLATIONS.importFromExcel} description="Update products from an Excel file." buttonText={TRANSLATIONS.import} onClick={handleImportFromExcel} disabled={isImporting} />
                            <SettingCard
                                title={TRANSLATIONS.exportToExcel}
                                description="Export all products to an Excel file (.xlsx)."
                                buttonText={isExportingExcel ? TRANSLATIONS.exporting : TRANSLATIONS.exportToExcel}
                                onClick={handleExportToExcel}
                                disabled={isExportingExcel}
                            />
                            {/* Service Worker & Debug tools */}
                            <div className="mt-4 p-4 rounded border border-admin-border bg-admin-sidebar">
                                <h3 className="font-semibold mb-2">Service Worker & Debug</h3>
                                <div className="grid grid-cols-1 sm:grid-cols-2 gap-3">
                                    <div className="flex gap-2">
                                        <button className="px-3 py-2 bg-blue-600 text-white rounded" onClick={() => handleExportBrowserBackup()}>Export Browser Backup</button>
                                        <button className="px-3 py-2 bg-yellow-600 text-white rounded" onClick={async () => { await unregisterServiceWorkersAndClearCaches(); addToast('You can now refresh the page and re-run Export.', 'info'); }}>Unregister SW & Clear Caches</button>
                                    </div>
                                    <button className="px-3 py-2 bg-yellow-600 text-white rounded" onClick={() => handleRequestSwStats()}>Get SW Stats</button>
                                    <button className="px-3 py-2 bg-red-600 text-white rounded" onClick={() => handleCleanOldCaches()}>Clear Old Caches</button>
                                    <button className="px-3 py-2 bg-slate-700 text-white rounded" onClick={() => handleDownloadBugReport()}>Download Bug Report</button>
                                </div>
                                <div className="mt-3 flex items-center gap-3">
                                    <label className="flex items-center gap-2 text-sm">
                                        <input type="checkbox" checked={reportIncludeBodies} onChange={(e) => { setReportIncludeBodies(e.target.checked); window.__REPORT_INCLUDE_BODIES = e.target.checked; }} />
                                        <span>Include response bodies</span>
                                    </label>
                                    <label className="flex items-center gap-2 text-sm">
                                        <span>Body size limit (bytes):</span>
                                        <input type="number" value={reportBodyLimit} onChange={(e) => { const v = parseInt(e.target.value || '0', 10); setReportBodyLimit(v); window.__REPORT_BODY_SIZE_LIMIT = v; }} className="w-32 px-2 py-1 rounded bg-admin-input" />
                                    </label>
                                </div>
                                <p className="text-sm text-admin-text-secondary mt-2">Export includes cache metadata and IndexedDB content (no server files deleted). Clear Old Caches removes only cache storage (not IndexedDB).</p>
                            </div>
                        </div>

                        <div className="space-y-4">
                            <h2 className="text-xl font-semibold text-admin-text-secondary border-b border-admin-border pb-2">AI Settings</h2>
                            <SettingCard title={TRANSLATIONS.setApiKey} description="Set your Google AI Studio API Key for AI features." buttonText={TRANSLATIONS.setApiKey} onClick={() => setIsApiKeyModalOpen(true)} />
                        </div>

                        <div className="space-y-4 pt-4">
                            <h2 className="text-xl font-semibold text-red-500 border-b border-red-500/30 pb-2">{TRANSLATIONS.dangerZone}</h2>
                            <SettingCard
                                title={TRANSLATIONS.wipeAllData}
                                description="Permanently delete all catalog data and reset the app."
                                buttonText={TRANSLATIONS.wipeAllData}
                                onClick={handleWipeClick}
                                isDanger
                            />
                        </div>
                    </div>
                );
            }

            function ControlPanel({
                setView, openModal, openConfirm, addToast, handleDelete, handleWipeAllData,
                setIsWelcomeSettingsOpen, setIsApiKeyModalOpen, setIsFooterSettingsOpen,
                handleImport, handleExport, handleImportFromExcel, handleExportToExcel, isExportingExcel, isImporting, lang
            }) {
                const [adminView, setAdminView] = useState('overview');

                const contentProps = {
                    openModal,
                    openConfirm,
                    addToast,
                    handleDelete,
                    lang,
                    // For settings

                    handleWipeAllData, setIsWelcomeSettingsOpen, setIsApiKeyModalOpen, setIsFooterSettingsOpen,
                    handleImport, handleExport, handleImportFromExcel, handleExportToExcel, isExportingExcel, isImporting
                };

                return (
                    <div className="flex h-screen bg-transparent text-admin-text-primary">
                        <ControlPanelSidebar adminView={adminView} setAdminView={setAdminView} setView={setView} />
                        <main className="flex-1 flex flex-col overflow-hidden">
                            <div className="flex-1 overflow-y-auto overflow-x-hidden p-4 sm:p-6 lg:p-8">
                                {adminView === 'overview' && <DashboardOverview openModal={openModal} setAdminView={setAdminView} />}
                                {adminView === 'products' && <ProductManagementTable {...contentProps} />}
                                {adminView === 'brands' && <BrandManagementView {...contentProps} />}
                                {adminView === 'categories' && <CategoryManagementView {...contentProps} />}
                                {adminView === 'settings' && <SettingsView {...contentProps} />}
                            </div>
                        </main>
                    </div>
                );
            }

            function SearchResultsView({ results, setView, lang, searchTerm }) {
                if (results.length === 0) {
                    return (
                        <div className="text-center py-16">
                            <h2 className="text-2xl font-bold">{TRANSLATIONS.noResultsFound}</h2>
                            <p className="text-slate-500 dark:text-slate-400 mt-2">For search term: "{searchTerm}"</p>
                        </div>
                    );
                }
                return (
                    <div>
                        <h2 className="text-3xl font-bold mb-6">{TRANSLATIONS.searchResultsTitle} ({results.length})</h2>
                        <GridView items={results} type="product" context={{}} setView={setView} lang={lang} isManagementMode={false} handleDelete={() => { }} openConfirm={() => { }} openModal={() => { }} />
                    </div>
                );
            }

            function EntityModal({ isOpen, type, mode, data, context, onSave, onClose, lang, addToast, aiInstance, handleAiFeatureClick }) {
                if (!isOpen) return null;

                const [item, setItem] = useState(data);
                const [isGenerating, setIsGenerating] = useState(false);
                const logoInputRef = useRef(null);
                const historyLogoInputRef = useRef(null);
                const imagesInputRef = useRef(null);
                const isProduct = type === 'product';

                useEffect(() => {
                    // When opening the product modal, prefer to show Persian remarks if English is empty
                    if (isProduct && data) {
                        const initial = { ...data };
                        if ((!initial.remarks || initial.remarks === '') && initial.remarksFa) {
                            initial.remarks = initial.remarksFa;
                        }
                        if ((!initial.remarksFa || initial.remarksFa === '') && initial.remarks) {
                            initial.remarksFa = initial.remarks;
                        }
                        setItem(initial);
                    } else {
                        setItem(data);
                    }
                }, [data]);

                const handleDeepChange = (path, value) => {
                    setItem(prev => {
                        const newState = { ...prev };
                        let current = newState;
                        for (let i = 0; i < path.length - 1; i++) {
                            const key = path[i];
                            current[key] = { ...(current[key] || {}) };
                            current = current[key];
                        }
                        current[path[path.length - 1]] = value;
                        return newState;
                    });
                };

                const handleChange = (field, value, subField = null) => {
                    if (typeof value === 'string') {
                        value = toLatinDigits(value);
                    }
                    if (subField) {
                        setItem(prev => ({ ...prev, [field]: { ...prev[field], [subField]: value } }));
                    } else {
                        setItem(prev => ({ ...prev, [field]: value }));
                    }
                };

                const handleLogoUpload = async (e) => {
                    const file = e.target.files[0];
                    if (!file) return;
                    try {
                        const base64logo = await fileToBase64(file, 200, 200, 0.8);
                        setItem(prev => ({ ...prev, logo: base64logo }));
                    } catch (error) {
                        addToast("Failed to process logo.", 'error');
                    }
                };

                const handleHistoryLogoUpload = async (e) => {
                    const file = e.target.files[0];
                    if (!file) return;
                    try {
                        const base64logo = await fileToBase64(file, 200, 200, 0.8);
                        handleDeepChange(['history', 'logo'], base64logo);
                    } catch (error) {
                        addToast("Failed to process history logo.", 'error');
                    }
                };

                const handleImagesUpload = async (e) => {
                    const files = Array.from(e.target.files);
                    if (files.length === 0) return;

                    addToast(`Processing ${files.length} images...`, 'info');

                    try {
                        const currentImageCount = item.images?.length || 0;
                        const filesToProcess = files.slice(0, 5 - currentImageCount);

                        const base64files = await Promise.all(
                            filesToProcess.map(file => fileToBase64(file).catch(err => {
                                console.error("Image processing error:", err);
                                return null;
                            }))
                        );

                        const successfulUploads = base64files.filter(Boolean);
                        setItem(prev => ({ ...prev, images: [...(prev.images || []), ...successfulUploads].slice(0, 5) }));

                    } catch (error) {
                        addToast("An error occurred during image processing.", 'error');
                    }
                };

                const removeImage = (index) => {
                    setItem(prev => ({ ...prev, images: prev.images.filter((_, i) => i !== index) }));
                };

                const handleGenerateDescription = () => {
                    handleAiFeatureClick(async () => {
                        if (!item.images || item.images.length === 0) {
                            addToast(TRANSLATIONS.aiNeedsImages, 'warning');
                            return;
                        }
                        setIsGenerating(true);
                        try {
                            if (!aiInstance) throw new Error("AI not initialized.");

                            const imagePart = { inlineData: { mimeType: 'image/jpeg', data: item.images[0].split(',')[1] } };
                            const textPart = { text: "Generate a creative, appealing marketing description for this furniture item in both English and Persian (Farsi), with each description being a maximum of 40 words. Provide the response as a JSON object with two keys: 'en' and 'fa'. Do not include any markdown formatting like ```json." };

                            const response = await aiInstance.models.generateContent({
                                model: 'gemini-3-flash-preview',
                                contents: { parts: [imagePart, textPart] },
                            });

                            const responseText = response.text;
                            if (!responseText) throw new Error("Empty response from AI.");

                            const cleanedText = responseText.replace(/```json/g, '').replace(/```/g, '').trim();
                            const jsonResponse = JSON.parse(cleanedText);

                            if (jsonResponse.en && jsonResponse.fa) {
                                handleChange('description', { en: jsonResponse.en, fa: jsonResponse.fa });
                                addToast("Descriptions generated successfully!", "success");
                            } else {
                                throw new Error("AI response did not contain 'en' and 'fa' keys.");
                            }

                        } catch (error) {
                            console.error("AI Description Generation Error:", error);
                            addToast(TRANSLATIONS.aiGenerationError, 'error');
                        } finally {
                            setIsGenerating(false);
                        }
                    });
                };

                const handleSave = () => {
                    onSave(type, item, context);
                };

                const title = `${mode === 'add' ? TRANSLATIONS.add : TRANSLATIONS.edit} ${type.charAt(0).toUpperCase() + type.slice(1)}`;

                return (
                    <div className="fixed inset-0 bg-black/70 backdrop-blur-sm flex items-start justify-center z-50 p-4 pt-16 sm:pt-24" onClick={onClose}>
                        <div className="bg-white dark:bg-slate-800/80 backdrop-blur-xl ring-1 dark:ring-white/10 rounded-lg shadow-2xl w-full max-w-2xl max-h-[80vh] flex flex-col animate-slide-up text-slate-800 dark:text-slate-200" onClick={e => e.stopPropagation()}>
                            <header className="p-4 border-b border-slate-200 dark:border-slate-700 flex justify-between items-center flex-shrink-0">
                                <h2 className="text-xl font-bold text-blue-600 dark:text-blue-400">{title}</h2>
                                <button onClick={onClose} className="text-slate-500 dark:text-slate-400 hover:text-slate-800 dark:hover:text-white"><XMarkIcon /></button>
                            </header>
                            <div className="p-6 space-y-4 overflow-y-auto">
                                {/* Common Fields */}
                                <div>
                                    <label className="block text-sm font-medium mb-1">{TRANSLATIONS[`${type}NameEn`]}</label>
                                    <input type="text" value={item.name?.en || ''} onChange={e => handleChange('name', e.target.value, 'en')} className="w-full bg-slate-100 dark:bg-slate-900/80 rounded-md p-2 ring-1 ring-slate-300 dark:ring-slate-700 focus:ring-blue-500 focus:outline-none" />
                                </div>
                                <div>
                                    <label className="block text-sm font-medium mb-1 font-vazir">{TRANSLATIONS[`${type}NameFa`]}</label>
                                    <input
                                        type="text"
                                        value={item.name?.fa || ''}
                                        onChange={e => {
                                            // نمی‌پاکی‌کنیم، فقط نگاه‌داری می‌کنیم - پاکی‌کنی در ذخیره‌سازی انجام میشود
                                            handleChange('name', e.target.value, 'fa');
                                        }}
                                        className="w-full bg-slate-100 dark:bg-slate-900/80 rounded-md p-2 ring-1 ring-slate-300 dark:ring-slate-700 focus:ring-blue-500 focus:outline-none font-vazir text-right"
                                        dir="rtl"
                                    />
                                </div>

                                {/* Brand Specific */}
                                {type === 'brand' && (
                                    <>
                                        <div>
                                            <label className="block text-sm font-medium mb-1">{TRANSLATIONS.brandLogo}</label>
                                            <div className="flex items-center gap-4">
                                                {item.logo && <img src={item.logo} className="w-20 h-20 object-contain rounded-md bg-slate-200 dark:bg-slate-700 p-1" />}
                                                <input type="file" ref={logoInputRef} accept="image/jpeg, image/png, image/webp, image/svg+xml" onChange={handleLogoUpload} className="hidden" />
                                                <button type="button" onClick={() => logoInputRef.current?.click()} className="px-4 py-2 bg-slate-200 dark:bg-slate-600 rounded-md hover:bg-slate-300 dark:hover:bg-slate-500 font-semibold transition-colors cursor-pointer">{TRANSLATIONS.uploadLogo}</button>
                                                {item.logo && <button type="button" onClick={() => handleChange('logo', null)} className="px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-500 font-semibold transition-colors">Delete</button>}
                                            </div>
                                        </div>
                                        <hr className="border-slate-200 dark:border-slate-700" />
                                        <h3 className="text-lg font-bold text-slate-700 dark:text-slate-300">Brand History Section</h3>
                                        <div>
                                            <label className="block text-sm font-medium mb-1">{TRANSLATIONS.brandHistoryLogo}</label>
                                            <div className="flex items-center gap-4">
                                                {item.history?.logo && <img src={item.history.logo} className="w-20 h-20 object-contain rounded-md bg-slate-200 dark:bg-slate-700 p-1" />}
                                                <input type="file" ref={historyLogoInputRef} accept="image/jpeg, image/png, image/webp, image/svg+xml" onChange={handleHistoryLogoUpload} className="hidden" />
                                                <button type="button" onClick={() => historyLogoInputRef.current?.click()} className="px-4 py-2 bg-slate-200 dark:bg-slate-600 rounded-md hover:bg-slate-300 dark:hover:bg-slate-500 font-semibold transition-colors cursor-pointer">{TRANSLATIONS.uploadLogo}</button>
                                                {item.history?.logo && <button type="button" onClick={() => handleDeepChange(['history', 'logo'], null)} className="px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-500 font-semibold transition-colors">Delete</button>}
                                            </div>
                                        </div>
                                        <div>
                                            <label className="block text-sm font-medium mb-1">{TRANSLATIONS.brandHistoryTextEn}</label>
                                            <textarea value={item.history?.text?.en || ''} onChange={e => handleDeepChange(['history', 'text', 'en'], e.target.value)} rows="5" className="w-full bg-slate-100 dark:bg-slate-900/80 rounded-md p-2 ring-1 ring-slate-300 dark:ring-slate-700 focus:ring-blue-500 focus:outline-none"></textarea>
                                        </div>
                                        <div>
                                            <label className="block text-sm font-medium font-vazir">{TRANSLATIONS.brandHistoryTextFa}</label>
                                            <textarea value={item.history?.text?.fa || ''} onChange={e => handleDeepChange(['history', 'text', 'fa'], e.target.value)} rows="5" className="w-full bg-slate-100 dark:bg-slate-900/80 rounded-md p-2 ring-1 ring-slate-300 dark:ring-slate-700 focus:ring-blue-500 focus:outline-none font-vazir text-right" dir="rtl"></textarea>
                                        </div>
                                    </>
                                )}

                                {/* Product Specific */}
                                {isProduct && (
                                    <>
                                        <hr className="border-slate-200 dark:border-slate-700" />
                                        <div>
                                            <label className="block text-sm font-medium mb-1">{TRANSLATIONS.images}</label>
                                            <div className="grid grid-cols-3 sm:grid-cols-4 md:grid-cols-5 gap-2">
                                                {(item.images || []).map((img, index) => (
                                                    <div key={index} className="relative group aspect-square">
                                                        <img src={img} className="w-full h-full object-cover rounded-md bg-slate-200 dark:bg-slate-700" />
                                                        <div className="absolute inset-0 bg-black/50 opacity-0 group-hover:opacity-100 transition-opacity flex items-center justify-center">
                                                            <button onClick={() => removeImage(index)} className="p-2 bg-red-600/80 rounded-full text-white hover:bg-red-500"><TrashIcon className="w-5 h-5" /></button>
                                                        </div>
                                                    </div>
                                                ))}
                                                {(!item.images || item.images.length < 5) && (
                                                    <button onClick={() => imagesInputRef.current?.click()} className="aspect-square flex flex-col items-center justify-center bg-slate-100 dark:bg-slate-900/50 border-2 border-dashed border-slate-300 dark:border-slate-600 rounded-lg cursor-pointer hover:bg-slate-200 dark:hover:bg-slate-700/60 hover:border-blue-500 text-slate-500 dark:text-slate-400">
                                                        <PlusIcon className="w-8 h-8" />
                                                        <span className="text-xs mt-1 text-center">{TRANSLATIONS.uploadImages}</span>
                                                    </button>
                                                )}
                                            </div>
                                            <input ref={imagesInputRef} type="file" accept="image/jpeg, image/png, image/webp" multiple className="hidden" onChange={handleImagesUpload} />
                                        </div>

                                        <hr className="border-slate-200 dark:border-slate-700" />

                                        <div className="flex items-end gap-2">
                                            <div className="flex-grow">
                                                <label className="block text-sm font-medium mb-1">{TRANSLATIONS.descriptionEn}</label>
                                                <textarea value={item.description?.en || ''} onChange={e => handleChange('description', e.target.value, 'en')} rows="3" className="w-full bg-slate-100 dark:bg-slate-900/80 rounded-md p-2 ring-1 ring-slate-300 dark:ring-slate-700 focus:ring-blue-500 focus:outline-none"></textarea>
                                            </div>
                                            <button onClick={handleGenerateDescription} disabled={isGenerating} className="px-3 py-2 bg-indigo-600 text-white rounded-md hover:bg-indigo-500 font-semibold transition-colors flex items-center gap-2 text-sm disabled:bg-indigo-400 disabled:cursor-wait">
                                                {isGenerating ? TRANSLATIONS.generating : TRANSLATIONS.generateWithAI}
                                            </button>
                                        </div>
                                        <div>
                                            <label className="block text-sm font-medium font-vazir">{TRANSLATIONS.descriptionFa}</label>
                                            <textarea value={item.description?.fa || ''} onChange={e => handleChange('description', e.target.value, 'fa')} rows="3" className="w-full bg-slate-100 dark:bg-slate-900/80 rounded-md p-2 ring-1 ring-slate-300 dark:ring-slate-700 focus:ring-blue-500 focus:outline-none font-vazir text-right" dir="rtl"></textarea>
                                        </div>

                                        <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
                                            <div>
                                                <label className="block text-sm font-medium mb-1">{TRANSLATIONS.remarks}</label>
                                                <textarea value={item.remarks || ''} onChange={e => handleChange('remarks', e.target.value)} rows="3" className="w-full bg-slate-100 dark:bg-slate-900/80 rounded-md p-2 ring-1 ring-slate-300 dark:ring-slate-700 focus:ring-blue-500 focus:outline-none"></textarea>
                                            </div>
                                            <div>
                                                <label className="block text-sm font-medium font-vazir">{TRANSLATIONS.remarksFa}</label>
                                                <textarea value={item.remarksFa || ''} onChange={e => handleChange('remarksFa', e.target.value)} rows="3" className="w-full bg-slate-100 dark:bg-slate-900/80 rounded-md p-2 ring-1 ring-slate-300 dark:ring-slate-700 focus:ring-blue-500 focus:outline-none font-vazir text-right" dir="rtl"></textarea>
                                            </div>
                                        </div>

                                        <div className="grid grid-cols-1 sm:grid-cols-3 gap-4">
                                            <div>
                                                <label className="block text-sm font-medium mb-1">{TRANSLATIONS.price}</label>
                                                <input type="number" value={item.price || ''} onChange={e => handleChange('price', parseFloat(toLatinDigits(e.target.value)) || 0)} className="w-full bg-slate-100 dark:bg-slate-900/80 rounded-md p-2 ring-1 ring-slate-300 dark:ring-slate-700 focus:ring-blue-500 focus:outline-none" />
                                            </div>
                                            <div>
                                                <label className="block text-sm font-medium mb-1">{TRANSLATIONS.currency}</label>
                                                <div className="relative">
                                                    <select value={item.currency || '€'} onChange={e => handleChange('currency', e.target.value)} className="w-full bg-slate-100 dark:bg-slate-900/80 rounded-md p-2 ring-1 ring-slate-300 dark:ring-slate-700 focus:ring-blue-500 focus:outline-none appearance-none pr-8">
                                                        <option value="€">€</option>
                                                        <option value="تومان">تومان</option>
                                                        <option value="$">$</option>
                                                    </select>
                                                    <div className="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-slate-700 dark:text-slate-200">
                                                        <ChevronDownIcon className="w-5 h-5" />
                                                    </div>
                                                </div>
                                            </div>
                                            <div>
                                                <label className="block text-sm font-medium mb-1">{TRANSLATIONS.totalQuantity}</label>
                                                <input type="number" value={item.quantity || ''} onChange={e => handleChange('quantity', parseInt(toLatinDigits(e.target.value), 10) || 0)} className="w-full bg-slate-100 dark:bg-slate-900/80 rounded-md p-2 ring-1 ring-slate-300 dark:ring-slate-700 focus:ring-blue-500 focus:outline-none" />
                                            </div>
                                        </div>
                                        <div>
                                            <label className="block text-sm font-medium mb-1">{TRANSLATIONS.priceNote}</label>
                                            <input type="text" value={item.priceNote || ''} onChange={e => handleChange('priceNote', e.target.value)} className="w-full bg-slate-100 dark:bg-slate-900/80 rounded-md p-2 ring-1 ring-slate-300 dark:ring-slate-700 focus:ring-blue-500 focus:outline-none" />
                                        </div>
                                    </>
                                )}
                            </div>
                            <footer className="p-4 border-t border-slate-200 dark:border-slate-700 flex justify-end gap-2 flex-shrink-0">
                                <button type="button" onClick={onClose} className="px-4 py-2 bg-slate-200 dark:bg-slate-600 rounded-md hover:bg-slate-300 dark:hover:bg-slate-500 font-semibold transition-colors">{TRANSLATIONS.cancel}</button>
                                <button type="button" onClick={handleSave} className="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-500 font-semibold transition-colors">{TRANSLATIONS.save}</button>
                            </footer>
                        </div>
                    </div>
                );
            }

            function GridView({ items, type, context, setView, openModal, openConfirm, handleDelete, lang, isManagementMode }) {
                const getTitle = (item) => {
                    if (type === 'product' || type === 'searchResults') {
                        const fa = item?.name?.fa;
                        if (!fa) return '';
                        const cleaned = cleanProductName(fa);
                        if (!cleaned || cleaned.trim().length === 0) return '';
                        return cleaned;
                    }
                    const title = getLocalizedTitle(item.name, lang, TRANSLATIONS.untitled);
                    return title;
                };

                const Card = ({ item, index }) => {
                    const isCategory = type === 'category';
                    const hasImages = isCategory && item.productImages && item.productImages.length > 0;

                    const [hoveredImageIndex, setHoveredImageIndex] = useState(0);
                    const hoverIntervalRef = useRef(null);

                    const originalTitle = getTitle(item);


                    const startSlideshow = useCallback(() => {
                        if (!hasImages || item.productImages.length <= 1) return;
                        clearInterval(hoverIntervalRef.current);
                        hoverIntervalRef.current = setInterval(() => {
                            setHoveredImageIndex(prevIndex => (prevIndex + 1) % item.productImages.length);
                        }, 1200);
                    }, [hasImages, item.productImages]);

                    const stopSlideshow = useCallback(() => {
                        clearInterval(hoverIntervalRef.current);
                        hoverIntervalRef.current = null;
                        setHoveredImageIndex(0);
                    }, []);

                    const handleClick = () => {
                        if (type === 'brand') {
                            setView({ type: 'categories', brandId: item.id });
                        } else if (type === 'category') {
                            setView({ type: 'products', brandId: item.brandId, categoryId: item.id });
                        } else if (type === 'product' || type === 'searchResults') {
                            setView({ type: 'productDetail', brandId: item.context?.brandId || context.brandId, categoryId: item.context?.categoryId || context.categoryId, productId: item.id });
                        }
                    };

                    const cardContent = (
                        <div
                            onClick={handleClick}
                            onMouseEnter={startSlideshow}
                            onMouseLeave={stopSlideshow}
                            className="group relative aspect-square transition-all duration-300 cursor-pointer rounded-lg overflow-hidden shadow-xl dark:shadow-[0_15px_30px_rgba(0,0,0,0.6)] hover:shadow-2xl dark:hover:shadow-[0_20px_40px_rgba(59,130,246,0.5)] ring-1 ring-black/5 dark:ring-white/10 hover:ring-blue-500/50 hover:scale-105"
                        >
                            <div className="absolute inset-0 bg-white dark:bg-slate-800">
                                {hasImages ? (
                                    <>
                                        <img
                                            src={item.productImages[0]}
                                            alt={originalTitle}
                                            className="absolute inset-0 w-full h-full object-cover transition-opacity duration-500 ease-in-out group-hover:opacity-0"
                                        />
                                        <div className="absolute inset-0 w-full h-full opacity-0 group-hover:opacity-100 transition-opacity duration-500 ease-in-out">
                                            {item.productImages.map((imgSrc, i) => (
                                                <img
                                                    key={i}
                                                    src={imgSrc}
                                                    className={`w-full h-full object-cover absolute inset-0 transition-opacity duration-1000 ease-in-out ${hoveredImageIndex === i ? 'opacity-100' : 'opacity-0'}`}
                                                    alt=""
                                                />
                                            ))}
                                        </div>
                                    </>
                                ) : item.images && item.images.length > 0 ? (
                                    <img src={item.images[0]} alt={originalTitle} className="w-full h-full object-cover transition-transform duration-300 group-hover:scale-110" />
                                ) : (
                                    <div className="w-full h-full flex items-center justify-center bg-slate-200 dark:bg-slate-700">
                                        <BuildingStorefrontIcon />
                                    </div>
                                )}
                            </div>

                            {type !== 'product' && type !== 'searchResults' && (
                                <div className="absolute bottom-0 left-0 right-0 p-3 bg-gradient-to-t from-black/80 to-transparent">
                                    <h3 className="text-sm font-bold text-white text-center truncate">
                                        {originalTitle}
                                    </h3>
                                </div>
                            )}

                            {isManagementMode && (
                                <div className="absolute top-2 right-2 flex gap-1 opacity-0 group-hover:opacity-100 transition-opacity z-10">
                                    <button onClick={(e) => { e.stopPropagation(); openModal(type, 'edit', item, context) }} className="p-1.5 bg-slate-100/90 dark:bg-slate-800/90 rounded-full text-blue-500 dark:text-blue-400 hover:bg-slate-200 dark:hover:bg-slate-600 shadow-md"><PencilIcon className="w-4 h-4" /></button>
                                    <button
                                        onClick={(e) => {
                                            e.stopPropagation();
                                            openConfirm({
                                                title: `${TRANSLATIONS.delete} "${originalTitle}"`,
                                                message: TRANSLATIONS.confirmDelete,
                                                confirmText: TRANSLATIONS.confirmDeleteAction,
                                                confirmClass: 'bg-red-600 hover:bg-red-500',
                                                onConfirm: () => handleDelete(type, { [`${type}Id`]: item.id })
                                            })
                                        }}
                                        className="p-1.5 bg-slate-100/90 dark:bg-slate-800/90 rounded-full text-red-500 dark:text-red-400 hover:bg-slate-200 dark:hover:bg-slate-600 shadow-md"
                                    ><TrashIcon className="w-4 h-4" /></button>
                                </div>
                            )}
                        </div>
                    );

                    if (type === 'product' || type === 'searchResults') {
                        return cardContent;
                    }

                    return (
                        <AnimatedWrapper index={index}>
                            {cardContent}
                        </AnimatedWrapper>
                    );
                };

                return (
                    <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-4 sm:gap-6">
                        {items.map((item, index) => <Card key={item.id} item={item} index={index} />)}
                        {isManagementMode && (() => {
                            const addButton = (
                                <div
                                    onClick={() => openModal(type, 'add', { id: generateId(), name: { en: '', fa: '' }, description: { en: '', fa: '' }, price: 0, currency: '€', quantity: 0, images: [] }, context)}
                                    className="aspect-square h-full transition-all duration-300 flex flex-col items-center justify-center gap-2 cursor-pointer rounded-lg bg-slate-200/50 dark:bg-slate-800/40 border-2 border-dashed border-slate-400 dark:border-slate-600 hover:bg-slate-200 dark:hover:bg-slate-700/60 hover:border-blue-500 text-slate-500 dark:text-slate-400"
                                >
                                    <PlusIcon className="w-10 h-10" />
                                    <span className="text-sm font-semibold">{type === 'category' ? TRANSLATIONS.addCategory : TRANSLATIONS.addProduct}</span>
                                </div>
                            );

                            if (type === 'product' || type === 'searchResults') {
                                return addButton;
                            }

                            return (
                                <AnimatedWrapper index={items.length}>
                                    {addButton}
                                </AnimatedWrapper>
                            );
                        })()}
                    </div>
                );
            }

            function ProductDetailView({ product, brand, category, lang, addToast, setLightboxImage, breadcrumbs, setView }) {
                const [selectedImageIndex, setSelectedImageIndex] = useState(0);
                const [selectedLang, setSelectedLang] = useState('en');

                // Mobile bottom-sheet state (drag to reveal details)
                const sheetRef = useRef(null);
                const startYRef = useRef(0);
                const startTranslateRef = useRef(0);
                const sheetHeightRef = useRef(420);
                const [sheetTranslate, setSheetTranslate] = useState(72); // percent (0 = fully open, 100 = hidden)
                const draggingRef = useRef(false);

                useEffect(() => {
                    const setHeight = () => {
                        if (sheetRef.current) {
                            const maxH = Math.min(window.innerHeight * 0.85, sheetRef.current.scrollHeight || 560);
                            sheetHeightRef.current = maxH;
                        }
                    };
                    setHeight();
                    window.addEventListener('resize', setHeight);
                    return () => window.removeEventListener('resize', setHeight);
                }, []);

                const handleTouchStart = (e) => {
                    draggingRef.current = true;
                    startYRef.current = e.touches ? e.touches[0].clientY : e.clientY;
                    startTranslateRef.current = sheetTranslate;
                };

                const handleTouchMove = (e) => {
                    if (!draggingRef.current) return;
                    const currentY = e.touches ? e.touches[0].clientY : e.clientY;
                    const dy = currentY - startYRef.current;
                    const deltaPercent = (dy / sheetHeightRef.current) * 100;
                    let next = startTranslateRef.current + deltaPercent;
                    if (next < 0) next = 0;
                    if (next > 100) next = 100;
                    setSheetTranslate(next);
                };

                const handleTouchEnd = () => {
                    draggingRef.current = false;
                    if (sheetTranslate < 40) setSheetTranslate(0);
                    else setSheetTranslate(72);
                };

                if (!product) {
                    return <div className="text-center p-8">Product not found.</div>;
                }

                const { name, description, images = [], remarks, remarksFa } = product;

                // Prefer showing the full English name (if provided) as the product identifier
                // so codes that contain spaces are displayed exactly as entered.
                const productId = (product.name?.en && product.name.en.toString().trim()) || product.id;

                const handleShare = async () => {
                    const productIdText = productId || product.id;
                    const message = `Product Code: ${productIdText}`;

                    const imageToShare = images?.[selectedImageIndex];

                            if (imageToShare && navigator.share && navigator.canShare) {
                        try {
                            let blob;
                            // Handle both data URLs and regular web URLs
                            if (imageToShare.startsWith('data:')) {
                                blob = dataURLtoBlob(imageToShare);
                            } else {
                                        if (window.IS_FILE_PROTOCOL) {
                                            // Browser often blocks fetch for local file origin; inform user
                                            alert('Sharing images is limited when opening the HTML directly. Run a local HTTP server (e.g. start-server.bat) and open via http://localhost to enable sharing.');
                                            return;
                                        }
                                        const response = await fetch(imageToShare);
                                if (!response.ok) {
                                    throw new Error(`Failed to fetch image: ${response.statusText}`);
                                }
                                blob = await response.blob();
                            }

                            const file = new File([blob], `${productIdText}.jpg`, { type: blob.type || 'image/jpeg' });

                            if (navigator.canShare({ files: [file] })) {
                                await navigator.share({
                                    files: [file],
                                    text: message,
                                    title: getLocalizedTitle(product.name, 'en'),
                                });
                                return;
                            } else {
                                // If it can't share the file specifically, fall through to text-only
                                throw new Error("Sharing files of this type is not supported by the browser.");
                            }
                        } catch (error) {
                            console.error('Error sharing image:', error);
                            // Fallback is handled below
                        }
                    }

                    // Fallback for browsers that don't support sharing or if an error occurred
                    addToast(TRANSLATIONS.shareFailedTextOnly, 'warning');
                    const whatsappUrl = `https://wa.me/?text=${encodeURIComponent(message)}`;
                    window.open(whatsappUrl, '_blank');
                };

                return (
                    <div className="h-full w-full flex flex-col bg-slate-100 dark:bg-slate-950">
                            {/* BREADCRUMB NAVIGATION */}
                            <div className="flex-shrink-0 bg-white/60 dark:bg-slate-900/60 backdrop-blur-lg shadow-sm p-3 px-4 sm:px-6 lg:px-8 z-10"
                                style={{ position: 'sticky', top: 'env(safe-area-inset-top, 0px)', paddingTop: 'env(safe-area-inset-top, 0px)' }}>
                            <div className="flex items-center text-sm text-slate-600 dark:text-slate-400 overflow-x-auto whitespace-nowrap">
                                <button onClick={() => setView({ type: 'brands' })} className="hover:text-blue-500 dark:hover:text-blue-400 transition-colors flex-shrink-0">
                                    {TRANSLATIONS.brands}
                                </button>
                                {breadcrumbs.map((crumb, index) => (
                                    <span key={index} className="flex items-center flex-shrink-0">
                                        <span className="mx-2 text-slate-400 dark:text-slate-500">/</span>
                                        <button
                                            onClick={() => {
                                                if (crumb.type === 'brand') setView({ type: 'categories', brandId: crumb.id });
                                                if (crumb.type === 'category') setView({ type: 'products', brandId: crumb.context.brandId, categoryId: crumb.id });
                                            }}
                                            className="hover:text-blue-500 dark:hover:text-blue-400 transition-colors disabled:text-slate-800 dark:disabled:text-slate-200 disabled:font-semibold disabled:no-underline disabled:cursor-default"
                                            disabled={index === breadcrumbs.length - 1}
                                        >
                                            {getLocalizedTitle(crumb.name, lang)}
                                        </button>
                                    </span>
                                ))}
                            </div>
                        </div>

                        <div className="flex flex-col lg:flex-row flex-grow w-full bg-slate-200 dark:bg-slate-950 text-slate-900 dark:text-white min-h-0 max-w-full">
                            {/* Image Section - Mobile: Full Width, Desktop: 65% */}
                            <div className="w-full lg:w-[65%] flex flex-col p-2 sm:p-3 md:p-4 bg-slate-200 dark:bg-slate-900 overflow-y-auto mt-6" style={{ minHeight: '320px', maxHeight: `calc(100dvh - var(--footer-height, 0px) - env(safe-area-inset-top, 0px) - 24px)`, boxSizing: 'border-box' }}>
                                {/* Main Image */}
                                <div className="relative bg-white dark:bg-slate-800 rounded-lg flex items-center justify-center shadow-md mb-2 sm:mb-3 flex-shrink-0 overflow-hidden"
                                    style={{ height: 'min(42vh, 420px)', width: '100%' }}>
                                    {images.length > 0 ? (
                                        <img
                                            src={images[selectedImageIndex]}
                                            onClick={() => setLightboxImage(images[selectedImageIndex])}
                                            className="w-full h-full object-contain object-center cursor-pointer"
                                        />
                                    ) : (
                                        <div className="text-slate-500 text-xs sm:text-sm">تصویری نیست</div>
                                    )}
                                </div>
                                {/* Thumbnails */}
                                {images.length > 0 && (
                                    <div className="flex flex-row gap-1 overflow-x-auto horizontal-scrollbar pb-2 flex-shrink-0"
                                        style={{ height: '90px', width: '100%' }}>
                                        {images.map((img, index) => (
                                            <img
                                                key={index} src={img}
                                                onClick={() => setSelectedImageIndex(index)}
                                                className={`h-full aspect-square object-cover rounded-md cursor-pointer transition-all duration-300 ring-2 flex-shrink-0 ${selectedImageIndex === index ? 'ring-blue-500' : 'ring-transparent opacity-70 hover:opacity-100'}`}
                                            />
                                        ))}
                                    </div>
                                )}
                            </div>

                            {/* Details Section - Desktop (side column) */}
                            <div className="hidden lg:block w-full lg:w-[35%] overflow-y-auto p-3 sm:p-4 md:p-5 lg:p-6 bg-white dark:bg-slate-800 flex flex-col mt-6 relative z-20 pb-28 sm:pb-32" style={{ minHeight: '320px', maxHeight: `calc(100dvh - var(--footer-height, 0px) - env(safe-area-inset-top, 0px) - 24px)`, boxSizing: 'border-box' }}>
                                {/* Header Info */}
                                <div className="flex-shrink-0 mb-3 sm:mb-4">
                                    <h2 className="text-base sm:text-xl md:text-2xl font-bold text-slate-800 dark:text-slate-200 break-words">{productId}</h2>
                                    <h1 className="text-xs sm:text-sm md:text-base mt-2 text-slate-700 dark:text-slate-300 font-normal font-vazir" dir="rtl">
                                        {/* فقط اگر name.fa مقدار داشت و بعد از clean کردن خالی نبود نمایش بده */}
                                        {(() => {
                                            if (!product?.name?.fa) return null;
                                            const cleaned = cleanProductName(product.name.fa);
                                            if (!cleaned || cleaned.trim().length === 0) return null;
                                            return cleaned;
                                        })()}
                                    </h1>
                                    {/* category is shown in breadcrumb; avoid duplicating it here */}

                                    {(remarksFa || remarks) && (
                                        <>
                                            {remarksFa && (
                                                <p className="mt-1 sm:mt-2 text-xs sm:text-sm text-slate-500 dark:text-slate-400" dir="rtl">
                                                    {remarksFa}
                                                </p>
                                            )}
                                            {remarks && (
                                                <p className="mt-1 sm:mt-2 text-xs sm:text-sm text-slate-500 dark:text-slate-400" dir="ltr">
                                                    {remarks}
                                                </p>
                                            )}
                                        </>
                                    )}

                                    {/* Language Toggle */}
                                    <div className="flex gap-1 sm:gap-2 my-2 sm:my-3 justify-end">
                                        <button
                                            onClick={() => setSelectedLang('en')}
                                            className={`px-2 sm:px-3 py-1 rounded-full text-xs sm:text-sm font-semibold transition-colors ${selectedLang === 'en' ? 'bg-blue-600 text-white' : 'bg-slate-200 dark:bg-slate-700 text-slate-700 dark:text-slate-300'}`}
                                        >EN</button>
                                        <button
                                            onClick={() => setSelectedLang('fa')}
                                            className={`px-2 sm:px-3 py-1 rounded-full text-xs sm:text-sm font-semibold font-vazir transition-colors ${selectedLang === 'fa' ? 'bg-blue-600 text-white' : 'bg-slate-200 dark:bg-slate-700 text-slate-700 dark:text-slate-300'}`}
                                        >FA</button>
                                    </div>

                                    {/* Description */}
                                    <p className={`whitespace-pre-wrap text-xs sm:text-sm text-slate-600 dark:text-slate-300 leading-relaxed my-2 sm:my-3 ${selectedLang === 'fa' ? 'font-vazir text-right' : 'text-left'}`} dir={selectedLang === 'fa' ? 'rtl' : 'ltr'}>
                                        {getLocalizedText(product, 'description', selectedLang)}
                                    </p>
                                </div>

                                {/* Bottom Details */}
                                <div className="mt-auto pt-2 sm:pt-3 md:pt-4 border-t border-slate-200 dark:border-slate-700 space-y-1 sm:space-y-2 flex-shrink-0">
                                    {product.price > 0 && (
                                        <div className="flex flex-col sm:flex-row sm:justify-between items-baseline text-xs sm:text-sm gap-1">
                                            <span className="text-slate-500 dark:text-slate-400 font-medium">{TRANSLATIONS.price}:</span>
                                            <div className="text-right">
                                                <p className="text-lg sm:text-xl md:text-2xl font-bold text-slate-800 dark:text-slate-200">
                                                    {formatPrice(product.price, product.currency, selectedLang)}
                                                </p>
                                                {product.priceNote && <p className="text-xs text-slate-500 font-vazir dark:text-slate-400">{product.priceNote}</p>}
                                            </div>
                                        </div>
                                    )}
                                    <div className="flex justify-between items-center text-xs sm:text-sm">
                                        <span className="text-slate-500 dark:text-slate-400 font-medium">{TRANSLATIONS.inventory}:</span>
                                        <span className="font-bold text-sm sm:text-base text-slate-800 dark:text-slate-200">{product.quantity > 0 ? product.quantity : ''}</span>
                                    </div>
                                    <div className="flex justify-end pt-1 sm:pt-2">
                                        <button
                                            onClick={handleShare}
                                            className="inline-flex items-center justify-center gap-1 px-2 sm:px-3 py-1 sm:py-2 bg-green-500 text-white rounded-lg hover:bg-green-600 font-semibold text-xs sm:text-sm transition-colors"
                                        >
                                            <WhatsAppIcon className="w-3 h-3 sm:w-4 sm:h-4" />
                                            {TRANSLATIONS.shareOnWhatsApp}
                                        </button>
                                    </div>
                                </div>
                            </div>

                            {/* Mobile Bottom Sheet: draggable details overlay (only for small screens) */}
                            <div className="lg:hidden">
                                <div
                                    ref={sheetRef}
                                    onTouchStart={handleTouchStart}
                                    onTouchMove={handleTouchMove}
                                    onTouchEnd={handleTouchEnd}
                                    onMouseDown={(e) => { e.preventDefault(); handleTouchStart(e); window.addEventListener('mousemove', handleTouchMove); const up = () => { handleTouchEnd(); window.removeEventListener('mousemove', handleTouchMove); window.removeEventListener('mouseup', up); }; window.addEventListener('mouseup', up); }}
                                    className="fixed left-0 right-0 bottom-0 z-50 bg-white dark:bg-slate-800 shadow-2xl rounded-t-xl p-4"
                                    style={{
                                        height: 'min(85vh, 560px)',
                                        transform: `translateY(${sheetTranslate}%)`,
                                        transition: draggingRef.current ? 'none' : 'transform 220ms ease',
                                        boxSizing: 'border-box'
                                    }}
                                >
                                    <div className="w-full flex justify-center mb-3">
                                        <div className="w-12 h-1.5 rounded-full bg-slate-300 dark:bg-slate-600" />
                                    </div>

                                    <div className="overflow-y-auto" style={{ maxHeight: 'calc(85vh - 48px)' }}>
                                        <div className="mb-3">
                                            <h2 className="text-base sm:text-xl md:text-2xl font-bold text-slate-800 dark:text-slate-200 break-words">{productId}</h2>
                                            <h1 className="text-xs sm:text-sm md:text-base mt-2 text-slate-700 dark:text-slate-300 font-normal font-vazir" dir="rtl">
                                                {(() => {
                                                    if (!product?.name?.fa) return null;
                                                    const cleaned = cleanProductName(product.name.fa);
                                                    if (!cleaned || cleaned.trim().length === 0) return null;
                                                    return cleaned;
                                                })()}
                                            </h1>
                                            {/* category is shown in breadcrumb; avoid duplicating it here */}
                                            {(remarksFa || remarks) && (
                                                <>
                                                    {remarksFa && (
                                                        <p className="mt-1 sm:mt-2 text-xs sm:text-sm text-slate-500 dark:text-slate-400" dir="rtl">
                                                            {remarksFa}
                                                        </p>
                                                    )}
                                                    {remarks && (
                                                        <p className="mt-1 sm:mt-2 text-xs sm:text-sm text-slate-500 dark:text-slate-400" dir="ltr">
                                                            {remarks}
                                                        </p>
                                                    )}
                                                </>
                                            )}
                                        </div>

                                        <div className="flex gap-1 sm:gap-2 my-2 sm:my-3 justify-end">
                                            <button onClick={() => setSelectedLang('en')} className={`px-2 sm:px-3 py-1 rounded-full text-xs sm:text-sm font-semibold transition-colors ${selectedLang === 'en' ? 'bg-blue-600 text-white' : 'bg-slate-200 dark:bg-slate-700 text-slate-700 dark:text-slate-300'}`}>EN</button>
                                            <button onClick={() => setSelectedLang('fa')} className={`px-2 sm:px-3 py-1 rounded-full text-xs sm:text-sm font-semibold font-vazir transition-colors ${selectedLang === 'fa' ? 'bg-blue-600 text-white' : 'bg-slate-200 dark:bg-slate-700 text-slate-700 dark:text-slate-300'}`}>FA</button>
                                        </div>

                                        <p className={`whitespace-pre-wrap text-xs sm:text-sm text-slate-600 dark:text-slate-300 leading-relaxed my-2 sm:my-3 ${selectedLang === 'fa' ? 'font-vazir text-right' : 'text-left'}`} dir={selectedLang === 'fa' ? 'rtl' : 'ltr'}>
                                            {getLocalizedText(product, 'description', selectedLang)}
                                        </p>

                                        <div className="mt-3 pt-2 border-t border-slate-200 dark:border-slate-700 space-y-1 sm:space-y-2">
                                            {product.price > 0 && (
                                                <div className="flex flex-col sm:flex-row sm:justify-between items-baseline text-xs sm:text-sm gap-1">
                                                    <span className="text-slate-500 dark:text-slate-400 font-medium">{TRANSLATIONS.price}:</span>
                                                    <div className="text-right">
                                                        <p className="text-lg sm:text-xl md:text-2xl font-bold text-slate-800 dark:text-slate-200">{formatPrice(product.price, product.currency, selectedLang)}</p>
                                                        {product.priceNote && <p className="text-xs text-slate-500 font-vazir dark:text-slate-400">{product.priceNote}</p>}
                                                    </div>
                                                </div>
                                            )}
                                            <div className="flex justify-between items-center text-xs sm:text-sm">
                                                <span className="text-slate-500 dark:text-slate-400 font-medium">{TRANSLATIONS.inventory}:</span>
                                                <span className="font-bold text-sm sm:text-base text-slate-800 dark:text-slate-200">{product.quantity > 0 ? product.quantity : ''}</span>
                                            </div>
                                            <div className="flex justify-end pt-1 sm:pt-2">
                                                <button onClick={handleShare} className="inline-flex items-center justify-center gap-1 px-2 sm:px-3 py-1 sm:py-2 bg-green-500 text-white rounded-lg hover:bg-green-600 font-semibold text-xs sm:text-sm transition-colors">
                                                    <WhatsAppIcon className="w-3 h-3 sm:w-4 sm:h-4" />
                                                    {TRANSLATIONS.shareOnWhatsApp}
                                                </button>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                );
            }

            // --- FOOTER COMPONENTS ---

            const MapPinIcon = ({ className = "w-6 h-6" }) => (<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}><path strokeLinecap="round" strokeLinejoin="round" d="M15 10.5a3 3 0 1 1-6 0 3 3 0 0 1 6 0Z" /><path strokeLinecap="round" strokeLinejoin="round" d="M19.5 10.5c0 7.142-7.5 11.25-7.5 11.25S4.5 17.642 4.5 10.5a7.5 7.5 0 1 1 15 0Z" /></svg>);
            const PhoneIcon = ({ className = "w-6 h-6" }) => (<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}><path strokeLinecap="round" strokeLinejoin="round" d="M2.25 6.75c0 8.284 6.716 15 15 15h2.25a2.25 2.25 0 0 0 2.25-2.25v-1.372c0-.516-.351-.966-.852-1.091l-4.423-1.106c-.44-.11-.902.055-1.173.417l-.97 1.293c-.282.376-.769.542-1.21.38a12.035 12.035 0 0 1-7.143-7.143c-.162-.441.004-.928.38-1.21l1.293-.97c.363-.271.527-.734.417-1.173L6.963 3.102a1.125 1.125 0 0 0-1.091-.852H4.5A2.25 2.25 0 0 0 2.25 4.5v2.25Z" /></svg>);
            const EnvelopeIcon = ({ className = "w-6 h-6" }) => (<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}><path strokeLinecap="round" strokeLinejoin="round" d="M21.75 6.75v10.5a2.25 2.25 0 0 1-2.25 2.25h-15a2.25 2.25 0 0 1-2.25-2.25V6.75m19.5 0A2.25 2.25 0 0 0 19.5 4.5h-15a2.25 2.25 0 0 0-2.25 2.25m19.5 0v.243a2.25 2.25 0 0 1-1.07 1.916l-7.5 4.615a2.25 2.25 0 0 1-2.36 0L3.32 8.91a2.25 2.25 0 0 1-1.07-1.916V6.75" /></svg>);
            const ArrowTopRightOnSquareIcon = ({ className = "w-6 h-6" }) => (<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}><path strokeLinecap="round" strokeLinejoin="round" d="M13.5 6H5.25A2.25 2.25 0 0 0 3 8.25v10.5A2.25 2.25 0 0 0 5.25 21h10.5A2.25 2.25 0 0 0 18 18.75V10.5m-10.5 6L21 3m0 0h-5.25M21 3v5.25" /></svg>);

            function FooterSection({ settings, setFooterHeight }) {
                const footerRef = useRef(null);

                useEffect(() => {
                    if (footerRef.current && setFooterHeight) {
                            const resizeObserver = new ResizeObserver(entries => {
                                for (let entry of entries) {
                                    const h = entry.contentRect.height;
                                    setFooterHeight(h);
                                }
                            });
                            resizeObserver.observe(footerRef.current);
                            return () => {
                                resizeObserver.disconnect();
                            };
                        }
                }, [setFooterHeight]);

                const {
                    logo,
                    secondaryLogo,
                    address,
                    locationLink,
                    phoneNumbers,
                    email,
                    instagramLink,
                    whatsappLink,
                } = settings || {};

                // Cloud Dancer (11-4201 TCX) - Approx #F0EEE9
                const bgColor = '#F0EEE9';

                return (
                    <footer
                        ref={footerRef}
                        className="w-full fixed left-0 bottom-0 z-0 text-slate-800 shadow-[0_-6px_24px_rgba(0,0,0,0.06)] transition-all duration-300"
                        style={{ backgroundColor: bgColor, paddingBottom: 'env(safe-area-inset-bottom,16px)', boxSizing: 'border-box', width: '100%' }}
                    >
                        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-6 sm:py-8 text-sm sm:text-base">
                            <div className="grid grid-cols-1 md:grid-cols-12 gap-8 md:gap-12 items-start opacity-0 animate-fade-in" style={{ animationDelay: '0.2s' }}>
                                {/* Column 1: Logo */}
                                <div className="col-span-12 md:col-span-4 flex flex-col items-center gap-4">
                                    {logo ? (
                                        <div className="flex flex-col items-center relative">
                                            <img id="footerLogo" src={logo} alt="Brand Logo" className="h-20 md:h-24 w-auto object-contain mix-blend-multiply" />
                                            {secondaryLogo && (
                                                <img
                                                    src={secondaryLogo}
                                                    alt="Secondary Logo"
                                                    id="secondaryLogo"
                                                    className="md:absolute relative md:left-1/2 md:top-28 mt-3 h-16 md:h-20 w-auto object-contain opacity-95 md:translate-x-[-50%]"
                                                />
                                            )}
                                        </div>
                                    ) : (
                                        <div className="h-32 w-32 bg-slate-200/50 rounded-lg flex items-center justify-center border-2 border-dashed border-slate-400/30">
                                            <span className="text-slate-400 text-sm">{TRANSLATIONS.brandLogo}</span>
                                        </div>
                                    )}
                                </div>

                                {/* Column 2: Address */}
                                <div className="col-span-12 md:col-span-4 flex flex-col gap-3 text-right items-center md:items-center md:mt-8" dir="rtl">
                                    {/* Contact Information label (moved above address, centered) */}
                                    <h3 className="font-bold text-lg border-b-2 border-slate-300 pb-1 mb-2 w-fit text-slate-800 tracking-wide mx-auto">{TRANSLATIONS.contactInfo}</h3>
                                    {address && (
                                        <div className="flex gap-3 items-start text-slate-600 mt-2 max-w-lg">
                                            <MapPinIcon className="w-6 h-6 flex-shrink-0 mt-1 text-slate-500" />
                                            <p className="whitespace-pre-line text-base md:text-lg leading-relaxed font-vazir text-right mt-0">{address}</p>
                                        </div>
                                    )}
                                    {locationLink && (
                                        <a href={locationLink} target="_blank" rel="noopener noreferrer" className="text-sm font-semibold bg-white border border-slate-200 text-slate-600 hover:text-blue-600 hover:border-blue-300 py-2 px-6 rounded-full shadow-sm hover:shadow-md transition-all flex items-center gap-2 mt-3 mx-auto font-vazir">
                                            <span>{TRANSLATIONS.locationLink}</span>
                                            <ArrowTopRightOnSquareIcon className="w-4 h-4" />
                                        </a>
                                    )}
                                </div>

                                {/* Column 3: Contact */}
                                <div className="col-span-12 md:col-span-4 flex flex-col gap-4 text-center md:text-left md:items-start items-center md:mt-8">
                                    <div className="flex flex-wrap items-center gap-4 justify-center md:justify-start w-full">
                                            <div className="flex items-center gap-2">
                                            {instagramLink && (
                                                <a href={instagramLink} target="_blank" rel="noopener noreferrer"
                                                    className="rounded-xl shadow-md hover:scale-110 transition-transform flex items-center justify-center p-0.5 overflow-hidden"
                                                    style={{ width: '40px', height: '40px', background: 'linear-gradient(45deg, #f09433 0%, #e6683c 25%, #dc2743 50%, #cc2366 75%, #bc1888 100%)' }}
                                                    title="Instagram">
                                                    <svg fill="white" viewBox="0 0 24 24" style={{ width: '24px', height: '24px' }}>
                                                        <path d="M12 2.163c3.204 0 3.584.012 4.85.07 3.252.148 4.771 1.691 4.919 4.919.058 1.265.069 1.645.069 4.849 0 3.205-.012 3.584-.069 4.849-.149 3.225-1.664 4.771-4.919 4.919-1.266.058-1.644.07-4.85.07-3.204 0-3.584-.012-4.849-.07-3.26-.149-4.771-1.699-4.919-4.92-.058-1.265-.07-1.644-.07-4.849 0-3.204.013-3.583.07-4.849.149-3.227 1.664-4.771 4.919-4.919 1.266-.057 1.645-.069 4.849-.069zm0-2.163c-3.259 0-3.667.014-4.947.072-4.358.2-6.78 2.618-6.98 6.98-.059 1.281-.073 1.689-.073 4.948 0 3.259.014 3.668.072 4.948.2 4.358 2.618 6.78 6.98 6.98 1.281.058 1.689.072 4.948.072 3.259 0 3.668-.014 4.948-.072 4.354-.2 6.782-2.618 6.979-6.98.059-1.28.073-1.689.073-4.948 0-3.259-.014-3.667-.072-4.947-.196-4.354-2.617-6.78-6.979-6.98-1.281-.059-1.69-.073-4.949-.073zm0 5.838c-3.403 0-6.162 2.759-6.162 6.162s2.759 6.163 6.162 6.163 6.162-2.759 6.162-6.163c0-3.403-2.759-6.162-6.162-6.162zm0 10.162c-2.209 0-4-1.79-4-4 0-2.209 1.791-4 4-4s4 1.791 4 4c0 2.21-1.791 4-4 4zm6.406-11.845c-.796 0-1.441.645-1.441 1.44s.645 1.44 1.441 1.44c.795 0 1.439-.645 1.439-1.44s-.644-1.44-1.439-1.44z" />
                                                    </svg>
                                                </a>
                                            )}
                                            {whatsappLink && (
                                                <a href={whatsappLink} target="_blank" rel="noopener noreferrer" className="p-2 bg-white shadow-sm rounded-full text-green-500 hover:scale-110 transition-transform" title="WhatsApp">
                                                    <WhatsAppIcon className="w-7 h-7" />
                                                </a>
                                            )}
                                        </div>
                                    </div>
                                    {phoneNumbers && phoneNumbers.length > 0 && (
                                        <div className="space-y-4">
                                            {phoneNumbers.map((phone, idx) => (
                                                <div key={idx} className="flex items-center gap-4 justify-center md:justify-start text-slate-700">
                                                    <span className="p-2 bg-white rounded-full shadow-sm">
                                                        <PhoneIcon className="w-6 h-6 text-slate-500" />
                                                    </span>
                                                    <a href={`tel:${phone}`} className="hover:text-blue-600 font-mono text-base md:text-lg tracking-tight transition-colors">{phone}</a>
                                                </div>
                                            ))}
                                        </div>
                                    )}
                                    {email && (
                                        <div className="flex items-center gap-4 justify-center md:justify-start mt-2 text-slate-700">
                                            <span className="p-2 bg-white rounded-full shadow-sm">
                                                <EnvelopeIcon className="w-6 h-6 text-slate-500" />
                                            </span>
                                            <a href={`mailto:${email}`} className="hover:text-blue-600 text-base transition-colors">{email}</a>
                                        </div>
                                    )}
                                </div>
                            </div>
                        </div>
                    </footer>
                );
            }

            function FooterSettingsModal({ isOpen, onClose, onSave, initialSettings, addToast }) {
                if (!isOpen) return null;

                const [logo, setLogo] = useState(initialSettings?.logo || null);
                const [secondaryLogo, setSecondaryLogo] = useState(initialSettings?.secondaryLogo || null);
                const [address, setAddress] = useState(initialSettings?.address || '');
                const [locationLink, setLocationLink] = useState(initialSettings?.locationLink || '');
                const [phones, setPhones] = useState(initialSettings?.phoneNumbers?.join('\n') || '');
                const [email, setEmail] = useState(initialSettings?.email || '');
                const [instagram, setInstagram] = useState(initialSettings?.instagramLink || '');
                const [whatsapp, setWhatsapp] = useState(initialSettings?.whatsappLink || '');

                const fileInputRef = useRef(null);
                const fileInputRefSecondary = useRef(null);

                const handleLogoUpload = async (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        try {
                            const base64 = await fileToBase64(file);
                            setLogo(base64);
                        } catch (err) {
                            addToast("Error uploading logo", "error");
                        }
                    }
                };

                const handleSecondaryLogoUpload = async (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        try {
                            const base64 = await fileToBase64(file);
                            setSecondaryLogo(base64);
                        } catch (err) {
                            addToast("Error uploading secondary logo", "error");
                        }
                    }
                };

                const handleSave = () => {
                    const settings = {
                        logo,
                        secondaryLogo,
                        address,
                        locationLink,
                        phoneNumbers: phones.split('\n').map(p => p.trim()).filter(Boolean),
                        email,
                        instagramLink: instagram,
                        whatsappLink: whatsapp
                    };
                    onSave(settings);
                };

                return (
                    <div className="fixed inset-0 bg-black/70 backdrop-blur-sm flex items-center justify-center z-50 p-4 pt-16" onClick={onClose}>
                        <div className="bg-white dark:bg-slate-800 rounded-lg shadow-2xl w-full max-w-2xl max-h-[85vh] flex flex-col animate-slide-up" onClick={e => e.stopPropagation()}>
                            <header className="p-4 border-b border-slate-200 dark:border-slate-700 flex justify-between items-center">
                                <h2 className="text-xl font-bold text-slate-800 dark:text-white">{TRANSLATIONS.footerSettings}</h2>
                                <button onClick={onClose}><XMarkIcon className="w-6 h-6 text-slate-500 hover:text-red-500" /></button>
                            </header>

                            <div className="p-6 overflow-y-auto space-y-6">
                                {/* Logo Upload */}
                                <div className="flex flex-col gap-2">
                                    <label className="text-sm font-semibold text-slate-700 dark:text-slate-300">{TRANSLATIONS.brandLogo}</label>
                                    <div className="flex items-center gap-4">
                                        <div className="w-24 h-24 bg-slate-100 dark:bg-slate-700 rounded-lg flex items-center justify-center border border-slate-300 dark:border-slate-600 overflow-hidden relative group">
                                            {logo ? <img src={logo} className="w-full h-full object-contain" /> : <span className="text-xs text-slate-500">No Logo</span>}
                                            {logo && <button onClick={() => setLogo(null)} className="absolute inset-0 bg-black/50 opacity-0 group-hover:opacity-100 flex items-center justify-center text-white"><TrashIcon className="w-6 h-6" /></button>}
                                        </div>
                                        <button onClick={() => fileInputRef.current?.click()} className="px-4 py-2 bg-blue-100 text-blue-700 dark:bg-blue-900/40 dark:text-blue-300 rounded-md hover:bg-blue-200 dark:hover:bg-blue-900/60 font-semibold text-sm transition-colors border border-blue-200 dark:border-blue-700">Upload Logo</button>
                                        <input ref={fileInputRef} type="file" className="hidden" accept="image/*" onChange={handleLogoUpload} />
                                    </div>
                                </div>
                                {/* Secondary Logo Upload */}
                                <div className="flex flex-col gap-2">
                                    <label className="text-sm font-semibold text-slate-700 dark:text-slate-300">{TRANSLATIONS.secondaryLogo}</label>
                                    <div className="flex items-center gap-4">
                                        <div className="w-20 h-12 bg-slate-100 dark:bg-slate-700 rounded-md flex items-center justify-center border border-slate-300 dark:border-slate-600 overflow-hidden relative group">
                                            {secondaryLogo ? <img src={secondaryLogo} className="w-full h-full object-contain" /> : <span className="text-xs text-slate-500">No Logo</span>}
                                            {secondaryLogo && <button onClick={() => setSecondaryLogo(null)} className="absolute inset-0 bg-black/50 opacity-0 group-hover:opacity-100 flex items-center justify-center text-white"><TrashIcon className="w-5 h-5" /></button>}
                                        </div>
                                        <button onClick={() => fileInputRefSecondary.current?.click()} className="px-3 py-1 bg-blue-100 text-blue-700 dark:bg-blue-900/40 dark:text-blue-300 rounded-md hover:bg-blue-200 dark:hover:bg-blue-900/60 font-semibold text-sm transition-colors border border-blue-200 dark:border-blue-700">Upload</button>
                                        <input ref={fileInputRefSecondary} type="file" className="hidden" accept="image/*" onChange={handleSecondaryLogoUpload} />
                                    </div>
                                </div>

                                <div className="grid grid-cols-1 gap-4">
                                    <div>
                                        <label className="block text-sm font-semibold mb-1 text-slate-700 dark:text-slate-300">{TRANSLATIONS.address}</label>
                                        <textarea value={address} onChange={e => setAddress(e.target.value)} className="w-full p-2 rounded-md border border-slate-300 dark:border-slate-600 dark:bg-slate-700/50 min-h-[80px] text-sm focus:ring-blue-500 focus:outline-none dark:text-slate-100" placeholder="Enter full address..." dir="rtl"></textarea>
                                    </div>
                                    <div>
                                        <label className="block text-sm font-semibold mb-1 text-slate-700 dark:text-slate-300">{TRANSLATIONS.phoneNumbers} (Enter one per line)</label>
                                        <textarea value={phones} onChange={e => setPhones(e.target.value)} className="w-full p-2 rounded-md border border-slate-300 dark:border-slate-600 dark:bg-slate-700/50 min-h-[80px] text-sm font-mono focus:ring-blue-500 focus:outline-none dark:text-slate-100" placeholder="021-12345678&#10;0912-3456789"></textarea>
                                    </div>
                                </div>

                                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                                    <div>
                                        <label className="block text-sm font-semibold mb-1 text-slate-700 dark:text-slate-300">{TRANSLATIONS.locationLink} (Google Maps)</label>
                                        <input type="text" value={locationLink} onChange={e => setLocationLink(e.target.value)} className="w-full p-2 rounded-md border border-slate-300 dark:border-slate-600 dark:bg-slate-700/50 text-sm focus:ring-blue-500 focus:outline-none dark:text-slate-100" placeholder="https://maps.google.com/..." />
                                    </div>
                                    <div>
                                        <label className="block text-sm font-semibold mb-1 text-slate-700 dark:text-slate-300">Email</label>
                                        <input type="email" value={email} onChange={e => setEmail(e.target.value)} className="w-full p-2 rounded-md border border-slate-300 dark:border-slate-600 dark:bg-slate-700/50 text-sm focus:ring-blue-500 focus:outline-none dark:text-slate-100" placeholder="info@example.com" />
                                    </div>
                                </div>

                                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                                    <div>
                                        <label className="block text-sm font-semibold mb-1 text-slate-700 dark:text-slate-300">Instagram Link</label>
                                        <input type="text" value={instagram} onChange={e => setInstagram(e.target.value)} className="w-full p-2 rounded-md border border-slate-300 dark:border-slate-600 dark:bg-slate-700/50 text-sm focus:ring-blue-500 focus:outline-none dark:text-slate-100" placeholder="https://instagram.com/..." />
                                    </div>
                                    <div>
                                        <label className="block text-sm font-semibold mb-1 text-slate-700 dark:text-slate-300">WhatsApp Link (e.g. https://wa.me/number)</label>
                                        <input type="text" value={whatsapp} onChange={e => setWhatsapp(e.target.value)} className="w-full p-2 rounded-md border border-slate-300 dark:border-slate-600 dark:bg-slate-700/50 text-sm focus:ring-blue-500 focus:outline-none dark:text-slate-100" placeholder="https://wa.me/98912..." />
                                    </div>
                                </div>
                            </div>
                            <footer className="p-4 border-t border-slate-200 dark:border-slate-700 flex justify-end gap-2">
                                <button onClick={onClose} className="px-4 py-2 bg-slate-200 dark:bg-slate-700 rounded-md hover:bg-slate-300 dark:hover:bg-slate-600 font-semibold transition-colors text-slate-700 dark:text-slate-200">{TRANSLATIONS.cancel}</button>
                                <button onClick={handleSave} className="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-500 font-semibold transition-colors">{TRANSLATIONS.save}</button>
                            </footer>
                        </div>
                    </div>
                );
            }

            // --- AUDIO & AI ASSISTANT COMPONENTS ---
            function encode(bytes) {
                let binary = '';
                const len = bytes.byteLength;
                for (let i = 0; i < len; i++) {
                    binary += String.fromCharCode(bytes[i]);
                }
                return btoa(binary);
            }

            function decode(base64) {
                const binaryString = atob(base64);
                const len = binaryString.length;
                const bytes = new Uint8Array(len);
                for (let i = 0; i < len; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                return bytes;
            }

            async function decodeAudioData(data, ctx, sampleRate, numChannels) {
                const dataInt16 = new Int16Array(data.buffer);
                const frameCount = dataInt16.length / numChannels;
                const buffer = ctx.createBuffer(numChannels, frameCount, sampleRate);

                for (let channel = 0; channel < numChannels; channel++) {
                    const channelData = buffer.getChannelData(channel);
                    for (let i = 0; i < frameCount; i++) {
                        channelData[i] = dataInt16[i * numChannels + channel] / 32768.0;
                    }
                }
                return buffer;
            }

            function createBlob(data) {
                const l = data.length;
                const int16 = new Int16Array(l);
                for (let i = 0; i < l; i++) {
                    int16[i] = data[i] * 32768;
                }
                return {
                    data: encode(new Uint8Array(int16.buffer)),
                    mimeType: 'audio/pcm;rate=16000',
                };
            }

            function AssistantModal({ isOpen, onClose, aiInstance, addToast, setView, performSearch, setSearchTerm }) {
                if (!isOpen) return null;

                const [status, setStatus] = useState('initializing');
                const [transcription, setTranscription] = useState({ input: '', output: '', history: [] });
                const [errorMessage, setErrorMessage] = useState('');

                const sessionPromiseRef = useRef(null);
                const inputAudioContextRef = useRef(null);
                const outputAudioContextRef = useRef(null);
                const streamRef = useRef(null);
                const scriptProcessorRef = useRef(null);
                const sourceNodeRef = useRef(null);
                const nextStartTimeRef = useRef(0);
                const outputSourcesRef = useRef(new Set());

                const { Type, Modality } = window.genai || {};

                const endSession = useCallback((shouldCloseModal = false) => {
                    sessionPromiseRef.current?.then(session => session.close()).catch(e => console.error("Error closing session:", e));
                    sessionPromiseRef.current = null;

                    streamRef.current?.getTracks().forEach(track => track.stop());
                    streamRef.current = null;

                    sourceNodeRef.current?.disconnect();
                    scriptProcessorRef.current?.disconnect();
                    sourceNodeRef.current = null;
                    scriptProcessorRef.current = null;

                    inputAudioContextRef.current?.close().catch(e => { });
                    outputAudioContextRef.current?.close().catch(e => { });
                    inputAudioContextRef.current = null;
                    outputAudioContextRef.current = null;

                    outputSourcesRef.current.forEach(source => source.stop());
                    outputSourcesRef.current.clear();
                    nextStartTimeRef.current = 0;

                    setStatus('idle');
                    if (shouldCloseModal) {
                        onClose();
                    }
                }, [onClose]);

                const startSession = useCallback(async () => {
                    setErrorMessage('');

                    if (!aiInstance || !navigator.mediaDevices?.getUserMedia) {
                        const msg = TRANSLATIONS.voiceSearchError;
                        addToast(msg, 'error');
                        setErrorMessage(msg);
                        setStatus('error');
                        return;
                    }
                    if (!Type || !Modality) {
                        const msg = TRANSLATIONS.aiServiceLoadError;
                        addToast(msg, 'error');
                        setErrorMessage(msg);
                        setStatus('error');
                        return;
                    }
                    setStatus('connecting');

                    try {
                        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                        streamRef.current = stream;

                        inputAudioContextRef.current = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 16000 });
                        outputAudioContextRef.current = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 24000 });

                        const searchTool = {
                            functionDeclarations: [{
                                name: 'searchCatalog',
                                description: 'Searches the furniture catalog for products based on a query.',
                                parameters: {
                                    type: Type.OBJECT,
                                    properties: {
                                        query: {
                                            type: Type.STRING,
                                            description: 'The search term, like "red sofa" or "Carpanelli tables".',
                                        },
                                    },
                                    required: ['query'],
                                },
                            }],
                        };

                        sessionPromiseRef.current = aiInstance.live.connect({
                            model: 'gemini-2.5-flash-native-audio-preview-09-2025',
                            config: {
                                responseModalities: [Modality.AUDIO],
                                inputAudioTranscription: {},
                                outputAudioTranscription: {},
                                tools: [searchTool],
                                systemInstruction: `You are an expert catalog search assistant for GALSTIAN furniture. Your goal is to help users find specific PRODUCTS by using the 'searchCatalog' tool. Follow these rules strictly:
1. **Translate to English:** If the user speaks in any language other than English (e.g., Persian), you MUST first translate their core request into a simple English search query.
2. **Simplify Query:** Before searching, simplify the English query. Convert plural nouns to singular (e.g., "sofas" becomes "sofa", "tables" becomes "table"). Remove filler words and ignore punctuation or special characters. The goal is a concise keyword query. For example, "Can you show me the Carpanelli dining tables?" becomes "Carpanelli dining table".
3. **Use the Tool:** Always use the 'searchCatalog' tool with the simplified, singular, English query to search through all product information, including names and descriptions.
4. **Be Brief:** Keep your spoken audio responses very short. After performing a search, just confirm the action verbally.
5. **No Guessing:** Do not make up information about products.`,
                            },
                            callbacks: {
                                onopen: () => {
                                    setStatus('listening');
                                    const source = inputAudioContextRef.current.createMediaStreamSource(stream);
                                    const scriptProcessor = inputAudioContextRef.current.createScriptProcessor(4096, 1, 1);
                                    scriptProcessor.onaudioprocess = (audioProcessingEvent) => {
                                        const inputData = audioProcessingEvent.inputBuffer.getChannelData(0);
                                        const pcmBlob = createBlob(inputData);
                                        sessionPromiseRef.current?.then((session) => {
                                            session.sendRealtimeInput({ media: pcmBlob });
                                        });
                                    };
                                    source.connect(scriptProcessor);
                                    scriptProcessor.connect(inputAudioContextRef.current.destination);
                                    sourceNodeRef.current = source;
                                    scriptProcessorRef.current = scriptProcessor;
                                },
                                onmessage: async (message) => {
                                    if (message.serverContent?.inputTranscription) {
                                        setTranscription(prev => ({ ...prev, input: prev.input + message.serverContent.inputTranscription.text }));
                                    }
                                    if (message.serverContent?.outputTranscription) {
                                        setTranscription(prev => ({ ...prev, output: prev.output + message.serverContent.outputTranscription.text }));
                                    }
                                    if (message.serverContent?.turnComplete) {
                                        setTranscription(prev => {
                                            const newHistory = [...prev.history];
                                            if (prev.input.trim()) newHistory.push({ speaker: 'user', text: prev.input.trim() });
                                            if (prev.output.trim()) newHistory.push({ speaker: 'model', text: prev.output.trim() });
                                            return { input: '', output: '', history: newHistory };
                                        });
                                    }

                                    if (message.toolCall) {
                                        for (const fc of message.toolCall.functionCalls) {
                                            if (fc.name === 'searchCatalog' && fc.args.query) {
                                                addToast(`${TRANSLATIONS.aiNavigating} for "${fc.args.query}"`, 'info');
                                                setSearchTerm(fc.args.query);
                                                performSearch(fc.args.query);
                                                sessionPromiseRef.current.then(session => session.sendToolResponse({ functionResponses: { id: fc.id, name: fc.name, response: { result: 'ok' } } }));
                                                endSession(true);
                                            }
                                        }
                                    }

                                    const audioData = message.serverContent?.modelTurn?.parts[0]?.inlineData?.data;
                                    if (audioData) {
                                        setStatus('speaking');
                                        const outputCtx = outputAudioContextRef.current;
                                        nextStartTimeRef.current = Math.max(nextStartTimeRef.current, outputCtx.currentTime);
                                        const audioBuffer = await decodeAudioData(decode(audioData), outputCtx, 24000, 1);
                                        const source = outputCtx.createBufferSource();
                                        source.buffer = audioBuffer;
                                        source.connect(outputCtx.destination);

                                        source.addEventListener('ended', () => {
                                            outputSourcesRef.current.delete(source);
                                            if (outputSourcesRef.current.size === 0) {
                                                setStatus('listening');
                                            }
                                        });

                                        source.start(nextStartTimeRef.current);
                                        nextStartTimeRef.current += audioBuffer.duration;
                                        outputSourcesRef.current.add(source);
                                    }
                                },
                                onerror: (e) => {
                                    console.error('Live session error:', e);
                                    const msg = TRANSLATIONS.assistantStatusError;
                                    addToast(msg, 'error');
                                    setErrorMessage(msg);
                                    setStatus('error');
                                    endSession();
                                },
                                onclose: () => {
                                    setStatus('idle');
                                },
                            }
                        });
                    } catch (err) {
                        console.error('Assistant session start error:', err);
                        if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') {
                            const msg = TRANSLATIONS.voicePermissionError;
                            addToast(msg, 'error');
                            setErrorMessage(msg);
                        } else {
                            const msg = TRANSLATIONS.assistantStatusError;
                            addToast(msg, 'error');
                            setErrorMessage(msg);
                        }
                        setStatus('error');
                    }
                }, [aiInstance, addToast, Type, Modality, performSearch, setSearchTerm, endSession]);

                useEffect(() => {
                    if (isOpen) {
                        startSession();
                    }
                    return () => {
                        endSession();
                    };
                }, [isOpen, startSession, endSession]);

                const statusText = {
                    connecting: TRANSLATIONS.assistantStatusConnecting,
                    listening: TRANSLATIONS.assistantStatusListening,
                    speaking: TRANSLATIONS.assistantStatusSpeaking,
                    error: TRANSLATIONS.assistantStatusError,
                    initializing: TRANSLATIONS.assistantStatusConnecting,
                    idle: TRANSLATIONS.assistantStatusIdle,
                }[status];

                return (
                    <div className="fixed inset-0 bg-black/70 backdrop-blur-sm flex items-center justify-center z-50 p-4" onClick={() => endSession(true)}>
                        <div className="assistant-modal-glow w-full max-w-lg" onClick={e => e.stopPropagation()}>
                            <div className="bg-white dark:bg-slate-800/95 backdrop-blur-2xl rounded-lg shadow-2xl w-full h-[60vh] max-h-[700px] flex flex-col animate-slide-up text-slate-800 dark:text-slate-200">
                                <header className="p-4 border-b border-slate-200 dark:border-slate-700 flex justify-between items-center flex-shrink-0">
                                    <h2 className="text-xl font-bold text-indigo-500 dark:text-indigo-400">{TRANSLATIONS.assistantTitle}</h2>
                                    <button onClick={() => endSession(true)} className="text-slate-500 dark:text-slate-400 hover:text-slate-800 dark:hover:text-white"><XMarkIcon /></button>
                                </header>

                                <div className="flex-grow overflow-y-auto p-4 space-y-4">
                                    {status === 'error' ? (
                                        <div className="flex flex-col items-center justify-center h-full text-center">
                                            <div className="w-16 h-16 bg-red-100 dark:bg-red-900/50 rounded-full flex items-center justify-center mb-4">
                                                <svg xmlns="http://www.w3.org/2000/svg" className="h-8 w-8 text-red-500" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
                                            </div>
                                            <p className="font-semibold text-red-600 dark:text-red-400">{errorMessage || TRANSLATIONS.assistantStatusError}</p>
                                            {errorMessage === TRANSLATIONS.voicePermissionError && (
                                                <p className="text-sm text-slate-500 dark:text-slate-400 mt-2">To use the voice assistant, you need to grant microphone access in your browser's site settings.</p>
                                            )}
                                        </div>
                                    ) : (
                                        <>
                                            {transcription.history.map((turn, index) => (
                                                <div key={index} className={`flex ${turn.speaker === 'user' ? 'justify-end' : 'justify-start'}`}>
                                                    <div className={`max-w-[80%] rounded-lg px-3 py-2 ${turn.speaker === 'user' ? 'bg-blue-600 text-white' : 'bg-slate-200 dark:bg-slate-700'}`}>
                                                        {turn.text}
                                                    </div>
                                                </div>
                                            ))}
                                            {transcription.input && <div className="flex justify-end"><div className="max-w-[80%] rounded-lg px-3 py-2 bg-blue-600/50 text-white">{transcription.input}</div></div>}
                                            {transcription.output && <div className="flex justify-start"><div className="max-w-[80%] rounded-lg px-3 py-2 bg-slate-200/50 dark:bg-slate-700/50">{transcription.output}</div></div>}
                                        </>
                                    )}
                                </div>

                                <footer className="p-4 border-t border-slate-200 dark:border-slate-700 flex-shrink-0 flex flex-col items-center justify-center gap-3">
                                    <div className={`w-16 h-16 rounded-full flex items-center justify-center transition-colors ${status === 'listening' ? 'bg-red-500' : 'bg-blue-500'}`}>
                                        <MicrophoneIcon className="w-8 h-8 text-white" />
                                    </div>
                                    <p className="text-sm text-center text-slate-500 dark:text-slate-400 h-5">{statusText}</p>
                                    <button onClick={() => endSession(true)} className="mt-2 text-sm text-slate-500 dark:text-slate-400 hover:text-slate-800 dark:hover:text-white">{TRANSLATIONS.endConversation}</button>
                                </footer>
                            </div>
                        </div>
                    </div>
                );
            }

            // --- MAIN APP COMPONENT ---
            function App() {
                const [isLoading, setIsLoading] = useState(true);
                const [loadingMessage, setLoadingMessage] = useState(TRANSLATIONS.loading);
                const [appTitle, setAppTitle] = useState(TRANSLATIONS.appName);
                const [isManagementMode, setIsManagementMode] = useState(false);
                const [view, setView] = useState({ type: 'brands' });

                // Homepage-specific states
                const [allBrands, setAllBrands] = useState([]);
                const [allCategories, setAllCategories] = useState([]);
                const [welcomeImages, setWelcomeImages] = useState([]);
                const [welcomeVideo, setWelcomeVideo] = useState(null); // This is the PROMOTIONAL video
                const [welcomeBackgroundType, setWelcomeBackgroundType] = useState('photos');
                const [welcomeBackgroundVideo, setWelcomeBackgroundVideo] = useState(null);
                const [heroMediaBlock, setHeroMediaBlock] = useState(null);

                const [currentItems, setCurrentItems] = useState([]);
                const [breadcrumbs, setBreadcrumbs] = useState([]);
                const [modal, setModal] = useState({ isOpen: false });
                const [confirmModal, setConfirmModal] = useState({ isOpen: false });
                const [searchTerm, setSearchTerm] = useState('');
                const [activeSearch, setActiveSearch] = useState('');
                const [isExportingExcel, setIsExportingExcel] = useState(false);
                const [isImporting, setIsImporting] = useState(false);
                const [isCameraSearchOpen, setIsCameraSearchOpen] = useState(false);
                const [isAiImageSearching, setIsAiImageSearching] = useState(false);
                const [isAiTextSearching, setIsAiTextSearching] = useState(false);
                const [isAssistantOpen, setIsAssistantOpen] = useState(false);
                const [toasts, setToasts] = useState([]);
                const [apiKey, setApiKey] = useState('');
                const [isApiKeyModalOpen, setIsApiKeyModalOpen] = useState(false);
                const [aiStatus, setAiStatus] = useState('initializing'); // 'initializing', 'ready', 'unavailable', 'error'
                const [isHeaderMenuOpen, setIsHeaderMenuOpen] = useState(false);
                const [lightboxImage, setLightboxImage] = useState(null);
                const [isWelcomeSettingsOpen, setIsWelcomeSettingsOpen] = useState(false);
                const [theme, setTheme] = useState(localStorage.getItem('catalog_theme') || 'dark');

                const [footerSettings, setFooterSettings] = useState(null);
                const [isFooterSettingsOpen, setIsFooterSettingsOpen] = useState(false);
                const [footerHeight, setFooterHeight] = useState(0);

                useEffect(() => {
                    try {
                        // Always apply bottom padding equal to footer height so user can scroll
                        // far enough to reveal the fixed footer from behind on small screens too.
                        if (footerHeight && mainContentRef?.current) {
                            mainContentRef.current.style.paddingBottom = `${footerHeight}px`;
                        } else if (mainContentRef?.current) {
                            mainContentRef.current.style.paddingBottom = '';
                        }
                    } catch (e) {
                        // ignore
                    }
                }, [footerHeight]);

                const mainContentRef = useRef(null);
                const jsonImportInputRef = useRef(null);
                const excelImportInputRef = useRef(null);
                const exitManagementClickCountRef = useRef(0);
                const exitManagementTimeoutRef = useRef(null);

                const lang = 'en'; // Hardcoded to English UI

                useEffect(() => {
                    const root = document.documentElement;
                    if (theme === 'light') {
                        root.classList.remove('dark');
                        root.classList.add('light');
                    } else {
                        root.classList.remove('light');
                        root.classList.add('dark');
                    }
                    localStorage.setItem('catalog_theme', theme);
                }, [theme]);

                useEffect(() => {
                    document.documentElement.classList.toggle('management-mode-active', isManagementMode);
                }, [isManagementMode]);

                useEffect(() => {
                    const isProductDetail = view.type === 'productDetail';

                    // Force native scrolling behavior based on view type
                    document.documentElement.style.overflowY = isProductDetail ? 'hidden' : 'auto';
                    document.documentElement.style.height = isProductDetail ? '100%' : 'auto';
                    document.body.style.overflowY = isProductDetail ? 'hidden' : 'auto';
                    document.body.style.height = isProductDetail ? '100%' : 'auto';

                    window.scrollTo(0, 0);
                }, [view]);

                const addToast = useCallback((message, type = 'info') => {
                    const id = Date.now() + Math.random();
                    setToasts(prev => [...prev, { id, message, type }]);
                }, []);

                const dismissToast = useCallback((id) => {
                    setToasts(prev => prev.filter(toast => toast.id !== id));
                }, []);

                const enterManagementMode = useCallback(() => {
                    localStorage.setItem('isManagementMode', 'true');
                    setIsManagementMode(true);
                    addToast("Showroom Mode Activated", "success");
                }, [addToast]);

                const handleExitManagementClick = useCallback(() => {
                    clearTimeout(exitManagementTimeoutRef.current);
                    exitManagementClickCountRef.current += 1;
                    if (exitManagementClickCountRef.current === 7) {
                        exitManagementClickCountRef.current = 0;
                        localStorage.removeItem('isManagementMode');
                        setIsManagementMode(false); // Set state directly
                        setView({ type: 'brands' });   // Reset view to default
                        addToast("Exiting Showroom Mode", "info");
                    } else {
                        exitManagementTimeoutRef.current = setTimeout(() => {
                            exitManagementClickCountRef.current = 0;
                        }, 1000);
                    }
                }, [addToast]);

                const exitManagementMode = useCallback(() => {
                    localStorage.removeItem('isManagementMode');
                    setIsManagementMode(false);
                    setView({ type: 'brands' });
                    addToast("Exiting Showroom Mode", "info");
                }, [addToast]);

                const refreshView = useCallback(async (newView) => {
                    // By removing the global `setIsLoading` toggle here, we prevent the UI from
                    // flickering during fast page transitions like navigating between categories.
                    // The main `initializeApp` handles the initial, full-page loading state.
                    if (newView.type === 'controlPanel') {
                        setView(newView);
                        setCurrentItems([]);
                        setBreadcrumbs([]);
                        return;
                    }

                    let newItems = [];
                    let newBreadcrumbs = [];

                    try {
                        if (newView.type === 'brands') {
                            const [brands, categories, products] = await Promise.all([
                                dbGetAll(STORES.BRANDS),
                                dbGetAll(STORES.CATEGORIES),
                                dbGetAll(STORES.PRODUCTS)
                            ]);
                            const categoriesWithImages = categories.map(cat => ({
                                ...cat,
                                productImages: products
                                    .filter(p => p.categoryId === cat.id && p.images && p.images.length > 0)
                                    .slice(0, 4)
                                    .map(p => p.images[0])
                            }));
                            setAllBrands(brands);
                            setAllCategories(categoriesWithImages);
                        } else if (newView.type === 'categories') {
                            const [categories, products] = await Promise.all([
                                dbGetByIndex(STORES.CATEGORIES, 'by_brand', newView.brandId),
                                dbGetByIndex(STORES.PRODUCTS, 'by_brand', newView.brandId)
                            ]);

                            newItems = categories.map(cat => ({
                                ...cat,
                                productImages: products
                                    .filter(p => p.categoryId === cat.id && p.images && p.images.length > 0)
                                    .slice(0, 4)
                                    .map(p => p.images[0])
                            }));
                            const brand = await dbGet(STORES.BRANDS, newView.brandId);
                            if (brand) newBreadcrumbs.push({ type: 'brand', id: brand.id, name: brand.name });
                        } else if (newView.type === 'products') {
                            newItems = await dbGetByIndex(STORES.PRODUCTS, 'by_category', newView.categoryId);
                            // Ensure products are shown in insertion order when possible
                            if (Array.isArray(newItems)) {
                                newItems.sort((a, b) => (Number(a.createdAt) || 0) - (Number(b.createdAt) || 0));
                            }
                            const brand = await dbGet(STORES.BRANDS, newView.brandId);
                            const category = await dbGet(STORES.CATEGORIES, newView.categoryId);
                            if (brand) newBreadcrumbs.push({ type: 'brand', id: brand.id, name: brand.name });
                            if (category) newBreadcrumbs.push({ type: 'category', id: category.id, name: category.name, context: { brandId: brand.id } });
                        } else if (newView.type === 'productDetail') {
                            let product = await dbGet(STORES.PRODUCTS, newView.productId);
                            // Conservative cleanup for single product view: only clean Persian name
                            if (product) {
                                try {
                                    if (product.name && product.name.fa) product.name.fa = cleanProductName(product.name.fa);
                                } catch (e) {
                                    // ignore
                                }

                                // Also try ASCII/Latin nested folders commonly used in uploaded_media (boloc2, boloc-2, boloc3, etc.)
                                try {
                                    const basename = (url || '').split('/').pop().split('?')[0];
                                    if (basename) {
                                        const asciiFolders = ['boloc2','boloc-2','boloc2','boloc3','boloc-3','bloc2','bloc3'];
                                        const basenameNoExt = basename.replace(/\.[^.]+$/, '');
                                        for (const af of asciiFolders) {
                                            const withOrigin = window.location.origin + '/uploaded_media/' + af + '/' + basename;
                                            if (!candidates.includes(withOrigin)) candidates.push(withOrigin);
                                            const withoutOrigin = 'uploaded_media/' + af + '/' + basename;
                                            if (!candidates.includes(withoutOrigin)) candidates.push(withoutOrigin);

                                            const withOriginNoExt = window.location.origin + '/uploaded_media/' + af + '/' + basenameNoExt;
                                            if (!candidates.includes(withOriginNoExt)) candidates.push(withOriginNoExt);
                                            const withoutOriginNoExt = 'uploaded_media/' + af + '/' + basenameNoExt;
                                            if (!candidates.includes(withoutOriginNoExt)) candidates.push(withoutOriginNoExt);
                                        }
                                    }
                                } catch (e) { /* ignore */ }

                                // If the URL is a basename or references uploaded_media, also
                                // try localized subfolder variants (e.g. uploaded_media/بلوک ۲/...).
                                try {
                                    const basename = (url || '').split('/').pop().split('?')[0];
                                    if (basename) {
                                        const persianFolders = ['بلوک ۲', 'بلوک ۳'];
                                        for (const pf of persianFolders) {
                                            const withOrigin = window.location.origin + '/uploaded_media/' + encodeURIComponent(pf) + '/' + encodeURIComponent(basename);
                                            if (!candidates.includes(withOrigin)) candidates.push(withOrigin);
                                            const withoutOrigin = 'uploaded_media/' + pf + '/' + basename;
                                            if (!candidates.includes(withoutOrigin)) candidates.push(withoutOrigin);
                                        }
                                    }
                                } catch (e) { /* ignore */ }
                            }
                            const brand = await dbGet(STORES.BRANDS, newView.brandId);
                            const category = await dbGet(STORES.CATEGORIES, newView.categoryId);
                            newItems = [product];
                            newView.product = product;
                            newView.category = category;
                            newView.brand = brand;
                            if (brand) newBreadcrumbs.push({ type: 'brand', id: brand.id, name: brand.name });
                            if (category) newBreadcrumbs.push({ type: 'category', id: category.id, name: category.name, context: { brandId: brand.id } });
                            if (product) newBreadcrumbs.push({ type: 'product', id: product.id, name: product.name, context: { brandId: brand.id, categoryId: category.id } });
                        } else if (newView.type === 'searchResults') {
                            newItems = newView.results;
                        }
                    } catch (error) {
                        console.error("Error refreshing view:", error);
                        addToast("Could not load data for the view.", 'error');
                    } finally {
                        setCurrentItems(newItems || []);
                        setBreadcrumbs(newBreadcrumbs);
                        setView(newView);
                    }
                }, [addToast, setView, setCurrentItems, setBreadcrumbs, setAllBrands, setAllCategories]);

                // --- DATA MIGRATION LOGIC ---
                const runMigration = useCallback(async () => {
                    const migrationFlag = await dbGet(STORES.CONFIG, 'migration_v1_complete');
                    if (migrationFlag?.value) return false;

                    setLoadingMessage(TRANSLATIONS.migratingData);

                    const dbs = await indexedDB.databases();
                    if (!dbs.some(db => db.name === LEGACY_DB_NAME)) {
                        await dbPut(STORES.CONFIG, { key: 'migration_v1_complete', value: true });
                        return false;
                    }

                    const legacyDBRequest = indexedDB.open(LEGACY_DB_NAME);
                    const legacyData = await new Promise((resolve, reject) => {
                        legacyDBRequest.onsuccess = (event) => {
                            const db = event.target.result;
                            if (!db.objectStoreNames.contains(LEGACY_STORE_NAME)) {
                                resolve(null);
                                return;
                            }
                            const tx = db.transaction(LEGACY_STORE_NAME, 'readonly');
                            const store = tx.objectStore(LEGACY_STORE_NAME);
                            const req = store.get(LEGACY_DATA_KEY);
                            req.onsuccess = () => resolve(req.result);
                            req.onerror = () => reject(req.error);
                        };
                        legacyDBRequest.onerror = (event) => reject(event.target.error);
                    });

                    if (legacyData && legacyData.brands) {
                        for (const brand of legacyData.brands) {
                            const { categories, ...brandData } = brand;
                            await dbPut(STORES.BRANDS, brandData);
                            if (categories) {
                                for (const category of categories) {
                                    const { products, ...categoryData } = category;
                                    await dbPut(STORES.CATEGORIES, { ...categoryData, brandId: brand.id });
                                    if (products) {
                                        for (const product of products) {
                                            await dbPut(STORES.PRODUCTS, { ...product, brandId: brand.id, categoryId: category.id });
                                        }
                                    }
                                }
                            }
                        }
                    }

                    await dbPut(STORES.CONFIG, { key: 'migration_v1_complete', value: true });
                    return true;
                }, []);

                const cleanAllProductNames = useCallback(async () => {
                    try {
                        const allProducts = await dbGetAll(STORES.PRODUCTS);
                        for (const product of allProducts) {
                            if (product.name) {
                                let changed = false;
                                let cleanedName = { ...product.name };
                                
                                // تمیز کردن نام انگلیسی
                                if (cleanedName.en) {
                                    const cleaned = cleanProductName(cleanedName.en);
                                    if (cleaned !== cleanedName.en) {
                                        cleanedName.en = cleaned;
                                        changed = true;
                                    }
                                }
                                
                                // تمیز کردن نام فارسی
                                if (cleanedName.fa) {
                                    const cleaned = cleanProductName(cleanedName.fa);
                                    if (cleaned !== cleanedName.fa) {
                                        cleanedName.fa = cleaned;
                                        changed = true;
                                    }
                                }
                                
                                // اگر نام تغییر کرد ذخیره کنید
                                if (changed) {
                                    await dbPut(STORES.PRODUCTS, { ...product, name: cleanedName });
                                }
                            }
                        }
                        return true;
                    } catch (error) {
                        console.error("Error cleaning product names:", error);
                        return false;
                    }
                }, []);

                const initializeApp = useCallback(async () => {
                    setIsLoading(true);
                    try {
                        const storedMode = localStorage.getItem('isManagementMode') === 'true';
                        setIsManagementMode(storedMode);

                        if (window.PRELOADED_DATA && !localStorage.getItem('catalog_preloaded_v1')) {
                            setLoadingMessage("Setting up catalog for the first time...");
                            const { data, config } = window.PRELOADED_DATA;
                            if (!data || !config) {
                                throw new Error("Preloaded data is in an invalid format.");
                            }

                            await Promise.all(Object.values(STORES).map(dbClear));

                            await Promise.all([
                                ...data.brands.map(item => dbPut(STORES.BRANDS, item)),
                                ...data.categories.map(item => dbPut(STORES.CATEGORIES, item)),
                                ...data.products.map(item => dbPut(STORES.PRODUCTS, item)),
                                dbPut(STORES.CONFIG, { key: 'app_title', value: config.app_title }),
                                dbPut(STORES.CONFIG, { key: 'welcome_images', value: config.welcome_images }),
                                dbPut(STORES.CONFIG, { key: 'welcome_video', value: config.welcome_video }),
                                dbPut(STORES.CONFIG, { key: 'welcome_background_type', value: config.welcome_background_type }),
                                dbPut(STORES.CONFIG, { key: 'welcome_background_video', value: config.welcome_background_video }),
                            ]);

                            localStorage.setItem('catalog_preloaded_v1', 'true');
                            setLoadingMessage(TRANSLATIONS.loading);
                        }

                        await runMigration();

                        // Note: automatic aggressive product-name cleanup and auto-reset
                        // have been disabled to avoid removing valid imported names.
                        console.log('Skipping automatic product-name optimization and DB auto-reset.');

                        const brandData = await dbGetAll(STORES.BRANDS);
                        if (brandData.length === 0) {
                            for (const brand of INITIAL_BRANDS) await dbPut(STORES.BRANDS, brand);
                            for (const category of INITIAL_CATEGORIES) await dbPut(STORES.CATEGORIES, category);
                            for (const product of INITIAL_PRODUCTS) await dbPut(STORES.PRODUCTS, product);
                        }

                        const correctTitle = "GALSTIAN";
                        await dbPut(STORES.CONFIG, { key: 'app_title', value: correctTitle });
                        setAppTitle(correctTitle);

                        const [imagesConfig, videoConfig, bgTypeConfig, bgVideoConfig, footerConfig, heroBlockConfig] = await Promise.all([
                            dbGet(STORES.CONFIG, 'welcome_images'),
                            dbGet(STORES.CONFIG, 'welcome_video'),
                            dbGet(STORES.CONFIG, 'welcome_background_type'),
                            dbGet(STORES.CONFIG, 'welcome_background_video'),
                            dbGet(STORES.CONFIG, 'footer_info'),
                            dbGet(STORES.CONFIG, 'hero_media_block')
                        ]);
                        setWelcomeImages(imagesConfig?.value || []);
                        setWelcomeVideo(videoConfig?.value || null);
                        // If welcome video is not set, probe common uploaded_media locations (prefer nested boloc3)
                        (async () => {
                            try {
                                if (!videoConfig?.value) {
                                    const candidates = [
                                        '/uploaded_media/boloc3/boloc3.mp4',
                                        '/uploaded_media/boloc3.mp4',
                                        '/uploaded_media/boloc-3.mp4',
                                        '/uploaded_media/bloc3.mp4'
                                    ];
                                    for (const c of candidates) {
                                        try {
                                            const full = c.startsWith('http') ? c : window.location.origin + c;
                                            const res = await fetch(full, { method: 'HEAD', cache: 'no-store' });
                                            if (res && res.ok) {
                                                setWelcomeVideo(c);
                                                try { await dbPut(STORES.CONFIG, { key: 'welcome_video', value: c }); } catch (e) { /* ignore */ }
                                                console.log('Seeded welcome_video with', c);
                                                break;
                                            }
                                        } catch (e) { /* ignore probe errors */ }
                                    }
                                }
                            } catch (e) { /* ignore */ }
                        })();
                        setWelcomeBackgroundType(bgTypeConfig?.value || 'photos');
                        setWelcomeBackgroundVideo(bgVideoConfig?.value || null);
                        setFooterSettings(footerConfig?.value || null);
                        // Ensure Block 2 (hero_media_block) has a usable video URL when missing.
                        // Non-invasive: only seeds the config if hero block is empty. Tries canonical
                        // filenames first, falls back to common mistyped names present in the repo.
                        let seededHero = null;
                        try {
                            const existingHero = heroBlockConfig?.value || null;
                            if (!existingHero || !existingHero.mediaUrl) {
                                const tryUrls = [
                                    '/uploaded_media/boloc2/boloc2.mp4',
                                    '/uploaded_media/boloc3/boloc3.mp4',
                                    '/uploaded_media/boloc-2.mp4',
                                    '/uploaded_media/boloc-3.mp4',
                                    '/uploaded_media/bloc2.mp4',
                                    '/uploaded_media/bloc3.mp4'
                                ];
                                let found = null;
                                for (const u of tryUrls) {
                                    try {
                                        const res = await fetch(u, { method: 'HEAD' });
                                        if (res && res.ok) { found = u; break; }
                                    } catch (e) {
                                        // ignore network errors for probing
                                    }
                                }
                                if (found) {
                                    // Preserve any existing heading/body when seeding the mediaUrl
                                    const existing = existingHero || {};
                                    seededHero = Object.assign({}, existing, { mediaType: 'video', mediaUrl: found });
                                    try { await dbPut(STORES.CONFIG, { key: 'hero_media_block', value: seededHero }); } catch (e) { console.warn('Failed to write seeded hero_media_block', e); }
                                }
                            }
                        } catch (e) {
                            console.warn('Hero seed probe failed', e);
                        }
                        setHeroMediaBlock(heroBlockConfig?.value || seededHero || null);
                        // If hero and welcome videos are swapped in the DB, fix them:
                        try {
                            const heroUrl = (heroBlockConfig?.value && heroBlockConfig.value.mediaUrl) || (seededHero && seededHero.mediaUrl) || null;
                            const welcomeUrl = videoConfig?.value || null;
                            const isHeroPointingTo3 = heroUrl && /bloc3\.mp4$|boloc-3\.mp4$/i.test(heroUrl);
                            const isWelcomePointingTo2 = welcomeUrl && /bloc2\.mp4$|boloc-2\.mp4$/i.test(welcomeUrl);
                            if (isHeroPointingTo3 && isWelcomePointingTo2) {
                                // Preserve existing hero heading/body when fixing swap
                                const existing = heroBlockConfig?.value || {};
                                const newHero = Object.assign({}, existing, { mediaType: 'video', mediaUrl: '/uploaded_media/bloc2.mp4' });
                                const newWelcome = '/uploaded_media/bloc3.mp4';
                                try { await dbPut(STORES.CONFIG, { key: 'hero_media_block', value: newHero }); } catch (e) { console.warn('Failed writing fixed hero_media_block', e); }
                                try { await dbPut(STORES.CONFIG, { key: 'welcome_video', value: newWelcome }); } catch (e) { console.warn('Failed writing fixed welcome_video', e); }
                                setHeroMediaBlock(newHero);
                                setWelcomeVideo(newWelcome);
                                console.log('Auto-fixed swapped media: hero->bloc2, welcome->bloc3');
                            }
                        } catch (e) {
                            console.warn('Auto-fix swap check failed', e);
                        }

                        // If hero text (heading/body) is missing, try to restore it from a local backup JSON in the repo.
                        try {
                            const currentHero = (heroBlockConfig && heroBlockConfig.value) || seededHero || null;
                            const needsHeading = !currentHero || !currentHero.heading;
                            const needsBody = !currentHero || !currentHero.body;
                            if ((needsHeading || needsBody)) {
                                const backupCandidates = [
                                    '/deploy/catalog_backup_lazy_2026-01-01T18-42-54-296Z.json',
                                    '/deploy/catalog_backup.json',
                                    '/deploy/backup-catalog-20251231144131.json',
                                    '/catalog_backup_lazy_2025-12-24T19-43-29-945Z.json',
                                    // Fallback to raw.githubusercontent in case Pages doesn't expose deploy/ files
                                    'https://raw.githubusercontent.com/amirpowerteam/galstian-catalog-1/main/deploy/catalog_backup_lazy_2026-01-01T18-42-54-296Z.json',
                                    'https://raw.githubusercontent.com/amirpowerteam/galstian-catalog-1/main/deploy/catalog_backup.json',
                                    'https://raw.githubusercontent.com/amirpowerteam/galstian-catalog-1/main/deploy/backup-catalog-20251231144131.json',
                                    'https://raw.githubusercontent.com/amirpowerteam/galstian-catalog-1/main/catalog_backup_lazy_2025-12-24T19-43-29-945Z.json'
                                ];
                                let backup = null;
                                for (const b of backupCandidates) {
                                    try {
                                        const r = await fetch(b);
                                        if (r && r.ok) { backup = await r.json(); break; }
                                    } catch (e) { /* ignore */ }
                                }
                                if (backup && backup.hero_media_block) {
                                    const from = backup.hero_media_block;
                                    const merged = Object.assign({}, currentHero || {}, {
                                        heading: currentHero?.heading || from.heading || null,
                                        body: currentHero?.body || from.body || null
                                    });
                                    try { await dbPut(STORES.CONFIG, { key: 'hero_media_block', value: merged }); } catch (e) { console.warn('Failed writing restored hero text', e); }
                                    setHeroMediaBlock(merged);
                                    console.log('Restored hero heading/body from local backup');
                                }
                            }
                        } catch (e) {
                            console.warn('Hero restore from backup failed', e);
                        }

                        await refreshView({ type: 'brands' });

                    } catch (error) {
                        console.error("Initialization Error:", error);
                        addToast(`Failed to initialize the catalog: ${error.message}`, 'error');
                    } finally {
                        setIsLoading(false);
                    }
                }, [runMigration, cleanAllProductNames, addToast, refreshView]);

                useEffect(() => {
                    initializeApp();
                }, [initializeApp]);

                useEffect(() => {
                    const savedKey = localStorage.getItem('gemini_api_key');
                    if (savedKey) {
                        setApiKey(savedKey);
                    }
                }, []);

                const handleSaveApiKey = (newKey) => {
                    localStorage.setItem('gemini_api_key', newKey);
                    setApiKey(newKey);
                    setIsApiKeyModalOpen(false);
                    addToast(TRANSLATIONS.apiKeySaved, 'success');
                };

                useEffect(() => {
                    if (!apiKey) {
                        setAiStatus('unavailable');
                        return;
                    }
                    setAiStatus('initializing');
                    let attempts = 0;
                    const interval = setInterval(() => {
                        attempts++;
                        if (window.genai && window.genai.GoogleGenAI) {
                            clearInterval(interval);
                            setAiStatus('ready');
                        } else if (attempts > 30) {
                            clearInterval(interval);
                            console.error("AI service script failed to load.", window.genai?.error);
                            addToast(TRANSLATIONS.aiServiceLoadError, 'error');
                            setAiStatus('error');
                        }
                    }, 250);
                    return () => clearInterval(interval);
                }, [apiKey, addToast]);


                const aiInstance = useMemo(() => {
                    if (aiStatus !== 'ready' || !apiKey || !window.genai?.GoogleGenAI) return null;
                    try {
                        const { GoogleGenAI } = window.genai;
                        return new GoogleGenAI({ apiKey: apiKey });
                    } catch (e) {
                        console.error("Failed to initialize GoogleGenAI:", e);
                        addToast("Failed to initialize AI. Invalid API key?", 'error');
                        setAiStatus('error');
                        return null;
                    }
                }, [aiStatus, apiKey, addToast]);

                const handleSaveWelcomeSettings = async ({ images, promoVideo, backgroundType, backgroundVideo, heroMediaBlock }) => {
                    try {
                        await dbPut(STORES.CONFIG, { key: 'welcome_images', value: images });
                        await dbPut(STORES.CONFIG, { key: 'welcome_video', value: promoVideo });
                        await dbPut(STORES.CONFIG, { key: 'welcome_background_type', value: backgroundType });
                        await dbPut(STORES.CONFIG, { key: 'welcome_background_video', value: backgroundVideo });
                        await dbPut(STORES.CONFIG, { key: 'hero_media_block', value: heroMediaBlock || null });
                        setWelcomeImages(images);
                        setWelcomeVideo(promoVideo);
                        setWelcomeBackgroundType(backgroundType);
                        setWelcomeBackgroundVideo(backgroundVideo);
                        setHeroMediaBlock(heroMediaBlock || null);
                        addToast('Welcome screen settings updated!', 'success');
                        setIsWelcomeSettingsOpen(false);
                    } catch (error) {
                        console.error("Failed to save welcome settings:", error);
                        addToast('Could not save welcome settings.', 'error');
                    }
                };

                const handleSaveFooterSettings = async (newSettings) => {
                    try {
                        await dbPut(STORES.CONFIG, { key: 'footer_info', value: newSettings });
                        setFooterSettings(newSettings);
                        addToast(TRANSLATIONS.apiKeySaved.replace('API Key', 'Footer settings'), 'success'); // Reusing or just string
                        setIsFooterSettingsOpen(false);
                    } catch (error) {
                        console.error("Failed to save footer settings:", error);
                        addToast('Could not save footer settings.', 'error');
                    }
                };

                const handleWipeAllData = useCallback(async () => {
                    try {
                        await Promise.all([
                            dbClear(STORES.BRANDS),
                            dbClear(STORES.CATEGORIES),
                            dbClear(STORES.PRODUCTS),
                            dbClear(STORES.CONFIG),
                        ]);
                        // After clearing, reset preloaded flag to allow re-import from file if available
                        localStorage.removeItem('catalog_preloaded_v1');
                        addToast(TRANSLATIONS.dataWiped, 'success');
                        // Reload the entire app to a clean state
                        window.location.reload();
                    } catch (error) {
                        console.error("Data wipe error:", error);
                        addToast(TRANSLATIONS.dataWipeError, 'error');
                    }
                    closeConfirm();
                }, [addToast]);

                const openModal = (type, mode, itemData = null, context = {}, onSuccess = null) => {
                    setModal({ isOpen: true, type, mode, data: itemData, context, key: Date.now(), onSuccess });
                };

                const closeModal = () => setModal({ isOpen: false });

                const openConfirm = (config) => {
                    setConfirmModal({ isOpen: true, ...config });
                };

                const closeConfirm = () => setConfirmModal({ isOpen: false });

                const handleDelete = useCallback(async (type, ids) => {
                    try {
                        if (type === 'brand') {
                            const categories = await dbGetByIndex(STORES.CATEGORIES, 'by_brand', ids.brandId);
                            for (const category of categories) {
                                const products = await dbGetByIndex(STORES.PRODUCTS, 'by_category', category.id);
                                for (const product of products) {
                                    await dbDelete(STORES.PRODUCTS, product.id);
                                }
                                await dbDelete(STORES.CATEGORIES, category.id);
                            }
                            await dbDelete(STORES.BRANDS, ids.brandId);
                        } else if (type === 'category') {
                            const products = await dbGetByIndex(STORES.PRODUCTS, 'by_category', ids.categoryId);
                            for (const product of products) {
                                await dbDelete(STORES.PRODUCTS, product.id);
                            }
                            await dbDelete(STORES.CATEGORIES, ids.categoryId);
                        } else if (type === 'product') {
                            await dbDelete(STORES.PRODUCTS, ids.productId);
                        }
                        addToast("Item deleted successfully.", 'success');
                        if (view.type !== 'controlPanel') {
                            await refreshView(view);
                        }
                    } catch (error) {
                        console.error("Failed to delete item:", error);
                        addToast(`Failed to delete item: ${error.message}`, 'error');
                    }
                    closeConfirm();
                    return Promise.resolve();
                }, [view, addToast, refreshView]);

                const handleSave = async (type, itemData, context) => {
                    try {
                        if (type === 'brand') {
                            await dbPut(STORES.BRANDS, itemData);
                        } else if (type === 'category') {
                            await dbPut(STORES.CATEGORIES, { ...itemData, brandId: context.brandId });
                        } else if (type === 'product') {
                            // Clean product name before saving
                            const dataToSave = { ...itemData, brandId: context.brandId, categoryId: context.categoryId };
                            if (dataToSave.name) {
                                if (dataToSave.name.en) dataToSave.name.en = String(dataToSave.name.en).trim();
                                if (dataToSave.name.fa) dataToSave.name.fa = cleanProductName(dataToSave.name.fa);
                            }

                            // Prevent duplicate IDs:
                            // - On add (modal.mode === 'add'): if the generated id already exists, generate a new one (safe, non-destructive).
                            // - On edit: if user changed the id to an existing id, refuse save and show error.
                            try {
                                if (modal?.mode === 'add') {
                                    const exists = await dbGet(STORES.PRODUCTS, dataToSave.id);
                                    if (exists) {
                                        // Try a few times to generate a truly unique id
                                        let newId = null;
                                        for (let i = 0; i < 8; i++) {
                                            const candidate = generateId();
                                            // ensure candidate doesn't exist
                                            // eslint-disable-next-line no-await-in-loop
                                            const cExists = await dbGet(STORES.PRODUCTS, candidate);
                                            if (!cExists) { newId = candidate; break; }
                                        }
                                        if (!newId) {
                                            addToast('Could not generate unique ID — please try again.', 'error');
                                            throw new Error('ID collision');
                                        }
                                        dataToSave.id = newId;
                                        addToast('ID collision detected — generated a new unique ID.', 'info');
                                    }
                                } else if (modal?.mode === 'edit') {
                                    // If the user changed the id to one that exists and it's not the same record, block the save.
                                    const originalId = modal?.data?.id;
                                    if (dataToSave.id && originalId && dataToSave.id !== originalId) {
                                        const conflict = await dbGet(STORES.PRODUCTS, dataToSave.id);
                                        if (conflict) {
                                            addToast('Cannot change ID: the target ID already exists.', 'error');
                                            throw new Error('ID already exists');
                                        }
                                    }
                                }
                            } catch (idErr) {
                                console.error('ID check failed:', idErr);
                                throw idErr;
                            }

                            // Ensure new products record the creation time so listing
                            // order can follow the insertion sequence.
                            if (modal?.mode === 'add' && !dataToSave.createdAt) {
                                try { dataToSave.createdAt = Date.now(); } catch (e) { /* ignore */ }
                            }
                            await dbPut(STORES.PRODUCTS, dataToSave);
                        } else if (type === 'appTitle') {
                            await dbPut(STORES.CONFIG, { key: 'app_title', value: itemData.title });
                            setAppTitle(itemData.title);
                        }
                        if (view.type !== 'controlPanel') {
                            await refreshView(view);
                        } else if (modal.onSuccess) {
                            modal.onSuccess();
                        }
                    } catch (error) {
                        console.error("Failed to save data:", error);
                        addToast("Error saving data.", 'error');
                    } finally {
                        closeModal();
                    }
                };

                const performSearch = useCallback(async (query) => {
                    const searchQuery = (query || searchTerm).trim();
                    if (!searchQuery) {
                        await refreshView({ type: 'brands' });
                        setActiveSearch('');
                        return;
                    }

                    setActiveSearch(searchQuery);
                    setIsLoading(true);

                    try {
                        const allProducts = await dbGetAll(STORES.PRODUCTS);
                        const allCategories = await dbGetAll(STORES.CATEGORIES);
                        const allBrands = await dbGetAll(STORES.BRANDS);
                        const categoryMap = new Map(allCategories.map(c => [c.id, c]));
                        const brandMap = new Map(allBrands.map(b => [b.id, b]));

                        const normalize = (str) => {
                            if (!str || typeof str !== 'string') return '';
                            return str.toLowerCase().replace(/[\s-.]/g, '');
                        };

                        const stopWords = [
                            'brand', 'product', 'category', 'show', 'me', 'find', 'open', 'go', 'to', 'see', 'the', 'a', 'an', 'and', 'with', 'for', 'in', 'on',
                            'برند', 'محصول', 'دسته', 'بندی', 'نشون', 'بده', 'پیدا', 'کن', 'باز', 'برو', 'به', 'نمایش', 'با'
                        ];

                        const queryTerms = searchQuery.toLowerCase().split(/\s+/).filter(Boolean);
                        const filteredQueryTerms = queryTerms.filter(term => !stopWords.includes(term));
                        const finalQueryTerms = filteredQueryTerms.length > 0 ? filteredQueryTerms : queryTerms;

                        const normalizedTerms = finalQueryTerms.map(normalize);

                        const results = allProducts.filter(product => {
                            const brand = brandMap.get(product.brandId);
                            const category = categoryMap.get(product.categoryId);

                            const searchableText = [
                                product.name?.en, product.name?.fa,
                                product.description?.en, product.description?.fa,
                                brand?.name?.en, brand?.name?.fa,
                                category?.name?.en, category?.name?.fa,
                            ].filter(Boolean).map(normalize).join(' ');

                            return normalizedTerms.every(term => searchableText.includes(term));
                        }).map(product => ({ ...product, context: { brandId: product.brandId, categoryId: product.categoryId } }));

                        await refreshView({ type: 'searchResults', results, searchTerm: searchQuery });
                    } catch (error) {
                        console.error("Search failed:", error);
                        addToast("An error occurred during search.", 'error');
                    } finally {
                        setIsLoading(false);
                    }
                }, [searchTerm, refreshView, addToast]);

                const handleAiFeatureClick = (callback) => {
                    if (aiStatus === 'ready') {
                        callback();
                    } else {
                        openConfirm({
                            title: TRANSLATIONS.setApiKey,
                            message: TRANSLATIONS.apiKeyMissingMessage,
                            confirmText: TRANSLATIONS.setApiKey,
                            confirmClass: 'bg-blue-600 hover:bg-blue-500',
                            onConfirm: () => setIsApiKeyModalOpen(true)
                        });
                    }
                };

                const handleCaptureAndSearch = async (imageDataUrl) => {
                    setIsCameraSearchOpen(false);
                    handleAiFeatureClick(async () => {
                        setIsAiImageSearching(true);
                        addToast(TRANSLATIONS.aiSearching, 'info');
                        try {
                            if (!aiInstance) throw new Error("AI not initialized.");

                            const imagePart = { inlineData: { mimeType: 'image/jpeg', data: imageDataUrl.split(',')[1] } };
                            const textPart = { text: 'Analyze this image of a furniture item. Based on its style, color, and type, generate a concise search query of 2-4 keywords to find similar items in a catalog. For example: "classic wood armchair", "modern glass table".' };

                            const response = await aiInstance.models.generateContent({
                                model: 'gemini-3-flash-preview',
                                contents: { parts: [imagePart, textPart] },
                            });
                            const responseText = response.text?.replace(/["']/g, "").trim();

                            if (!responseText) {
                                addToast(TRANSLATIONS.aiProductDetectionError, 'warning');
                                return;
                            }

                            setSearchTerm(responseText);
                            await performSearch(responseText);

                        } catch (error) {
                            console.error("AI Image Search Error:", error);
                            addToast(TRANSLATIONS.aiSearchError, 'error');
                        } finally {
                            setIsAiImageSearching(false);
                        }
                    });
                };

                const handleImport = () => {
                    jsonImportInputRef.current?.click();
                };

                const handleImportFile = (event) => {
                    const file = event.target.files[0];
                    if (!file) return;

                    openConfirm({
                        title: TRANSLATIONS.importData,
                        message: TRANSLATIONS.importConfirm,
                        confirmText: TRANSLATIONS.import,
                        confirmClass: 'bg-blue-600 hover:bg-blue-500',
                        onConfirm: () => {
                            closeConfirm();
                            setIsImporting(true);

                            // Allow UI to render the loader
                            setTimeout(async () => {
                                try {
                                    const text = await file.text();
                                    const { data, config } = JSON.parse(text);

                                    if (!data || !config) throw new Error("Invalid format.");

                                    // Sanitize imported config: convert legacy placeholders or huge string markers to null
                                    const sanitizeValue = (v) => {
                                        if (v === undefined) return null;
                                        if (v === null) return null;
                                        if (typeof v === 'string') {
                                            // Ignore exported redaction placeholders (don't treat them as valid URLs/data)
                                            if (/^<<REDACTED/.test(v)) return null;
                                            // legacy placeholder format e.g. <<omitted-large-string:123KB>>
                                            if (/^<<omitted-large-string:/.test(v)) return null;
                                            // If string looks like a truncated 'data:' URI or file path but too long, drop it
                                            if ((v.length > 1000000 && !v.startsWith('data:')) || v.startsWith('file:')) return null;
                                            return v;
                                        }
                                        if (Array.isArray(v)) return v.map(sanitizeValue);
                                        if (typeof v === 'object') {
                                            const out = {};
                                            for (const k of Object.keys(v)) out[k] = sanitizeValue(v[k]);
                                            return out;
                                        }
                                        return v;
                                    };

                                    await Promise.all(Object.values(STORES).map(dbClear));

                                    await Promise.all([
                                        ...data.brands.map(item => dbPut(STORES.BRANDS, item)),
                                        ...data.categories.map(item => dbPut(STORES.CATEGORIES, item)),
                                        ...data.products.map(item => dbPut(STORES.PRODUCTS, item)),
                                        dbPut(STORES.CONFIG, { key: 'app_title', value: sanitizeValue(config.app_title) }),
                                            dbPut(STORES.CONFIG, { key: 'welcome_images', value: sanitizeValue(config.welcome_images) }),
                                            dbPut(STORES.CONFIG, { key: 'welcome_video', value: sanitizeValue(config.welcome_video) }),
                                            dbPut(STORES.CONFIG, { key: 'welcome_background_type', value: sanitizeValue(config.welcome_background_type) }),
                                            dbPut(STORES.CONFIG, { key: 'welcome_background_video', value: sanitizeValue(config.welcome_background_video) }),
                                            dbPut(STORES.CONFIG, { key: 'hero_media_block', value: sanitizeValue(config.hero_media_block) || null }),
                                            dbPut(STORES.CONFIG, { key: 'footer_info', value: sanitizeValue(config.footer_info) || null }),
                                    ]);

                                    // If the imported file contains embedded media, restore them into IndexedDB
                                    try {
                                        const embedded = config._embedded_media || null;
                                        if (embedded) {
                                                    if (embedded.welcome_video && embedded.welcome_video.dataUrl) {
                                                        await dbPut(STORES.CONFIG, { key: 'welcome_video', value: embedded.welcome_video.dataUrl });
                                                    }
                                                    if (embedded.welcome_background_video && embedded.welcome_background_video.dataUrl) {
                                                        await dbPut(STORES.CONFIG, { key: 'welcome_background_video', value: embedded.welcome_background_video.dataUrl });
                                                    }
                                                    if (embedded.hero_video && embedded.hero_video.dataUrl) {
                                                        // merge mediaUrl into hero_media_block if present
                                                        const existingHero = await dbGet(STORES.CONFIG, 'hero_media_block');
                                                        const heroVal = (existingHero && existingHero.value) ? existingHero.value : {};
                                                        heroVal.mediaUrl = embedded.hero_video.dataUrl;
                                                        // Ensure mediaType is set to 'video' so the UI renders a <video> tag
                                                        if (!heroVal.mediaType) heroVal.mediaType = 'video';
                                                        await dbPut(STORES.CONFIG, { key: 'hero_media_block', value: heroVal });
                                                    }
                                        }
                                    } catch (e) {
                                        console.warn('Failed restoring embedded media during import', e);
                                    }

                                    addToast(TRANSLATIONS.importSuccess, 'success');
                                    window.location.reload();
                                } catch (error) {
                                    console.error("Import Error:", error);
                                    addToast(TRANSLATIONS.importError, 'error');
                                    setIsImporting(false);
                                } finally {
                                    event.target.value = null;
                                }
                            }, 50);
                        }
                    });
                };

                const handleExport = async () => {
                    // Monkey-patch JSON.stringify temporarily to catch RangeError from any call
                    const _origStringify = JSON.stringify;
                    const safeStringify = (value, replacer, space) => {
                        try {
                            return _origStringify(value, replacer, space);
                        } catch (err) {
                            if (!(err instanceof RangeError)) throw err;
                            // Try to prune large strings and stringify again
                            try {
                                const { result: pruned } = pruneLargeStrings(value, 800000);
                                return _origStringify(pruned, replacer, space);
                            } catch (e2) {
                                throw err; // rethrow original
                            }
                        }
                    };
                    JSON.stringify = safeStringify;
                    try {
                        const [brands, categories, products, titleConf, imagesConf, videoConf, bgTypeConf, bgVidConf, heroBlockConf, footerConf] = await Promise.all([
                            dbGetAll(STORES.BRANDS),
                            dbGetAll(STORES.CATEGORIES),
                            dbGetAll(STORES.PRODUCTS),
                            dbGet(STORES.CONFIG, 'app_title'),
                            dbGet(STORES.CONFIG, 'welcome_images'),
                            dbGet(STORES.CONFIG, 'welcome_video'),
                            dbGet(STORES.CONFIG, 'welcome_background_type'),
                            dbGet(STORES.CONFIG, 'welcome_background_video'),
                            dbGet(STORES.CONFIG, 'hero_media_block'),
                            dbGet(STORES.CONFIG, 'footer_info'),
                        ]);

                        // Validate data exists
                        if (!products || !categories || !brands) {
                            addToast("Error: Could not retrieve catalog data.", 'error');
                            console.error("Data retrieval failed - some data is null");
                            return;
                        }

                        // Try to compress product images (data URLs) to keep them in backup but reduce size
                        const compressProductsImages = async (productsList) => {
                            const cloned = productsList.map(p => ({ ...p }));
                            const imageFieldCandidates = ['images', 'image', 'gallery', 'photos', 'thumb'];
                            for (const prod of cloned) {
                                for (const field of imageFieldCandidates) {
                                    if (!prod[field]) continue;
                                    try {
                                        if (Array.isArray(prod[field])) {
                                            for (let i = 0; i < prod[field].length; i++) {
                                                const v = prod[field][i];
                                                if (typeof v === 'string' && v.startsWith('data:image/') && v.length > 150000) {
                                                    prod[field][i] = await compressImageDataUrl(v, 1200, 1200, 0.75);
                                                }
                                            }
                                        } else if (typeof prod[field] === 'string' && prod[field].startsWith('data:image/') && prod[field].length > 150000) {
                                            prod[field] = await compressImageDataUrl(prod[field], 1200, 1200, 0.75);
                                        }
                                    } catch (e) {
                                        console.warn('Failed compressing product image for field', field, e);
                                    }
                                }
                            }
                            return cloned;
                        };

                        const productsForExport = await compressProductsImages(products || []);

                        // Include mediaUrl in export so external embed scripts can locate the hero video
                        // Include mediaUrl so external scripts can embed hero video into backups
                        const heroExport = heroBlockConf?.value ? {
                            heading: (heroBlockConf.value.heading || '').toString(),
                            body: (heroBlockConf.value.body || '').toString(),
                            mediaUrl: heroBlockConf.value.mediaUrl || null
                        } : null;

                        // Attempt to embed welcome/hero video files into the backup when available (<= 12MB per file).
                        const embeddedMedia = {};
                        // declare export candidate vars in outer scope so they're available after this try/catch
                        let welcomeVideoForExport = null;
                        let welcomeBackgroundVideoForExport = null;
                        let heroVideoForExport = null;
                        try {
                            const MAX_EMBED_BYTES = 12 * 1024 * 1024; // 12MB
                            const maybeFetchAsDataUrl = async (url) => {
                                if (!url) return null;
                                const allow = (typeof url === 'string') && (
                                    url.startsWith('data:') || url.startsWith('blob:') || url.startsWith('/') || url.startsWith('./') || url.includes('uploaded_media') || url.includes('assets')
                                );
                                if (!allow) return null;

                                const readBufferToDataUrl = (buf, srcUrl) => {
                                    if (!buf) return null;
                                    if (buf.byteLength > MAX_EMBED_BYTES) return null;
                                    let binary = '';
                                    const bytes = new Uint8Array(buf);
                                    const chunkSize = 0x8000;
                                    for (let i = 0; i < bytes.length; i += chunkSize) {
                                        binary += String.fromCharCode.apply(null, bytes.subarray(i, i + chunkSize));
                                    }
                                    const b64 = btoa(binary);
                                    const ext = (srcUrl.split('.').pop() || '').toLowerCase();
                                    const mime = ext === 'mp4' ? 'video/mp4' : ext === 'webm' ? 'video/webm' : 'application/octet-stream';
                                    return `data:${mime};base64,${b64}`;
                                };

                                const tryFetch = async (fetchUrl, options = {}) => {
                                    try {
                                        const resp = await fetch(fetchUrl, options);
                                        if (!resp || !resp.ok) return null;
                                        const buf = await resp.arrayBuffer();
                                        return readBufferToDataUrl(buf, fetchUrl);
                                    } catch (e) {
                                        return null;
                                    }
                                };

                                // If already a data: URI, return it (if within size cap)
                                if (typeof url === 'string' && url.startsWith('data:')) {
                                    return url.length <= MAX_EMBED_BYTES ? url : null;
                                }

                                // Build a list of candidate URLs to try (original, absolute, resolved)
                                const candidates = [url];
                                try {
                                    // If starts with '/', try origin-prefixed URL
                                    if (url.startsWith('/')) candidates.push(window.location.origin + url);
                                    // Try resolving relative URLs against current location
                                    try {
                                        const resolved = new URL(url, window.location.href).href;
                                        if (!candidates.includes(resolved)) candidates.push(resolved);
                                    } catch (e) { /* ignore invalid URL */ }
                                    // If url contains 'uploaded_media' without leading slash, try adding origin
                                    if (url.includes('uploaded_media') && !url.startsWith('/')) {
                                        const withOrigin = window.location.origin + (url.startsWith('.') ? url.slice(1) : '/' + url);
                                        if (!candidates.includes(withOrigin)) candidates.push(withOrigin);
                                    }
                                } catch (e) {
                                    // ignore
                                }

                                // Try each candidate: direct fetch (no-store), cache, busted, plain
                                for (const c of candidates) {
                                    let result = await tryFetch(c, { cache: 'no-store' });
                                    if (result) return result;

                                    // cache storage
                                    try {
                                        if (window.caches && caches.match) {
                                            const cachedResp = await caches.match(c);
                                            if (cachedResp && cachedResp.ok) {
                                                try {
                                                    const buf = await cachedResp.arrayBuffer();
                                                    const dataUrl = readBufferToDataUrl(buf, c);
                                                    if (dataUrl) return dataUrl;
                                                } catch (e) { /* ignore */ }
                                            }
                                        }
                                    } catch (e) { /* ignore cache errors */ }

                                    // cache-busted
                                    try {
                                        const sep = c.includes('?') ? '&' : '?';
                                        const busted = c + sep + '_cb=' + Date.now();
                                        result = await tryFetch(busted, { cache: 'reload' });
                                        if (result) return result;
                                    } catch (e) { /* ignore */ }

                                    // last attempt plain fetch
                                    result = await tryFetch(c);
                                    if (result) return result;
                                }

                                return null;
                            };

                            const welcomeVideoUrl = videoConf?.value || null;
                            const welcomeBackgroundVideoUrl = bgVidConf?.value || null;
                            let heroUrl = heroBlockConf?.value && heroBlockConf.value.mediaUrl ? heroBlockConf.value.mediaUrl : null;

                            // If heroUrl is not set, try common uploaded_media filenames so export can reference local video
                            if (!heroUrl) {
                                const candidates = [
                                    '/uploaded_media/boloc2/boloc2.mp4',
                                    '/uploaded_media/boloc3/boloc3.mp4',
                                    '/uploaded_media/boloc-2.mp4',
                                    '/uploaded_media/boloc-3.mp4',
                                    '/uploaded_media/bloc2.mp4',
                                    '/uploaded_media/bloc3.mp4'
                                ];
                                const tryHead = async (u) => {
                                    try {
                                        const full = u.startsWith('http') ? u : window.location.origin + u;
                                        const resp = await fetch(full, { method: 'HEAD', cache: 'no-store' });
                                        return resp && resp.ok;
                                    } catch (e) { return false; }
                                };
                                for (const c of candidates) {
                                    // eslint-disable-next-line no-await-in-loop
                                    const ok = await tryHead(c);
                                    if (ok) { heroUrl = c; break; }
                                }
                            }

                            // ensure heroExport.mediaUrl reflects resolved heroUrl (so export contains it)
                            try {
                                if (heroExport) heroExport.mediaUrl = heroUrl || null;
                            } catch (e) { /* ignore */ }

                            // If the stored value is already a data: URI for a video, treat it as embedded media
                            welcomeVideoForExport = (typeof welcomeVideoUrl !== 'undefined') ? welcomeVideoUrl : null;
                            welcomeBackgroundVideoForExport = (typeof welcomeBackgroundVideoUrl !== 'undefined') ? welcomeBackgroundVideoUrl : null;
                            heroVideoForExport = (typeof heroUrl !== 'undefined') ? heroUrl : null;
                            if (typeof welcomeVideoUrl === 'string' && welcomeVideoUrl.startsWith('data:')) {
                                // small safety cap: only embed if <= MAX_EMBED_BYTES
                                if (welcomeVideoUrl.length <= (12 * 1024 * 1024)) {
                                    embeddedMedia.welcome_video = { src: null, dataUrl: welcomeVideoUrl };
                                    welcomeVideoForExport = null;
                                } else {
                                    welcomeVideoForExport = null;
                                }
                            }
                            if (typeof heroUrl === 'string' && heroUrl.startsWith('data:')) {
                                if (heroUrl.length <= (12 * 1024 * 1024)) {
                                    embeddedMedia.hero_video = { src: null, dataUrl: heroUrl };
                                    heroVideoForExport = null;
                                } else {
                                    heroVideoForExport = null;
                                }
                            }

                            // If background video is a data: URI, treat similarly for embedding
                            if (typeof welcomeBackgroundVideoUrl === 'string' && welcomeBackgroundVideoUrl.startsWith('data:')) {
                                if (welcomeBackgroundVideoUrl.length <= (12 * 1024 * 1024)) {
                                    embeddedMedia.welcome_background_video = { src: null, dataUrl: welcomeBackgroundVideoUrl };
                                    welcomeBackgroundVideoForExport = null;
                                } else {
                                    welcomeBackgroundVideoForExport = null;
                                }
                            }

                            // If hero video URL missing, try common uploaded_media filenames and embed the first reachable one
                            if (!heroVideoForExport) {
                                const commonCandidates = [
                                    'uploaded_media/bloc2.mp4', 'uploaded_media/bloc2',
                                    'uploaded_media/bloc3.mp4', 'uploaded_media/bloc3',
                                    'uploaded_media/boloc-2.mp4', 'uploaded_media/boloc-2',
                                    'uploaded_media/boloc-3.mp4', 'uploaded_media/boloc-3',
                                    'uploaded_media/بلوک ۲/bloc2.mp4', 'uploaded_media/بلوک ۲/bloc2',
                                    'uploaded_media/بلوک ۳/bloc3.mp4', 'uploaded_media/بلوک ۳/bloc3',
                                    'uploaded_media/بلوک ۲/boloc-2.mp4', 'uploaded_media/بلوک ۲/boloc-2',
                                    'uploaded_media/بلوک ۳/boloc-3.mp4', 'uploaded_media/بلوک ۳/boloc-3'
                                ];
                                for (const c of commonCandidates) {
                                    try {
                                        const resolved = c.startsWith('/') ? window.location.origin + c : new URL(c, window.location.href).href;
                                        const maybe = await maybeFetchAsDataUrl(resolved);
                                        if (maybe) {
                                            embeddedMedia.hero_video = { src: resolved, dataUrl: maybe };
                                            heroVideoForExport = null;
                                            // ensure export records mediaUrl as null since it's embedded
                                            if (heroExport) heroExport.mediaUrl = null;
                                            addToast('Included hero video in backup via automatic candidate match.', 'info');
                                            break;
                                        }
                                    } catch (e) { /* ignore and continue */ }
                                }
                            }

                            const wData = welcomeVideoForExport ? await maybeFetchAsDataUrl(welcomeVideoForExport) : null;
                            const bData = welcomeBackgroundVideoForExport ? await maybeFetchAsDataUrl(welcomeBackgroundVideoForExport) : null;
                            const hData = heroVideoForExport ? await maybeFetchAsDataUrl(heroVideoForExport) : null;
                            if (wData) embeddedMedia.welcome_video = { src: welcomeVideoUrl, dataUrl: wData };
                            if (bData) embeddedMedia.welcome_background_video = { src: welcomeBackgroundVideoUrl, dataUrl: bData };
                            if (hData) embeddedMedia.hero_video = { src: heroUrl, dataUrl: hData };
                            if (Object.keys(embeddedMedia).length) {
                                addToast('Including uploaded videos in backup (this may increase file size).', 'info');
                            }
                        } catch (e) {
                            console.warn('Embedding media failed', e);
                        }

                        const dataToExport = {
                            data: { brands, categories, products: productsForExport },
                            config: {
                                app_title: titleConf?.value || 'GALSTIAN',
                                welcome_images: imagesConf?.value || [],
                                welcome_video: videoConf?.value || null,
                                welcome_background_type: bgTypeConf?.value || 'photos',
                                welcome_background_video: welcomeBackgroundVideoForExport || null,
                                // Only keep hero text (heading/body) in export — include mediaUrl and optionally embed media
                                hero_media_block: heroExport,
                                // Embedded media (base64) - optional and may drastically grow backup size
                                _embedded_media: Object.keys(embeddedMedia).length ? embeddedMedia : undefined,
                                footer_info: footerConf?.value || null,
                            }
                        };

                        // Prevent JSON.stringify RangeError when catalog contains very large base64 media.
                        const MAX_STRING_LENGTH = 800000; // ~800KB threshold per string

                        const pruneLargeStrings = (obj, maxLen) => {
                            const omitted = [];
                            const seen = new WeakSet();

                            const clone = (value, path = '') => {
                                if (value && typeof value === 'object') {
                                    if (seen.has(value)) return value; // avoid circular
                                    seen.add(value);
                                    if (Array.isArray(value)) return value.map((v, i) => clone(v, path + '[' + i + ']'));
                                    const out = {};
                                    for (const k of Object.keys(value)) {
                                        out[k] = clone(value[k], path ? path + '.' + k : k);
                                    }
                                    return out;
                                }
                                // Never prune embedded media base64 blobs (we want to keep videos if present)
                                if (path && path.indexOf('root.config._embedded_media') === 0) return value;
                                if (typeof value === 'string' && value.length > maxLen) {
                                    omitted.push({ path, length: value.length });
                                    return null;
                                }
                                return value;
                            };

                            const result = clone(obj, 'root');
                            return { result, omitted };
                        };

                        const { result: prunedData, omitted } = pruneLargeStrings(dataToExport, MAX_STRING_LENGTH);
                        if (omitted && omitted.length) {
                            console.warn('Export: omitted large strings at paths:', omitted.slice(0,10));
                            addToast(`Export: omitted ${omitted.length} large media items to avoid oversized backup.`, 'warning');
                        }

                        // Sanitize potential secrets before exporting.
                        const SENSITIVE_KEY_RE = /api[_-]?key|token|secret|password|gemini|openai|authorization/i;
                        const GOOGLE_API_KEY_RE = /AIza[0-9A-Za-z\-_]{20,}/g;
                        const OPENAI_KEY_RE = /sk-[0-9a-zA-Z\-_]{16,}/g;

                        const scrubValue = (val, keyName) => {
                            if (typeof val === 'string') {
                                if (GOOGLE_API_KEY_RE.test(val) || OPENAI_KEY_RE.test(val) || /ya29\./.test(val)) return '<<REDACTED_SECRET>>';
                                return val;
                            }
                            if (Array.isArray(val)) return val.map(v => scrubValue(v));
                            if (val && typeof val === 'object') {
                                const out = {};
                                for (const k of Object.keys(val)) {
                                    try {
                                        if (SENSITIVE_KEY_RE.test(k)) {
                                            out[k] = '<<REDACTED_KEY>>';
                                        } else {
                                            out[k] = scrubValue(val[k], k);
                                        }
                                    } catch (e) {
                                        out[k] = null;
                                    }
                                }
                                return out;
                            }
                            return val;
                        };

                        const sanitized = scrubValue(prunedData);

                        const jsonString = JSON.stringify(sanitized, null, 2);
                        const blob = new Blob([jsonString], { type: 'application/json' });
                        const url = URL.createObjectURL(blob);

                        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                        const filename = `catalog_backup_lazy_${timestamp}.json`;

                        if (navigator.share && navigator.canShare && navigator.canShare({ files: [new File([blob], filename)] })) {
                            try {
                                await navigator.share({
                                    files: [new File([blob], filename, { type: 'application/json' })],
                                    title: 'Catalog Backup',
                                });
                                addToast("Backup shared successfully!", 'success');
                            } catch (error) {
                                if (error.name !== 'AbortError') {
                                    console.log('Share failed, falling back to download:', error);
                                    const a = document.createElement('a');
                                    a.href = url;
                                    a.download = filename;
                                    document.body.appendChild(a);
                                    a.click();
                                    document.body.removeChild(a);
                                    addToast("Backup downloaded successfully!", 'success');
                                }
                            }
                        } else {
                            const a = document.createElement('a');
                            a.href = url;
                            a.download = filename;
                            document.body.appendChild(a);
                            a.click();
                            document.body.removeChild(a);
                            addToast("Backup downloaded successfully!", 'success');
                        }
                        URL.revokeObjectURL(url);
                    } catch (error) {
                        console.error("Export failed:", error);
                        addToast("Failed to export data: " + (error.message || error), 'error');
                    } finally {
                        // restore original stringify
                        try { JSON.stringify = _origStringify; } catch (e) { /* ignore */ }
                    }
                };

                const handleExportToExcel = async () => {
                    console.log("=== EXPORT STARTED ===");
                    setIsExportingExcel(true);
                    try {
                        // Ensure SheetJS (XLSX) is loaded; if not, load it dynamically
                        const ensureXLSXLoaded = () => {
                            return new Promise((resolve, reject) => {
                                if (window.XLSX) return resolve();
                                const existing = document.querySelector('script[data-xlsx-loader]');
                                if (existing) {
                                    existing.addEventListener('load', () => window.XLSX ? resolve() : reject(new Error('XLSX missing after load')));
                                    existing.addEventListener('error', () => reject(new Error('Failed to load XLSX')));
                                    return;
                                }
                                // Try local copy first (assets/xlsx.full.min.js), then fall back to CDN
                                const tryLoad = (src) => {
                                    return new Promise((res, rej) => {
                                        const sc = document.createElement('script');
                                        sc.setAttribute('data-xlsx-loader', '1');
                                        sc.src = src;
                                        sc.onload = () => res(sc);
                                        sc.onerror = () => rej(new Error('Failed to load ' + src));
                                        document.head.appendChild(sc);
                                    });
                                };

                                tryLoad('assets/xlsx.full.min.js').then(() => {
                                    if (window.XLSX) return resolve();
                                    // local loaded but XLSX not present — try CDN
                                    return tryLoad('https://cdn.jsdelivr.net/npm/xlsx@0.18.9/dist/xlsx.full.min.js').then(() => window.XLSX ? resolve() : reject(new Error('XLSX missing after CDN load'))).catch(reject);
                                }).catch(() => {
                                    // local failed, try CDN
                                    tryLoad('https://cdn.jsdelivr.net/npm/xlsx@0.18.9/dist/xlsx.full.min.js').then(() => window.XLSX ? resolve() : reject(new Error('XLSX missing after CDN load'))).catch(reject);
                                });
                            });
                        };

                        let useCsvFallback = false;
                        try {
                            await ensureXLSXLoaded();
                        } catch (loadErr) {
                            console.warn('XLSX library not available, will fallback to CSV export:', loadErr);
                            addToast('Excel library not available — exporting CSV instead', 'warning');
                            useCsvFallback = true;
                        }

                        console.log("Step 1: Fetching data from database...");
                        const products = await dbGetAll(STORES.PRODUCTS);
                        console.log("Step 2: Got products:", products?.length);
                        
                        if (!products || products.length === 0) {
                            console.log("Step 3: No products found!");
                            addToast("No products to export.", 'warning');
                            setIsExportingExcel(false);
                            return;
                        }

                        if (useCsvFallback) {
                            addToast("Preparing CSV file...", 'info');
                            // Create simple CSV (UTF-8 BOM) for compatibility
                            let csvContent = "\uFEFF" + "ID,Product Name (EN),Product Name (FA),Price,Quantity\r\n";
                            products.forEach((p, idx) => {
                                const nameEn = (p.name?.en || '').replace(/"/g, '""');
                                const nameFa = (p.name?.fa || '').replace(/"/g, '""');
                                const row = `"${p.id}","${nameEn}","${nameFa}","${p.price || 0}","${p.quantity || 0}"`;
                                csvContent += row + "\r\n";
                                if (idx % 50 === 0) console.log(`Processing product ${idx}/${products.length}`);
                            });

                            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8' });
                            const link = document.createElement('a');
                            const url = URL.createObjectURL(blob);
                            link.href = url;
                            link.download = `catalog_${new Date().toISOString().split('T')[0]}.csv`;
                            document.body.appendChild(link);
                            link.click();
                            setTimeout(() => {
                                document.body.removeChild(link);
                                URL.revokeObjectURL(url);
                            }, 100);

                            addToast("✓ CSV file exported successfully!", 'success');
                            setIsExportingExcel(false);
                            return;
                        }

                        addToast("Preparing Excel file...", 'info');

                        // Create a proper .xlsx workbook using SheetJS (XLSX)
                        console.log("Step 4: Creating XLSX workbook...");

                        const headers = ['ID', 'Product Name (EN)', 'Product Name (FA)', 'Price', 'Quantity'];
                        const data = products.map((p, idx) => {
                            if (idx % 50 === 0) console.log(`Processing product ${idx}/${products.length}`);
                            return {
                                ID: p.id,
                                'Product Name (EN)': p.name?.en || '',
                                'Product Name (FA)': p.name?.fa || '',
                                Price: p.price || 0,
                                Quantity: p.quantity || 0
                            };
                        });

                        const worksheet = XLSX.utils.json_to_sheet(data, { header: headers });
                        const workbook = XLSX.utils.book_new();
                        XLSX.utils.book_append_sheet(workbook, worksheet, 'Products');

                        // Write workbook to binary array
                        const wbout = XLSX.write(workbook, { bookType: 'xlsx', type: 'array' });
                        const blob = new Blob([wbout], { type: 'application/octet-stream' });

                        console.log("Step 5: Workbook written, blob size:", blob.size);

                        // Create download link
                        const url = URL.createObjectURL(blob);
                        const link = document.createElement('a');
                        link.href = url;
                        link.download = `catalog_${new Date().toISOString().split('T')[0]}.xlsx`;
                        document.body.appendChild(link);
                        console.log("Step 6: Starting download...");
                        link.click();

                        // Cleanup
                        setTimeout(() => {
                            document.body.removeChild(link);
                            URL.revokeObjectURL(url);
                            console.log("Step 7: Cleanup complete");
                        }, 100);

                        addToast("✓ Excel (.xlsx) file exported successfully!", 'success');
                        console.log("=== EXPORT COMPLETED SUCCESSFULLY ===");

                    } catch (err) {
                        console.error("=== EXPORT FAILED ===");
                        console.error("Error message:", err.message);
                        console.error("Error stack:", err.stack);
                        addToast("Export failed: " + err.message, 'error');
                    } finally {
                        setIsExportingExcel(false);
                    }
                };

                

                const handleImportFromExcel = () => {
                    excelImportInputRef.current?.click();
                };

                const handleImportExcelFile = (event) => {
                    const file = event.target.files[0];
                    if (!file) return;

                    openConfirm({
                        title: TRANSLATIONS.importFromExcel,
                        message: TRANSLATIONS.importExcelConfirm,
                        confirmText: TRANSLATIONS.importExcelAction,
                        confirmClass: 'bg-blue-600 hover:bg-blue-500',
                        onConfirm: () => {
                            closeConfirm();
                            setIsImporting(true);

                            setTimeout(async () => {
                                try {
                                    const reader = new FileReader();
                                    const lowerName = (file.name || '').toLowerCase();
                                    const isCsv = lowerName.endsWith('.csv') || file.type === 'text/csv';

                                    if (isCsv) {
                                        // Parse CSV as text (simple, tolerant parser)
                                        reader.onload = async (e) => {
                                            try {
                                                const text = e.target.result;
                                                // Normalize line endings and split
                                                const lines = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n').split('\n').filter(l => l.trim() !== '');
                                                if (lines.length === 0) throw new Error('Empty CSV file');

                                                const headerLine = lines[0];
                                                const headers = headerLine.split(',').map(h => h.trim().replace(/^"|"$/g, '').toLowerCase());

                                                const rows = lines.slice(1).map(line => {
                                                    // naive CSV split - handles simple comma-separated with quotes removed
                                                    const cols = line.split(',').map(c => c.trim().replace(/^"|"$/g, ''));
                                                    const obj = {};
                                                    headers.forEach((h, i) => obj[h] = cols[i]);
                                                    return obj;
                                                });

                                                await processImportedRows(rows);
                                            } catch (innerError) {
                                                console.error('CSV processing error:', innerError);
                                                addToast(TRANSLATIONS.importExcelError, 'error');
                                            } finally {
                                                setIsImporting(false);
                                            }
                                        };
                                        reader.onerror = () => {
                                            addToast(TRANSLATIONS.importExcelError, 'error');
                                            setIsImporting(false);
                                        };
                                        reader.readAsText(file, 'utf-8');
                                    } else {
                                        // Ensure XLSX library is available before attempting to parse
                                        const ensureXLSXLoadedForImport = () => {
                                            return new Promise((resolve, reject) => {
                                                if (window.XLSX) return resolve();
                                                const existing = document.querySelector('script[data-xlsx-loader]');
                                                if (existing) {
                                                    existing.addEventListener('load', () => window.XLSX ? resolve() : reject(new Error('XLSX missing after load')));
                                                    existing.addEventListener('error', () => reject(new Error('Failed to load XLSX')));
                                                    return;
                                                }
                                                // Try local copy first, then CDN
                                                const tryLoadImport = (src) => {
                                                    return new Promise((res, rej) => {
                                                        const sc = document.createElement('script');
                                                        sc.setAttribute('data-xlsx-loader', '1');
                                                        sc.src = src;
                                                        sc.onload = () => res(sc);
                                                        sc.onerror = () => rej(new Error('Failed to load ' + src));
                                                        document.head.appendChild(sc);
                                                    });
                                                };

                                                tryLoadImport('assets/xlsx.full.min.js').then(() => {
                                                    if (window.XLSX) return resolve();
                                                    return tryLoadImport('https://cdn.jsdelivr.net/npm/xlsx@0.18.9/dist/xlsx.full.min.js').then(() => window.XLSX ? resolve() : reject(new Error('XLSX missing after CDN load'))).catch(reject);
                                                }).catch(() => {
                                                    tryLoadImport('https://cdn.jsdelivr.net/npm/xlsx@0.18.9/dist/xlsx.full.min.js').then(() => window.XLSX ? resolve() : reject(new Error('XLSX missing after CDN load'))).catch(reject);
                                                });
                                            });
                                        };

                                        try {
                                            await ensureXLSXLoadedForImport();
                                        } catch (loadErr) {
                                            console.error('Failed to load XLSX for import:', loadErr);
                                            addToast(TRANSLATIONS.importExcelError, 'error');
                                            setIsImporting(false);
                                            return;
                                        }
                                        // Assume Excel binary
                                        reader.onload = async (e) => {
                                            try {
                                                const data = new Uint8Array(e.target.result);
                                                const workbook = XLSX.read(data, { type: 'array' });
                                                const sheetName = workbook.SheetNames[0];
                                                const worksheet = workbook.Sheets[sheetName];
                                                const json = XLSX.utils.sheet_to_json(worksheet, { defval: null });
                                                // Normalize keys to lower-case for mapping
                                                const rows = json.map(r => {
                                                    const obj = {};
                                                    Object.keys(r).forEach(k => obj[k.toString().trim().toLowerCase()] = r[k]);
                                                    return obj;
                                                });

                                                await processImportedRows(rows);
                                            } catch (innerError) {
                                                console.error("Excel processing error:", innerError);
                                                addToast(TRANSLATIONS.importExcelError, 'error');
                                            } finally {
                                                setIsImporting(false);
                                            }
                                        };
                                        reader.onerror = () => {
                                            addToast(TRANSLATIONS.importExcelError, 'error');
                                            setIsImporting(false);
                                        };
                                        reader.readAsArrayBuffer(file);
                                    }

                                } catch (error) {
                                    console.error("Import from Excel error:", error);
                                    addToast(TRANSLATIONS.importExcelError, 'error');
                                    setIsImporting(false);
                                } finally {
                                    event.target.value = null;
                                }
                            }, 50);
                        }
                    });
                };

                // Process imported rows (accepts rows with lower-case keys)
                const processImportedRows = async (rows) => {
                    try {
                        const allProducts = await dbGetAll(STORES.PRODUCTS);
                        const productMap = new Map(allProducts.map(p => [String(p.id).toLowerCase(), p]));

                        let updatedCount = 0;
                        for (const row of rows) {
                            if (!row) continue;
                            // row keys are expected lower-case if from XLSX path, or already lower-case from CSV parser
                            const keys = Object.keys(row).map(k => k.toString().trim().toLowerCase());

                            // Find ID value from common header names
                            const idKey = keys.find(k => ['id', 'product id', 'productid', 'sku'].includes(k));
                            const priceKey = keys.find(k => k.includes('price'));
                            const qtyKey = keys.find(k => k.includes('qty') || k.includes('quantity'));

                            const productId = idKey ? row[idKey] : null;
                            if (!productId) continue;

                            const mapKey = String(productId).toLowerCase();
                            if (!productMap.has(mapKey)) continue;

                            const product = productMap.get(mapKey);

                            if (priceKey && row[priceKey] !== undefined && row[priceKey] !== null && row[priceKey] !== '') {
                                const parsed = parseFloat(String(row[priceKey]).replace(/[^0-9.\-]/g, ''));
                                product.price = isNaN(parsed) ? product.price : parsed;
                            }
                            if (qtyKey && row[qtyKey] !== undefined && row[qtyKey] !== null && row[qtyKey] !== '') {
                                const parsedQ = parseInt(String(row[qtyKey]).replace(/[^0-9\-]/g, ''), 10);
                                product.quantity = isNaN(parsedQ) ? product.quantity : parsedQ;
                            }

                            await dbPut(STORES.PRODUCTS, product);
                            updatedCount++;
                        }

                        addToast(`${updatedCount} products updated successfully!`, 'success');
                        await refreshView(view);
                    } catch (err) {
                        console.error('Import processing error:', err);
                        addToast(TRANSLATIONS.importExcelError, 'error');
                    }
                };

                const handleExportForSharing = () => {
                    openConfirm({
                        title: TRANSLATIONS.exportForSharing,
                        message: "To create a shareable file, first ensure you export a fresh backup. The latest backup will be embedded into the file.",
                        confirmText: "Export Backup & Create",
                        confirmClass: 'bg-blue-600 hover:bg-blue-500',
                        onConfirm: () => {
                            handleExport();
                            addToast(TRANSLATIONS.exportForSharingSuccess, 'success');
                        }
                    });
                };

                const handleHomeClick = (newView = { type: 'brands' }) => {
                    setSearchTerm('');
                    setActiveSearch('');
                    refreshView(newView);
                };

                const clearSearch = () => {
                    handleHomeClick();
                };

                if (isLoading) {
                    return (
                        <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', minHeight: '100vh', color: 'black' }} className="dark:text-white bg-slate-100 dark:bg-slate-950">
                            <svg className="animate-spin -ml-1 mr-3 h-8 w-8" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                                <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                            </svg>
                            {loadingMessage}
                        </div>
                    )
                }

                if (isImporting) {
                    return (
                        <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', minHeight: '100vh', color: 'black' }} className="dark:text-white bg-slate-100 dark:bg-slate-950">
                            <svg className="animate-spin -ml-1 mr-3 h-8 w-8" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                                <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                            </svg>
                            {TRANSLATIONS.importingData}
                        </div>
                    )
                }

                const headerProps = {
                    searchTerm, setSearchTerm, performSearch, activeSearch, clearSearch, handleHomeClick,
                    handleAiFeatureClick, setIsAssistantOpen, setIsCameraSearchOpen,
                    setIsWelcomeSettingsOpen, handleImportFromExcel, isImporting, handleExportToExcel, isExportingExcel,
                    handleExportForSharing, setIsApiKeyModalOpen, handleImport, handleExport,
                    theme, setTheme, exitManagementMode, lightboxImage, isHeaderMenuOpen, setIsHeaderMenuOpen,
                    setIsFooterSettingsOpen
                };

                const renderView = () => {
                    if (view.type === 'controlPanel') {
                        return <ControlPanel
                            setView={refreshView}
                            openModal={openModal}
                            openConfirm={openConfirm}
                            addToast={addToast}
                            handleDelete={handleDelete}
                            handleWipeAllData={handleWipeAllData}
                            setIsWelcomeSettingsOpen={setIsWelcomeSettingsOpen}
                            setIsApiKeyModalOpen={setIsApiKeyModalOpen}
                            setIsFooterSettingsOpen={setIsFooterSettingsOpen}
                            handleImport={handleImport}
                            handleExport={handleExport}
                            handleImportFromExcel={handleImportFromExcel}
                            handleExportToExcel={handleExportToExcel}
                            isExportingExcel={isExportingExcel}
                            isImporting={isImporting}
                            lang={lang}
                        />;
                    }

                    let content;

                    // 1. Product Detail View
                    if (view.type === 'productDetail') {
                        content = <ProductDetailView
                            product={view.product}
                            brand={view.brand}
                            category={view.category}
                            lang={lang}
                            addToast={addToast}
                            setLightboxImage={setLightboxImage}
                            breadcrumbs={breadcrumbs}
                            setView={refreshView}
                        />;
                    }
                    // 2. Generic Grid Views (Products, Search Results)
                    // We use this for 'products' and 'searchResults'. 
                    // For 'categories', we prefer HomePageContent (Brand View) unless explicitly in management mode or search.
                    // However, navigation from breadcrumbs might trigger 'categories'. 
                    // If view.type is 'categories', we can show the generic grid as a fallback or for deep navigation.
                    else if (view.type === 'products' || view.type === 'searchResults' || view.type === 'categories') {
                        const viewContext = { brandId: view.brandId, categoryId: view.categoryId };
                        let gridViewType = 'brand';
                        if (view.type === 'categories') gridViewType = 'category';
                        if (view.type === 'products') gridViewType = 'product';
                        if (view.type === 'searchResults') gridViewType = 'searchResults';

                        content = (
                            <div className="p-4 sm:p-6 lg:p-8 min-h-full">
                                {(view.type !== 'brands' && breadcrumbs.length > 0) && (
                                    <div className="flex-shrink-0 mb-6 z-10 transition-all duration-300 ease-in-out">
                                        <div className="flex items-center text-sm text-slate-600 dark:text-slate-400 overflow-x-auto whitespace-nowrap bg-white/50 dark:bg-black/20 backdrop-blur-md p-2 rounded-lg inline-flex shadow-sm">
                                            <button onClick={() => refreshView({ type: 'brands' })} className="hover:text-blue-500 dark:hover:text-blue-400 transition-colors flex-shrink-0 px-2 font-medium">
                                                {TRANSLATIONS.brands}
                                            </button>
                                            {breadcrumbs.map((crumb, index) => (
                                                <span key={index} className="flex items-center flex-shrink-0">
                                                    <span className="mx-1 text-slate-400 dark:text-slate-500">/</span>
                                                    <button
                                                        onClick={() => {
                                                            if (crumb.type === 'brand') refreshView({ type: 'categories', brandId: crumb.id });
                                                        }}
                                                        className={`hover:text-blue-500 dark:hover:text-blue-400 transition-colors px-2 ${index === breadcrumbs.length - 1 ? 'font-bold text-slate-800 dark:text-slate-200 pointer-events-none' : ''}`}
                                                    >
                                                        {getLocalizedTitle(crumb.name, lang)}
                                                    </button>
                                                </span>
                                            ))}
                                        </div>
                                    </div>
                                )}
                                {view.type === 'searchResults' ? (
                                    <SearchResultsView results={currentItems} setView={refreshView} lang={lang} searchTerm={activeSearch} />
                                ) : (
                                    <GridView
                                        items={currentItems}
                                        type={gridViewType}
                                        context={viewContext}
                                        setView={refreshView}
                                        openModal={openModal}
                                        openConfirm={openConfirm}
                                        handleDelete={handleDelete}
                                        lang={lang}
                                        isManagementMode={isManagementMode}
                                    />
                                )}
                            </div>
                        );
                    }
                    // 3. Home / Brands View (Default)
                    else {
                        content = (
                            <>
                                <div className="relative z-10 bg-slate-100 dark:bg-slate-950 shadow-xl">
                                    <HeroSection
                                        onEnterManagement={enterManagementMode}
                                        welcomeImages={welcomeImages}
                                        welcomeBackgroundType={welcomeBackgroundType}
                                        welcomeBackgroundVideo={welcomeBackgroundVideo}
                                    />
                                    <HeroMediaBlock block={heroMediaBlock} />
                                    <HomePageContent
                                        brands={allBrands}
                                        categories={allCategories}
                                        setView={refreshView}
                                        isManagementMode={isManagementMode}
                                        openModal={openModal}
                                        openConfirm={openConfirm}
                                        handleDelete={handleDelete}
                                        lang={lang}
                                        welcomeVideo={welcomeVideo}
                                    />
                                </div>
                                <FooterSection settings={footerSettings} setFooterHeight={setFooterHeight} />
                            </>
                        );
                    }

                    return (
                        <div className={`min-h-screen w-full flex flex-col relative ${view.type === 'brands' || isManagementMode ? 'bg-black dark:bg-slate-950' : 'bg-slate-100 dark:bg-slate-950 text-slate-900 dark:text-slate-100'}`}>
                            {isManagementMode && <DesktopHeader {...headerProps} />}
                            {isManagementMode && <MobileHeader {...headerProps} />}
                            <main className="flex-grow w-full relative z-10" ref={mainContentRef}>
                                {content}
                            </main>
                        </div>
                    );
                }

                return (
                    <>
                        {renderView()}

                        {/* Global Modals & Components */}
                        <ToastContainer toasts={toasts} dismissToast={dismissToast} />
                        {modal.isOpen && <EntityModal key={modal.key} {...modal} onSave={handleSave} onClose={closeModal} lang={lang} addToast={addToast} aiInstance={aiInstance} handleAiFeatureClick={handleAiFeatureClick} />}
                        <ConfirmModal {...confirmModal} onClose={closeConfirm} />
                        <CameraSearchModal isOpen={isCameraSearchOpen} onClose={() => setIsCameraSearchOpen(false)} onCapture={handleCaptureAndSearch} addToast={addToast} />
                        <ApiKeyModal isOpen={isApiKeyModalOpen} onClose={() => setIsApiKeyModalOpen(false)} onSave={handleSaveApiKey} />
                        <AssistantModal
                            isOpen={isAssistantOpen}
                            onClose={() => setIsAssistantOpen(false)}
                            aiInstance={aiInstance}
                            addToast={addToast}
                            setView={refreshView}
                            performSearch={performSearch}
                            setSearchTerm={setSearchTerm}
                        />
                        <Lightbox imageUrl={lightboxImage} onClose={() => setLightboxImage(null)} />
                        {isWelcomeSettingsOpen && (
                            <WelcomeSettingsModal
                                isOpen={isWelcomeSettingsOpen}
                                onClose={() => setIsWelcomeSettingsOpen(false)}
                                onSave={handleSaveWelcomeSettings}
                                addToast={addToast}
                            />
                        )}
                        <FooterSettingsModal
                            isOpen={isFooterSettingsOpen}
                            onClose={() => setIsFooterSettingsOpen(false)}
                            onSave={handleSaveFooterSettings}
                            initialSettings={footerSettings}
                            addToast={addToast}
                        />

                        {/* Hidden file inputs for import */}
                        <input type="file" ref={jsonImportInputRef} className="hidden" accept=".json" onChange={handleImportFile} />
                        <input type="file" ref={excelImportInputRef} className="hidden" accept=".xlsx, .xls, .csv" onChange={handleImportExcelFile} />
                    </>
                );
            }

            // Log app startup info
            console.log('%c🚀 GALSTIAN Catalog Loaded', 'color: gold; font-size: 18px; font-weight: bold;');
            console.log('%cVersion: 2025-12-21-fixes', 'color: lightblue;');
            console.log('%cCache Version:', 'color: lightblue;', CACHE_VERSION);
            console.log('%cDB Name:', 'color: lightblue;', DB_NAME);

            // Debug helper removed — no floating debug button in production.

            ReactDOM.createRoot(document.getElementById('root')).render(<App />);

            // Auto-run unregister/clear helpers when `?clearSw=1` is present in the URL.
            try {
                if (typeof location !== 'undefined' && location.search && location.search.indexOf('clearSw=1') !== -1) {
                    (async () => {
                        try {
                            if (typeof unregisterServiceWorkersAndClearCaches === 'function') {
                                console.log('clearSw flag detected — unregistering service workers and clearing caches...');
                                await unregisterServiceWorkersAndClearCaches();
                                console.log('Service workers and caches cleared (auto).');
                                // give the user a hint in-page
                                try { alert('Service workers and caches cleared. Please hard-refresh the page (Ctrl+Shift+R).'); } catch(e){}
                            } else {
                                console.warn('unregisterServiceWorkersAndClearCaches helper not available yet.');
                            }
                        } catch (e) { console.warn('Auto-clear failed', e); }
                    })();
                }
            } catch (e) {}
        };
    </script>
    <script>
        // Debug layout helper: enable by adding #debug-layout to the URL
        (function () {
            try {
                if (location.hash && location.hash.indexOf('debug-layout') !== -1) {
                    const style = document.createElement('style');
                    style.id = 'debug-layout-styles';
                    style.innerHTML = `
                        /* Outline all elements to inspect spacing */
                        body * { outline: 1px dashed rgba(255,0,0,0.18) !important; }
                        footer { outline: 3px solid rgba(0,160,0,0.9) !important; }
                        header, main, section, article, div { outline-offset: -2px; }
                        /* Make footer visually distinct */
                        footer { background-image: linear-gradient(transparent, rgba(0,0,0,0.02)); }
                    `;
                    document.head.appendChild(style);

                    const logRects = () => {
                        const footer = document.querySelector('footer');
                        const main = document.querySelector('main');
                        console.log('--- Layout debug (hash: debug-layout) ---');
                        if (main) console.log('MAIN rect:', main.getBoundingClientRect());
                        if (footer) console.log('FOOTER rect:', footer.getBoundingClientRect());
                        const lastVisible = Array.from(document.querySelectorAll('body *')).filter(n => n.getBoundingClientRect().height > 0).slice(-10);
                        console.log('Last visible elements:', lastVisible.map(n => ({ tag: n.tagName, cls: n.className, rect: n.getBoundingClientRect() })));
                    };

                    window.addEventListener('load', () => setTimeout(logRects, 300));
                    window.addEventListener('resize', () => setTimeout(logRects, 120));
                    console.log('Layout debug: outlines enabled. Resize or scroll to update logs.');
                }
            } catch (e) {
                console.warn('Could not enable layout debug script', e);
            }
        })();
    </script>
</body>

</html>